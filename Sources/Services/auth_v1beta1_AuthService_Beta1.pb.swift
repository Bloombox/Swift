// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: auth/v1beta1/AuthService_Beta1.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies the Auth API, which provides features for authenticating/authorizing users, managing consent status, and
/// the issuance/management of digital ID cards.

import Foundation
import OpenCannabis
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates known errors that may be thrown by auth operations.
public enum Bloombox_Services_Auth_V1beta1_AuthError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// There was no error.
  case noError // = 0

  /// Access was denied: the user's account is suspended.
  case accountSuspended // = 1

  /// Profile could not be located.
  case profileNotFound // = 2

  /// The provided user key was found to be invalid.
  case invalidUserKey // = 3

  /// The provided auth assertion was deemed to be invalid.
  case invalidAssertion // = 4

  /// The specified authentication type is not currently supported.
  case unsupportedLoginType // = 5

  /// Authentication token from Hydra was not valid.
  case invalidAuthToken // = 6

  /// The ticket provided for consent was invalid.
  case invalidTicket // = 7

  /// The client's profile could not be located.
  case clientNotFound // = 8

  /// Consent ID is not valid.
  case invalidConsentID // = 9

  /// The provided ID token information was found to be invalid.
  case invalidIDToken // = 10

  /// The provided access token information was found to be invalid.
  case invalidAccessToken // = 11

  /// The provided ID token was found to be expired.
  case expiredIDToken // = 12

  /// The provided access token was found to be expired.
  case expiredAccessToken // = 13

  /// The specified client was invalid.
  case invalidClient // = 14

  /// The specified origin was invalid.
  case invalidOrigin // = 15

  /// Access was denied for unspecified reasons.
  case accessDenied // = 16

  /// The provided session value was invalid.
  case invalidSession // = 17

  /// The provided session has expired.
  case expiredSession // = 18

  /// The provided fingerprint value was invalid.
  case invalidFingerprint // = 19

  /// Captcha verification value was invalid.
  case invalidCaptcha // = 20

  /// The provided captcha veriication value was not correct.
  case captchaRejected // = 21

  /// The specified consent ID could not be resolved.
  case consentNotFound // = 22

  /// Consent operation or consent record has expired.
  case expiredConsent // = 23

  /// The specified nonce was missing, invalid, or already used.
  case invalidNonce // = 24

  /// A signature was required but none was found.
  case signatureRequired // = 25

  /// The signature was invalid or could not be loaded/decoded.
  case signatureInvalid // = 26

  /// The signature did not pass verification.
  case signatureMismatch // = 27

  /// An internal error was encountered.
  case internalError // = 99
  case UNRECOGNIZED(Int)

  public init() {
    self = .noError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 1: self = .accountSuspended
    case 2: self = .profileNotFound
    case 3: self = .invalidUserKey
    case 4: self = .invalidAssertion
    case 5: self = .unsupportedLoginType
    case 6: self = .invalidAuthToken
    case 7: self = .invalidTicket
    case 8: self = .clientNotFound
    case 9: self = .invalidConsentID
    case 10: self = .invalidIDToken
    case 11: self = .invalidAccessToken
    case 12: self = .expiredIDToken
    case 13: self = .expiredAccessToken
    case 14: self = .invalidClient
    case 15: self = .invalidOrigin
    case 16: self = .accessDenied
    case 17: self = .invalidSession
    case 18: self = .expiredSession
    case 19: self = .invalidFingerprint
    case 20: self = .invalidCaptcha
    case 21: self = .captchaRejected
    case 22: self = .consentNotFound
    case 23: self = .expiredConsent
    case 24: self = .invalidNonce
    case 25: self = .signatureRequired
    case 26: self = .signatureInvalid
    case 27: self = .signatureMismatch
    case 99: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noError: return 0
    case .accountSuspended: return 1
    case .profileNotFound: return 2
    case .invalidUserKey: return 3
    case .invalidAssertion: return 4
    case .unsupportedLoginType: return 5
    case .invalidAuthToken: return 6
    case .invalidTicket: return 7
    case .clientNotFound: return 8
    case .invalidConsentID: return 9
    case .invalidIDToken: return 10
    case .invalidAccessToken: return 11
    case .expiredIDToken: return 12
    case .expiredAccessToken: return 13
    case .invalidClient: return 14
    case .invalidOrigin: return 15
    case .accessDenied: return 16
    case .invalidSession: return 17
    case .expiredSession: return 18
    case .invalidFingerprint: return 19
    case .invalidCaptcha: return 20
    case .captchaRejected: return 21
    case .consentNotFound: return 22
    case .expiredConsent: return 23
    case .invalidNonce: return 24
    case .signatureRequired: return 25
    case .signatureInvalid: return 26
    case .signatureMismatch: return 27
    case .internalError: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Services_Auth_V1beta1_AuthError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Services_Auth_V1beta1_AuthError] = [
    .noError,
    .accountSuspended,
    .profileNotFound,
    .invalidUserKey,
    .invalidAssertion,
    .unsupportedLoginType,
    .invalidAuthToken,
    .invalidTicket,
    .clientNotFound,
    .invalidConsentID,
    .invalidIDToken,
    .invalidAccessToken,
    .expiredIDToken,
    .expiredAccessToken,
    .invalidClient,
    .invalidOrigin,
    .accessDenied,
    .invalidSession,
    .expiredSession,
    .invalidFingerprint,
    .invalidCaptcha,
    .captchaRejected,
    .consentNotFound,
    .expiredConsent,
    .invalidNonce,
    .signatureRequired,
    .signatureInvalid,
    .signatureMismatch,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

/// Specifies a message payload wherein a user is asserting their identity via an email-based username and a regular
/// string password, encoded and potentially encrypted by the frontend agent.
public struct Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Email address the user is logging in with.
  public var email: String = String()

  /// User's specified account password. Expressed as a hex-encoded hashed MD5, or at least Base64-encoded when sent in
  /// cleartext, and always over a secure connection.
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a message payload containing a Firebase ID token provided during an auth flow on the frontend.
public struct Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Firebase identity token.
  public var token: String = String()

  /// User's ID.
  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a generic assertion for account access privileges.
public struct Bloombox_Services_Auth_V1beta1_AccountAssertion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Assertion provided by the user, based on their chosen login method.
  public var assertion: OneOf_Assertion? {
    get {return _storage._assertion}
    set {_uniqueStorage()._assertion = newValue}
  }

  /// Email/Password-based account login.
  public var emailPassword: Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion {
    get {
      if case .emailPassword(let v)? = _storage._assertion {return v}
      return Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion()
    }
    set {_uniqueStorage()._assertion = .emailPassword(newValue)}
  }

  /// Firebase account login.
  public var firebase: Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion {
    get {
      if case .firebase(let v)? = _storage._assertion {return v}
      return Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion()
    }
    set {_uniqueStorage()._assertion = .firebase(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Assertion provided by the user, based on their chosen login method.
  public enum OneOf_Assertion: Equatable {
    /// Email/Password-based account login.
    case emailPassword(Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion)
    /// Firebase account login.
    case firebase(Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Services_Auth_V1beta1_AccountAssertion.OneOf_Assertion, rhs: Bloombox_Services_Auth_V1beta1_AccountAssertion.OneOf_Assertion) -> Bool {
      switch (lhs, rhs) {
      case (.emailPassword(let l), .emailPassword(let r)): return l == r
      case (.firebase(let l), .firebase(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies an RPC operation wherein a user has requested an assertion of their identity be validated by the server.
public struct Bloombox_Services_Auth_V1beta1_AuthenticateUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to authenticate a user.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Provider the user would like to login with.
    public var provider: Bloombox_Identity_IdentityProvider {
      get {return _storage._provider}
      set {_uniqueStorage()._provider = newValue}
    }

    /// Login credentials provided by the user or Firebase.
    public var assertion: Bloombox_Services_Auth_V1beta1_AccountAssertion {
      get {return _storage._assertion ?? Bloombox_Services_Auth_V1beta1_AccountAssertion()}
      set {_uniqueStorage()._assertion = newValue}
    }
    /// Returns true if `assertion` has been explicitly set.
    public var hasAssertion: Bool {return _storage._assertion != nil}
    /// Clears the value of `assertion`. Subsequent reads from it will return its default value.
    public mutating func clearAssertion() {_uniqueStorage()._assertion = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to authenticate a user.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates the user's identity ID.
    public var uid: String = String()

    /// Indicates the user's account key.
    public var key: String = String()

    /// Authorized token resulting from the authentication operation.
    public var token: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an operation to resolve authorized access credentials for Firebase and other services, based on a completed
/// authentication and authorization/consent flow.
public struct Bloombox_Services_Auth_V1beta1_ResolveToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to generate a platform authorization token.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// OAuth2 client ID.
    public var clientID: String {
      get {return _storage._clientID}
      set {_uniqueStorage()._clientID = newValue}
    }

    /// Encoded source origin.
    public var origin: String {
      get {return _storage._origin}
      set {_uniqueStorage()._origin = newValue}
    }

    /// State token for the active authentication flow.
    public var state: String {
      get {return _storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// Captcha code to be used via reCAPTCHA.
    public var captcha: String {
      get {return _storage._captcha}
      set {_uniqueStorage()._captcha = newValue}
    }

    /// Active session ID.
    public var session: String {
      get {return _storage._session}
      set {_uniqueStorage()._session = newValue}
    }

    /// Active device fingerprint.
    public var fingerprint: String {
      get {return _storage._fingerprint}
      set {_uniqueStorage()._fingerprint = newValue}
    }

    /// Combined authentication/authorization ticket.
    public var auth: Bloombox_Security_AuthPayload {
      get {return _storage._auth ?? Bloombox_Security_AuthPayload()}
      set {_uniqueStorage()._auth = newValue}
    }
    /// Returns true if `auth` has been explicitly set.
    public var hasAuth: Bool {return _storage._auth != nil}
    /// Clears the value of `auth`. Subsequent reads from it will return its default value.
    public mutating func clearAuth() {_uniqueStorage()._auth = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to generate a platform authorization token.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resulting JSON web token, for main application use.
    public var app: String = String()

    /// Resulting JSON web token, for DB use.
    public var db: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an operation wherein a user is demonstrating or indicating a decision regarding a consent flow, and would
/// like to proceed with the next sensible action.
public struct Bloombox_Services_Auth_V1beta1_ConsentDecision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request indicating an acceptance of the consent challenge - or, 'authorizing' a consent flow.
  public struct Accept {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID from the on-page access or identity token.
    public var uid: String = String()

    /// ID for the consent flow.
    public var consent: String = String()

    /// Scope(s) granted in the consent flow.
    public var scope: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Request indicating a rejection of the consent challenge - or, 'denying' a consent flow.
  public struct Reject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID from the on-page access or identity token.
    public var uid: String = String()

    /// ID for the consent flow.
    public var consent: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Specifies the response payload for a consent decision indication.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an operation to build a full user context after a successful ID and authorization/consent flow, including
/// a fresh JWT, resolved user key and profile, and access roles/rights related to particular partner/location scopes.
public struct Bloombox_Services_Auth_V1beta1_UserContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to retrieve materialized user authentication context. Must include valid, one-use cryptographic information
  /// along with the resulting ID and access tokens from the auth flow.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User's identity ID, or 'uid'.
    public var uid: String = String()

    /// Active session ID for the user.
    public var session: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response to a request to retrieve materialized user authentication context. Either specified an error or a set of
  /// materialized credential data.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User profile key.
    public var key: String {
      get {return _storage._key}
      set {_uniqueStorage()._key = newValue}
    }

    /// User's profile object.
    public var profile: Bloombox_Identity_User {
      get {return _storage._profile ?? Bloombox_Identity_User()}
      set {_uniqueStorage()._profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return _storage._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {_uniqueStorage()._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Retrieve a user's profile by their profile key.
public struct Bloombox_Services_Auth_V1beta1_GetProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to get a user's profile object from the database.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// key to reference the profile user's object from the database.
    public var user: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response to a request to get a user's profile object.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User's profile object.
    public var profile: Bloombox_Identity_User {
      get {return _storage._profile ?? Bloombox_Identity_User()}
      set {_uniqueStorage()._profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return _storage._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {_uniqueStorage()._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies an RPC operation to perform a consent flow through Hydra.
public struct Bloombox_Services_Auth_V1beta1_ConsentFlow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to perform a consent flow.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID value of the consent request.
    public var consent: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response to a request to perform a consent flow.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Consent ticket returned from Hydra.
    public var ticket: Opencannabis_Oauth_ConsentTicket {
      get {return _storage._ticket ?? Opencannabis_Oauth_ConsentTicket()}
      set {_uniqueStorage()._ticket = newValue}
    }
    /// Returns true if `ticket` has been explicitly set.
    public var hasTicket: Bool {return _storage._ticket != nil}
    /// Clears the value of `ticket`. Subsequent reads from it will return its default value.
    public mutating func clearTicket() {_uniqueStorage()._ticket = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies a one-time use "nonce," or, "number-used-once," which can be used to initiate a secure authorization flow.
/// Client devices and applications request this value before proceeding to verify the user's identity, and then provide
/// it in the identity assertion token later passed to the server during "connect" or "context"-phase methods.
public struct Bloombox_Services_Auth_V1beta1_AuthNonce {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the authentication nonce value, which is required to perform an authentication flow. This is an opaque
  /// value that may be used once, and only once.
  public var nonce: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies an RPC operation to connect a validated and signed user identity with their account. If the user has done
/// this before, there will be an existing consumer-side account - if not, an account is created under the hood, and
/// auto-linked with their identity.
public struct Bloombox_Services_Auth_V1beta1_IdentityConnect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to link a validated and signed user identity with an account.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identity token. This value is generated between the user's UID, an authentication nonce acquired from this
    /// service, and a timestamp. That pre-image value is then hashed with SHA512 and signed with a private key in the
    /// user's device, stored in a secure hardware enclave. The user must unlock the enclave with biometrics in order to
    /// perform this signature, so, it represents a cryptographic assertion that binds the user's ID with the private key
    /// on their device, and their biometric profile.
    public var token: String = String()

    /// APNS push token. This value is provided to the device via the Apple Push Notification System (APNS), when it
    /// registers for remote notifications, and is used to issue push notifications under the subject application's
    /// credentials. This value is only provided when the originating device is running iOS, and the user has authorized
    /// push notification access to the subject application.
    public var apns: String = String()

    /// FCM push token. This value is provided to the device by Google's systems when it performs registration with
    /// Firebase Cloud Messaging, and is used to address the user's specific device for push notifications. On iOS, this
    /// only applies when the application is open - FCM then usually proxies to APNS. On Android and web-based platforms,
    /// this is the primary push key.
    public var fcm: String = String()

    /// Raw content of the user's public key, hex-encoded. The public key must be stored in hardware memory on the user's
    /// device, where it is used to sign the token payload, along with a matching private key, which is used to sign the
    /// provided token payload when asserting the user's identity. The key provided here is used to verify the resulting
    /// digital signature, embedded in the token in the "sig" attribute.
    public var key: String = String()

    /// Client application that is making this request. Because this is included in the hashed signature pre-image,
    /// embedded in the token and signed by the user's key, it must be provided here for later verification. The public
    /// key specified in this request may be persisted for this client application, such that any future requests are
    /// expected to be signed with the same key.
    public var client: String = String()

    /// Specifies the device fingerprint, which is usually a standard UUID, uppercased. This value is generated on a per-
    /// device-per-app basis, and so, it may change as the app is updated on the subject user's device. Early in the app
    /// boot sequence, it should generate the fingerprint value and persist it to storage.
    public var device: String = String()

    /// Specifies the nonce value provided to the application by server-side systems, in order to authorize the client
    /// device's participation in this authorization routine. Client applications must specify a valid API key in order
    /// to request this value, and the API key is tied to the client ID, so both are validated by the presence of this
    /// nonce, if it is determined not to have already been used, and matches the token's signature.
    public var nonce: String = String()

    /// Advertising identifier for the subject user. In some circumstances, particularly iOS, the device fingerprint is
    /// not a stable identifier for the user. The Ad ID allows the user account in question to be tied to advertising
    /// and marketing tools. This is done with the user's consent once they setup their account and bind it to their
    /// device, along with their secure-enclave-protected public key.
    public var adid: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response to a request to link a user identity to an account.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resolved key for the subject user. A user key is distinguished from a UID, in that it addresses an actual account
    /// and user profile payload, rather than just pointing to an identity that can be linked to a full account. User
    /// keys are used for interacting with the API in an identity agnostic manner, post-authorization.
    public var key: Bloombox_Identity_UserKey {
      get {return _storage._key ?? Bloombox_Identity_UserKey()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    /// Authorization token, issued in response to the ID token provided in the request. Issued and signed by the server
    /// to indicate applicable top-level user permissions, and implies the user account was authenticated, authorized,
    /// and enabled to use the state associated with this token.
    public var token: Bloombox_Security_AuthToken {
      get {return _storage._token ?? Bloombox_Security_AuthToken()}
      set {_uniqueStorage()._token = newValue}
    }
    /// Returns true if `token` has been explicitly set.
    public var hasToken: Bool {return _storage._token != nil}
    /// Clears the value of `token`. Subsequent reads from it will return its default value.
    public mutating func clearToken() {_uniqueStorage()._token = nil}

    public var result: OneOf_Result? {
      get {return _storage._result}
      set {_uniqueStorage()._result = newValue}
    }

    /// Resulting user profile, either generated from the user based on the provided identity information, or returned
    /// from an earlier enrollment/authentication process, where it was established and confirmed by the user.
    public var profile: Bloombox_Identity_User {
      get {
        if case .profile(let v)? = _storage._result {return v}
        return Bloombox_Identity_User()
      }
      set {_uniqueStorage()._result = .profile(newValue)}
    }

    /// Flag indicating that the user needs to perform setup in order to establish a profile. If `setup` is seen as
    /// true, it will trigger the client-side application to enter a signup flow, which must pre-adopt the identity
    /// data provided earlier in the flow by the client device.
    public var setup: Bool {
      get {
        if case .setup(let v)? = _storage._result {return v}
        return false
      }
      set {_uniqueStorage()._result = .setup(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Result: Equatable {
      /// Resulting user profile, either generated from the user based on the provided identity information, or returned
      /// from an earlier enrollment/authentication process, where it was established and confirmed by the user.
      case profile(Bloombox_Identity_User)
      /// Flag indicating that the user needs to perform setup in order to establish a profile. If `setup` is seen as
      /// true, it will trigger the client-side application to enter a signup flow, which must pre-adopt the identity
      /// data provided earlier in the flow by the client device.
      case setup(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Services_Auth_V1beta1_IdentityConnect.Response.OneOf_Result, rhs: Bloombox_Services_Auth_V1beta1_IdentityConnect.Response.OneOf_Result) -> Bool {
        switch (lhs, rhs) {
        case (.profile(let l), .profile(let r)): return l == r
        case (.setup(let l), .setup(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct Bloombox_Services_Auth_V1beta1_ProfileUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// key to reference the profile user's object from the database.
    public var user: String {
      get {return _storage._user}
      set {_uniqueStorage()._user = newValue}
    }

    /// Profile to update the user profile with.
    public var profile: Bloombox_Identity_User {
      get {return _storage._profile ?? Bloombox_Identity_User()}
      set {_uniqueStorage()._profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return _storage._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {_uniqueStorage()._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.services.auth.v1beta1"

extension Bloombox_Services_Auth_V1beta1_AuthError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    1: .same(proto: "ACCOUNT_SUSPENDED"),
    2: .same(proto: "PROFILE_NOT_FOUND"),
    3: .same(proto: "INVALID_USER_KEY"),
    4: .same(proto: "INVALID_ASSERTION"),
    5: .same(proto: "UNSUPPORTED_LOGIN_TYPE"),
    6: .same(proto: "INVALID_AUTH_TOKEN"),
    7: .same(proto: "INVALID_TICKET"),
    8: .same(proto: "CLIENT_NOT_FOUND"),
    9: .same(proto: "INVALID_CONSENT_ID"),
    10: .same(proto: "INVALID_ID_TOKEN"),
    11: .same(proto: "INVALID_ACCESS_TOKEN"),
    12: .same(proto: "EXPIRED_ID_TOKEN"),
    13: .same(proto: "EXPIRED_ACCESS_TOKEN"),
    14: .same(proto: "INVALID_CLIENT"),
    15: .same(proto: "INVALID_ORIGIN"),
    16: .same(proto: "ACCESS_DENIED"),
    17: .same(proto: "INVALID_SESSION"),
    18: .same(proto: "EXPIRED_SESSION"),
    19: .same(proto: "INVALID_FINGERPRINT"),
    20: .same(proto: "INVALID_CAPTCHA"),
    21: .same(proto: "CAPTCHA_REJECTED"),
    22: .same(proto: "CONSENT_NOT_FOUND"),
    23: .same(proto: "EXPIRED_CONSENT"),
    24: .same(proto: "INVALID_NONCE"),
    25: .same(proto: "SIGNATURE_REQUIRED"),
    26: .same(proto: "SIGNATURE_INVALID"),
    27: .same(proto: "SIGNATURE_MISMATCH"),
    99: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailPasswordAssertion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.email)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion, rhs: Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FirebaseTokenAssertion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularStringField(value: &self.uid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion, rhs: Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_AccountAssertion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountAssertion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "email_password"),
    2: .same(proto: "firebase"),
  ]

  fileprivate class _StorageClass {
    var _assertion: Bloombox_Services_Auth_V1beta1_AccountAssertion.OneOf_Assertion?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assertion = source._assertion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Bloombox_Services_Auth_V1beta1_EmailPasswordAssertion?
          if let current = _storage._assertion {
            try decoder.handleConflictingOneOf()
            if case .emailPassword(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._assertion = .emailPassword(v)}
        case 2:
          var v: Bloombox_Services_Auth_V1beta1_FirebaseTokenAssertion?
          if let current = _storage._assertion {
            try decoder.handleConflictingOneOf()
            if case .firebase(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._assertion = .firebase(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._assertion {
      case .emailPassword(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .firebase(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_AccountAssertion, rhs: Bloombox_Services_Auth_V1beta1_AccountAssertion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._assertion != rhs_storage._assertion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_AuthenticateUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateUser"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_AuthenticateUser, rhs: Bloombox_Services_Auth_V1beta1_AuthenticateUser) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_AuthenticateUser.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_AuthenticateUser.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "assertion"),
  ]

  fileprivate class _StorageClass {
    var _provider: Bloombox_Identity_IdentityProvider = .email
    var _assertion: Bloombox_Services_Auth_V1beta1_AccountAssertion? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _provider = source._provider
      _assertion = source._assertion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._provider)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._assertion)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._provider != .email {
        try visitor.visitSingularEnumField(value: _storage._provider, fieldNumber: 1)
      }
      if let v = _storage._assertion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_AuthenticateUser.Request, rhs: Bloombox_Services_Auth_V1beta1_AuthenticateUser.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._provider != rhs_storage._provider {return false}
        if _storage._assertion != rhs_storage._assertion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_AuthenticateUser.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_AuthenticateUser.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "key"),
    3: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.key)
      case 3: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_AuthenticateUser.Response, rhs: Bloombox_Services_Auth_V1beta1_AuthenticateUser.Response) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.key != rhs.key {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ResolveToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResolveToken"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ResolveToken, rhs: Bloombox_Services_Auth_V1beta1_ResolveToken) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ResolveToken.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ResolveToken.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "origin"),
    3: .same(proto: "state"),
    4: .same(proto: "captcha"),
    5: .same(proto: "session"),
    6: .same(proto: "fingerprint"),
    7: .same(proto: "auth"),
  ]

  fileprivate class _StorageClass {
    var _clientID: String = String()
    var _origin: String = String()
    var _state: String = String()
    var _captcha: String = String()
    var _session: String = String()
    var _fingerprint: String = String()
    var _auth: Bloombox_Security_AuthPayload? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clientID = source._clientID
      _origin = source._origin
      _state = source._state
      _captcha = source._captcha
      _session = source._session
      _fingerprint = source._fingerprint
      _auth = source._auth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._clientID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._origin)
        case 3: try decoder.decodeSingularStringField(value: &_storage._state)
        case 4: try decoder.decodeSingularStringField(value: &_storage._captcha)
        case 5: try decoder.decodeSingularStringField(value: &_storage._session)
        case 6: try decoder.decodeSingularStringField(value: &_storage._fingerprint)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._auth)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._clientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 1)
      }
      if !_storage._origin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._origin, fieldNumber: 2)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 3)
      }
      if !_storage._captcha.isEmpty {
        try visitor.visitSingularStringField(value: _storage._captcha, fieldNumber: 4)
      }
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 5)
      }
      if !_storage._fingerprint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fingerprint, fieldNumber: 6)
      }
      if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ResolveToken.Request, rhs: Bloombox_Services_Auth_V1beta1_ResolveToken.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clientID != rhs_storage._clientID {return false}
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._captcha != rhs_storage._captcha {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._auth != rhs_storage._auth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ResolveToken.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ResolveToken.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "app"),
    2: .same(proto: "db"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.app)
      case 2: try decoder.decodeSingularStringField(value: &self.db)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.app.isEmpty {
      try visitor.visitSingularStringField(value: self.app, fieldNumber: 1)
    }
    if !self.db.isEmpty {
      try visitor.visitSingularStringField(value: self.db, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ResolveToken.Response, rhs: Bloombox_Services_Auth_V1beta1_ResolveToken.Response) -> Bool {
    if lhs.app != rhs.app {return false}
    if lhs.db != rhs.db {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentDecision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsentDecision"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentDecision, rhs: Bloombox_Services_Auth_V1beta1_ConsentDecision) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentDecision.Accept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ConsentDecision.protoMessageName + ".Accept"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "consent"),
    3: .same(proto: "scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.consent)
      case 3: try decoder.decodeRepeatedStringField(value: &self.scope)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.consent.isEmpty {
      try visitor.visitSingularStringField(value: self.consent, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scope, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentDecision.Accept, rhs: Bloombox_Services_Auth_V1beta1_ConsentDecision.Accept) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.consent != rhs.consent {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentDecision.Reject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ConsentDecision.protoMessageName + ".Reject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "consent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.consent)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.consent.isEmpty {
      try visitor.visitSingularStringField(value: self.consent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentDecision.Reject, rhs: Bloombox_Services_Auth_V1beta1_ConsentDecision.Reject) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.consent != rhs.consent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentDecision.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ConsentDecision.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentDecision.Response, rhs: Bloombox_Services_Auth_V1beta1_ConsentDecision.Response) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_UserContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserContext"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_UserContext, rhs: Bloombox_Services_Auth_V1beta1_UserContext) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_UserContext.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_UserContext.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "session"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.session)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_UserContext.Request, rhs: Bloombox_Services_Auth_V1beta1_UserContext.Request) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.session != rhs.session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_UserContext.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_UserContext.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "profile"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _profile: Bloombox_Identity_User? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _profile = source._profile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._key)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._profile)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_UserContext.Response, rhs: Bloombox_Services_Auth_V1beta1_UserContext.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._profile != rhs_storage._profile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_GetProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetProfile"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_GetProfile, rhs: Bloombox_Services_Auth_V1beta1_GetProfile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_GetProfile.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_GetProfile.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.user)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_GetProfile.Request, rhs: Bloombox_Services_Auth_V1beta1_GetProfile.Request) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_GetProfile.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_GetProfile.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  fileprivate class _StorageClass {
    var _profile: Bloombox_Identity_User? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _profile = source._profile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._profile)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_GetProfile.Response, rhs: Bloombox_Services_Auth_V1beta1_GetProfile.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._profile != rhs_storage._profile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentFlow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConsentFlow"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentFlow, rhs: Bloombox_Services_Auth_V1beta1_ConsentFlow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentFlow.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ConsentFlow.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.consent)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.consent.isEmpty {
      try visitor.visitSingularStringField(value: self.consent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentFlow.Request, rhs: Bloombox_Services_Auth_V1beta1_ConsentFlow.Request) -> Bool {
    if lhs.consent != rhs.consent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ConsentFlow.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ConsentFlow.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
  ]

  fileprivate class _StorageClass {
    var _ticket: Opencannabis_Oauth_ConsentTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ticket = source._ticket
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ticket)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ticket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ConsentFlow.Response, rhs: Bloombox_Services_Auth_V1beta1_ConsentFlow.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ticket != rhs_storage._ticket {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_AuthNonce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthNonce"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.nonce)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_AuthNonce, rhs: Bloombox_Services_Auth_V1beta1_AuthNonce) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_IdentityConnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityConnect"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_IdentityConnect, rhs: Bloombox_Services_Auth_V1beta1_IdentityConnect) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_IdentityConnect.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_IdentityConnect.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "apns"),
    3: .same(proto: "fcm"),
    4: .same(proto: "key"),
    5: .same(proto: "client"),
    6: .same(proto: "device"),
    7: .same(proto: "nonce"),
    8: .same(proto: "adid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularStringField(value: &self.apns)
      case 3: try decoder.decodeSingularStringField(value: &self.fcm)
      case 4: try decoder.decodeSingularStringField(value: &self.key)
      case 5: try decoder.decodeSingularStringField(value: &self.client)
      case 6: try decoder.decodeSingularStringField(value: &self.device)
      case 7: try decoder.decodeSingularStringField(value: &self.nonce)
      case 8: try decoder.decodeSingularStringField(value: &self.adid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.apns.isEmpty {
      try visitor.visitSingularStringField(value: self.apns, fieldNumber: 2)
    }
    if !self.fcm.isEmpty {
      try visitor.visitSingularStringField(value: self.fcm, fieldNumber: 3)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 4)
    }
    if !self.client.isEmpty {
      try visitor.visitSingularStringField(value: self.client, fieldNumber: 5)
    }
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 6)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 7)
    }
    if !self.adid.isEmpty {
      try visitor.visitSingularStringField(value: self.adid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_IdentityConnect.Request, rhs: Bloombox_Services_Auth_V1beta1_IdentityConnect.Request) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.apns != rhs.apns {return false}
    if lhs.fcm != rhs.fcm {return false}
    if lhs.key != rhs.key {return false}
    if lhs.client != rhs.client {return false}
    if lhs.device != rhs.device {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.adid != rhs.adid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_IdentityConnect.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_IdentityConnect.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "token"),
    3: .same(proto: "profile"),
    4: .same(proto: "setup"),
  ]

  fileprivate class _StorageClass {
    var _key: Bloombox_Identity_UserKey? = nil
    var _token: Bloombox_Security_AuthToken? = nil
    var _result: Bloombox_Services_Auth_V1beta1_IdentityConnect.Response.OneOf_Result?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _token = source._token
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._token)
        case 3:
          var v: Bloombox_Identity_User?
          if let current = _storage._result {
            try decoder.handleConflictingOneOf()
            if case .profile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._result = .profile(v)}
        case 4:
          if _storage._result != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._result = .setup(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._result {
      case .profile(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .setup(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_IdentityConnect.Response, rhs: Bloombox_Services_Auth_V1beta1_IdentityConnect.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ProfileUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ProfileUpdate, rhs: Bloombox_Services_Auth_V1beta1_ProfileUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Auth_V1beta1_ProfileUpdate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Auth_V1beta1_ProfileUpdate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    3: .same(proto: "profile"),
  ]

  fileprivate class _StorageClass {
    var _user: String = String()
    var _profile: Bloombox_Identity_User? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _profile = source._profile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._user)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._profile)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._user.isEmpty {
        try visitor.visitSingularStringField(value: _storage._user, fieldNumber: 1)
      }
      if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Auth_V1beta1_ProfileUpdate.Request, rhs: Bloombox_Services_Auth_V1beta1_ProfileUpdate.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._profile != rhs_storage._profile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
