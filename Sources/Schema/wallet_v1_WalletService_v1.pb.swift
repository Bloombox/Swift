// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wallet/v1/WalletService_v1.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Provides the Wallet API, which offers the ability to issue, manage, resolve and list digital pass cards from the
/// perspective of the subject customer/user. Membership cards, from the dispensary/retailer's perspective, are managed
/// via membership methods in the Dashboard API.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates known errors that may be thrown by wallet operations.
public enum Bloombox_Services_Wallet_V1_WalletError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// There was no error.
  case noError // = 0

  /// The specified partner key was invalid.
  case invalidPartner // = 1

  /// The specified location key was invalid.
  case invalidLocation // = 2

  /// The specified device key was invalid.
  case invalidDevice // = 3

  /// The specified ID or authorization token was invalid.
  case invalidToken // = 4

  /// The subject partner could not be found.
  case partnerNotFound // = 5

  /// The subject location could not be found.
  case locationNotFound // = 6

  /// Generic access-denied-error.
  case accessDenied // = 98

  /// An internal error was encountered.
  case internalError // = 99
  case UNRECOGNIZED(Int)

  public init() {
    self = .noError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 1: self = .invalidPartner
    case 2: self = .invalidLocation
    case 3: self = .invalidDevice
    case 4: self = .invalidToken
    case 5: self = .partnerNotFound
    case 6: self = .locationNotFound
    case 98: self = .accessDenied
    case 99: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noError: return 0
    case .invalidPartner: return 1
    case .invalidLocation: return 2
    case .invalidDevice: return 3
    case .invalidToken: return 4
    case .partnerNotFound: return 5
    case .locationNotFound: return 6
    case .accessDenied: return 98
    case .internalError: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Services_Wallet_V1_WalletError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Services_Wallet_V1_WalletError] = [
    .noError,
    .invalidPartner,
    .invalidLocation,
    .invalidDevice,
    .invalidToken,
    .partnerNotFound,
    .locationNotFound,
    .accessDenied,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

/// Specifies a request and response flow for an RPC operation to provision a new digital wallet card. Provisioning a
/// card occurs first in the card lifecycle, before the card is issued, and after the user has already satisfied any
/// constraints or requirements related to the partner or location context for which the card is being issued.
public struct Bloombox_Services_Wallet_V1_CardProvision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request, issued from the user's perspective, to issue a new digital card.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User that the card provision request is being issued for.
    public var user: Bloombox_Identity_UserKey {
      get {return _storage._user ?? Bloombox_Identity_UserKey()}
      set {_uniqueStorage()._user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {return _storage._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {_uniqueStorage()._user = nil}

    /// Specifies the context under which this card is being provisioned.
    public var context: OneOf_Context? {
      get {return _storage._context}
      set {_uniqueStorage()._context = newValue}
    }

    /// Partner record for which this card is being provisioned.
    public var partner: Bloombox_Partner_PartnerKey {
      get {
        if case .partner(let v)? = _storage._context {return v}
        return Bloombox_Partner_PartnerKey()
      }
      set {_uniqueStorage()._context = .partner(newValue)}
    }

    /// Location record for which this card is being provisioned.
    public var location: Bloombox_Partner_LocationKey {
      get {
        if case .location(let v)? = _storage._context {return v}
        return Bloombox_Partner_LocationKey()
      }
      set {_uniqueStorage()._context = .location(newValue)}
    }

    /// Special flag indicating a globally-usable identity card for the user.
    public var identity: Bool {
      get {
        if case .identity(let v)? = _storage._context {return v}
        return false
      }
      set {_uniqueStorage()._context = .identity(newValue)}
    }

    /// Public key for the user, so their signatures later on may be verified.
    public var publicKey: Opencannabis_Crypto_KeyMaterial {
      get {return _storage._publicKey ?? Opencannabis_Crypto_KeyMaterial()}
      set {_uniqueStorage()._publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    public var hasPublicKey: Bool {return _storage._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies the context under which this card is being provisioned.
    public enum OneOf_Context: Equatable {
      /// Partner record for which this card is being provisioned.
      case partner(Bloombox_Partner_PartnerKey)
      /// Location record for which this card is being provisioned.
      case location(Bloombox_Partner_LocationKey)
      /// Special flag indicating a globally-usable identity card for the user.
      case identity(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Services_Wallet_V1_CardProvision.Request.OneOf_Context, rhs: Bloombox_Services_Wallet_V1_CardProvision.Request.OneOf_Context) -> Bool {
        switch (lhs, rhs) {
        case (.partner(let l), .partner(let r)): return l == r
        case (.location(let l), .location(let r)): return l == r
        case (.identity(let l), .identity(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to provision a new digital card.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Wallet pass key provisioned for the requested ID card.
    public var card: Bloombox_Identity_Pass_PassKey {
      get {return _storage._card ?? Bloombox_Identity_Pass_PassKey()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    /// Issuance nonce, used in the card-issue step to claim this provisioned digital wallet card.
    public var nonce: String {
      get {return _storage._nonce}
      set {_uniqueStorage()._nonce = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies an operation to provision a new digital card.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to provision a new card.
    public var request: Bloombox_Services_Wallet_V1_CardProvision.Request {
      get {return _storage._request ?? Bloombox_Services_Wallet_V1_CardProvision.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to provision a new digital card.
    public var response: Bloombox_Services_Wallet_V1_CardProvision.Response {
      get {return _storage._response ?? Bloombox_Services_Wallet_V1_CardProvision.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Issue a digital card for a given user, from the user's perspective.
public struct Bloombox_Services_Wallet_V1_CardIssuance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request from a user to issue a digital wallet pass in a given commercial context.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User that cards are being requested for.
    public var user: Bloombox_Identity_UserKey {
      get {return _storage._user ?? Bloombox_Identity_UserKey()}
      set {_uniqueStorage()._user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {return _storage._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {_uniqueStorage()._user = nil}

    /// Wallet pass key provisioned for the requested ID card.
    public var card: Bloombox_Identity_Pass_PassKey {
      get {return _storage._card ?? Bloombox_Identity_Pass_PassKey()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    /// Nonce, provisioned via the card provisioning process, and provided to the device requesting issuance of the
    /// digital card.
    public var nonce: String {
      get {return _storage._nonce}
      set {_uniqueStorage()._nonce = newValue}
    }

    /// Signature from the user's private key, performed over the user key and context value.
    public var signature: Opencannabis_Crypto_Signature {
      get {return _storage._signature ?? Opencannabis_Crypto_Signature()}
      set {_uniqueStorage()._signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return _storage._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {_uniqueStorage()._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to issue a pass. Includes the issued-pass record, which should have a URI attached where the
  /// raw pass content can be downloaded.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Record for the digital pass in question, after it has been shifted to an issued-state.
    public var card: Bloombox_Identity_Pass_Pass {
      get {return _storage._card ?? Bloombox_Identity_Pass_Pass()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Represents an entire operation to request the issuance of a digital wallet pass card.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to issue a digital pass card.
    public var request: Bloombox_Services_Wallet_V1_CardIssuance.Request {
      get {return _storage._request ?? Bloombox_Services_Wallet_V1_CardIssuance.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to issue a digital pass card.
    public var response: Bloombox_Services_Wallet_V1_CardIssuance.Response {
      get {return _storage._response ?? Bloombox_Services_Wallet_V1_CardIssuance.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies an RPC operation to register a digital wallet pass for remote updates.
public struct Bloombox_Services_Wallet_V1_CardActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request for remote updates for a pass.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Device library ID.
    public var library: String = String()

    /// Pass type ID.
    public var passType: String = String()

    /// Serial number for the pass in question.
    public var serial: String = String()

    /// Push token provided by the pass registration.
    public var pushToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an RPC operation to retrieve the latest version of a given wallet pass.
public struct Bloombox_Services_Wallet_V1_CardRetrieve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to retrieve a wallet pass.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Pass type ID.
    public var passType: String = String()

    /// Serial number.
    public var serial: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response containing the resulting pass, if it could be found.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Raw bytes of the wallet pass.
    public var payload: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an endpoint to enroll in rewards programs via personalizable passes.
public struct Bloombox_Services_Wallet_V1_CardEnroll {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Card enrollment payload.
  public struct CardSpec {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user's full name, as entered by the user.
    public var fullName: String = String()

    /// The user's given name, parsed from the full name.
    public var givenName: String = String()

    /// The user's family name, parsed from the full name.
    public var familyName: String = String()

    /// The email address, as entered by the user.
    public var emailAddress: String = String()

    /// The postal code, as entered by the user.
    public var postalCode: String = String()

    /// The user's ISO country code. This key is only included when the client-side system can deduce the country code.
    public var isoCountryCode: String = String()

    /// The user's phone number, as entered by the user.
    public var phoneNumber: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Request to enroll via a personalizable pass.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Pass Type ID, identifying the type of wallet pass that is enrolling.
    public var passType: String {
      get {return _storage._passType}
      set {_uniqueStorage()._passType = newValue}
    }

    /// Serial number for the pass that is enrolling.
    public var serial: String {
      get {return _storage._serial}
      set {_uniqueStorage()._serial = newValue}
    }

    /// Personalization token for this request. Signed and returned by the server.
    public var personalizationToken: String {
      get {return _storage._personalizationToken}
      set {_uniqueStorage()._personalizationToken = newValue}
    }

    /// Dictionary containing required personal information for enrollment.
    public var requiredPersonalizationInfo: Bloombox_Services_Wallet_V1_CardEnroll.CardSpec {
      get {return _storage._requiredPersonalizationInfo ?? Bloombox_Services_Wallet_V1_CardEnroll.CardSpec()}
      set {_uniqueStorage()._requiredPersonalizationInfo = newValue}
    }
    /// Returns true if `requiredPersonalizationInfo` has been explicitly set.
    public var hasRequiredPersonalizationInfo: Bool {return _storage._requiredPersonalizationInfo != nil}
    /// Clears the value of `requiredPersonalizationInfo`. Subsequent reads from it will return its default value.
    public mutating func clearRequiredPersonalizationInfo() {_uniqueStorage()._requiredPersonalizationInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to enroll via a personalizable pass.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Raw signature returned from the server.
    public var signature: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request to list cards for a given user, from their own perspective, optionally filtering by partner/location key.
public struct Bloombox_Services_Wallet_V1_CardList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to list cards for a given user.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Device library ID.
    public var library: String = String()

    /// Pass type ID.
    public var passType: String = String()

    /// Tag for constraining update bounds.
    public var passesUpdatedSince: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response to a request to list cards for a given user.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Last-updated-tag for this response. Determined by the server.
    public var lastUpdated: String = String()

    /// Serial numbers owned by the specified device library.
    public var serialNumbers: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Operation to list cards for a given user.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to list cards for a given user.
    public var request: Bloombox_Services_Wallet_V1_CardList.Request {
      get {return _storage._request ?? Bloombox_Services_Wallet_V1_CardList.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to list cards for a given user.
    public var response: Bloombox_Services_Wallet_V1_CardList.Response {
      get {return _storage._response ?? Bloombox_Services_Wallet_V1_CardList.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies a request, on behalf of a user, to decommission a given card they own.
public struct Bloombox_Services_Wallet_V1_CardVoid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to void a digital card, on a user's behalf.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Device library ID.
    public var library: String = String()

    /// Pass type ID.
    public var passType: String = String()

    /// Serial number for the digital pass.
    public var serial: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Represents an entire operation to decommission a card on a user's behalf.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to void a given digital card.
    public var request: Bloombox_Services_Wallet_V1_CardVoid.Request {
      get {return _storage._request ?? Bloombox_Services_Wallet_V1_CardVoid.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Whether the deletion was successful or not.
    public var success: Bool {
      get {return _storage._success}
      set {_uniqueStorage()._success = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.services.wallet.v1"

extension Bloombox_Services_Wallet_V1_WalletError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    1: .same(proto: "INVALID_PARTNER"),
    2: .same(proto: "INVALID_LOCATION"),
    3: .same(proto: "INVALID_DEVICE"),
    4: .same(proto: "INVALID_TOKEN"),
    5: .same(proto: "PARTNER_NOT_FOUND"),
    6: .same(proto: "LOCATION_NOT_FOUND"),
    98: .same(proto: "ACCESS_DENIED"),
    99: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Bloombox_Services_Wallet_V1_CardProvision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardProvision"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardProvision, rhs: Bloombox_Services_Wallet_V1_CardProvision) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardProvision.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardProvision.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
    4: .same(proto: "identity"),
    5: .standard(proto: "public_key"),
  ]

  fileprivate class _StorageClass {
    var _user: Bloombox_Identity_UserKey? = nil
    var _context: Bloombox_Services_Wallet_V1_CardProvision.Request.OneOf_Context?
    var _publicKey: Opencannabis_Crypto_KeyMaterial? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _context = source._context
      _publicKey = source._publicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2:
          var v: Bloombox_Partner_PartnerKey?
          if let current = _storage._context {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._context = .partner(v)}
        case 3:
          var v: Bloombox_Partner_LocationKey?
          if let current = _storage._context {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._context = .location(v)}
        case 4:
          if _storage._context != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._context = .identity(v)}
        case 5: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._context {
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .identity(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case nil: break
      }
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardProvision.Request, rhs: Bloombox_Services_Wallet_V1_CardProvision.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardProvision.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardProvision.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
    2: .same(proto: "nonce"),
  ]

  fileprivate class _StorageClass {
    var _card: Bloombox_Identity_Pass_PassKey? = nil
    var _nonce: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _card = source._card
      _nonce = source._nonce
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._card)
        case 2: try decoder.decodeSingularStringField(value: &_storage._nonce)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardProvision.Response, rhs: Bloombox_Services_Wallet_V1_CardProvision.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._card != rhs_storage._card {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardProvision.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardProvision.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Services_Wallet_V1_CardProvision.Request? = nil
    var _response: Bloombox_Services_Wallet_V1_CardProvision.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardProvision.Operation, rhs: Bloombox_Services_Wallet_V1_CardProvision.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardIssuance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardIssuance"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardIssuance, rhs: Bloombox_Services_Wallet_V1_CardIssuance) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardIssuance.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardIssuance.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "card"),
    3: .same(proto: "nonce"),
    4: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _user: Bloombox_Identity_UserKey? = nil
    var _card: Bloombox_Identity_Pass_PassKey? = nil
    var _nonce: String = String()
    var _signature: Opencannabis_Crypto_Signature? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _card = source._card
      _nonce = source._nonce
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._card)
        case 3: try decoder.decodeSingularStringField(value: &_storage._nonce)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 3)
      }
      if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardIssuance.Request, rhs: Bloombox_Services_Wallet_V1_CardIssuance.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._card != rhs_storage._card {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardIssuance.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardIssuance.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
  ]

  fileprivate class _StorageClass {
    var _card: Bloombox_Identity_Pass_Pass? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _card = source._card
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._card)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardIssuance.Response, rhs: Bloombox_Services_Wallet_V1_CardIssuance.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._card != rhs_storage._card {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardIssuance.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardIssuance.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Services_Wallet_V1_CardIssuance.Request? = nil
    var _response: Bloombox_Services_Wallet_V1_CardIssuance.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardIssuance.Operation, rhs: Bloombox_Services_Wallet_V1_CardIssuance.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardActivate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardActivate, rhs: Bloombox_Services_Wallet_V1_CardActivate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardActivate.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardActivate.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "library"),
    2: .standard(proto: "pass_type"),
    3: .same(proto: "serial"),
    4: .same(proto: "pushToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.library)
      case 2: try decoder.decodeSingularStringField(value: &self.passType)
      case 3: try decoder.decodeSingularStringField(value: &self.serial)
      case 4: try decoder.decodeSingularStringField(value: &self.pushToken)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.library.isEmpty {
      try visitor.visitSingularStringField(value: self.library, fieldNumber: 1)
    }
    if !self.passType.isEmpty {
      try visitor.visitSingularStringField(value: self.passType, fieldNumber: 2)
    }
    if !self.serial.isEmpty {
      try visitor.visitSingularStringField(value: self.serial, fieldNumber: 3)
    }
    if !self.pushToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pushToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardActivate.Request, rhs: Bloombox_Services_Wallet_V1_CardActivate.Request) -> Bool {
    if lhs.library != rhs.library {return false}
    if lhs.passType != rhs.passType {return false}
    if lhs.serial != rhs.serial {return false}
    if lhs.pushToken != rhs.pushToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardRetrieve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardRetrieve"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardRetrieve, rhs: Bloombox_Services_Wallet_V1_CardRetrieve) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardRetrieve.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardRetrieve.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "pass_type"),
    3: .same(proto: "serial"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.passType)
      case 3: try decoder.decodeSingularStringField(value: &self.serial)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.passType.isEmpty {
      try visitor.visitSingularStringField(value: self.passType, fieldNumber: 2)
    }
    if !self.serial.isEmpty {
      try visitor.visitSingularStringField(value: self.serial, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardRetrieve.Request, rhs: Bloombox_Services_Wallet_V1_CardRetrieve.Request) -> Bool {
    if lhs.passType != rhs.passType {return false}
    if lhs.serial != rhs.serial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardRetrieve.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardRetrieve.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardRetrieve.Response, rhs: Bloombox_Services_Wallet_V1_CardRetrieve.Response) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardEnroll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardEnroll"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardEnroll, rhs: Bloombox_Services_Wallet_V1_CardEnroll) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardEnroll.CardSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardEnroll.protoMessageName + ".CardSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_name"),
    2: .standard(proto: "given_name"),
    3: .standard(proto: "family_name"),
    4: .standard(proto: "email_address"),
    5: .standard(proto: "postal_code"),
    6: .standard(proto: "ISO_country_code"),
    7: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.fullName)
      case 2: try decoder.decodeSingularStringField(value: &self.givenName)
      case 3: try decoder.decodeSingularStringField(value: &self.familyName)
      case 4: try decoder.decodeSingularStringField(value: &self.emailAddress)
      case 5: try decoder.decodeSingularStringField(value: &self.postalCode)
      case 6: try decoder.decodeSingularStringField(value: &self.isoCountryCode)
      case 7: try decoder.decodeSingularStringField(value: &self.phoneNumber)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullName, fieldNumber: 1)
    }
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 2)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 3)
    }
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 4)
    }
    if !self.postalCode.isEmpty {
      try visitor.visitSingularStringField(value: self.postalCode, fieldNumber: 5)
    }
    if !self.isoCountryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.isoCountryCode, fieldNumber: 6)
    }
    if !self.phoneNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.phoneNumber, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardEnroll.CardSpec, rhs: Bloombox_Services_Wallet_V1_CardEnroll.CardSpec) -> Bool {
    if lhs.fullName != rhs.fullName {return false}
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.postalCode != rhs.postalCode {return false}
    if lhs.isoCountryCode != rhs.isoCountryCode {return false}
    if lhs.phoneNumber != rhs.phoneNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardEnroll.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardEnroll.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pass_type"),
    2: .same(proto: "serial"),
    3: .standard(proto: "personalization_token"),
    4: .standard(proto: "required_personalization_info"),
  ]

  fileprivate class _StorageClass {
    var _passType: String = String()
    var _serial: String = String()
    var _personalizationToken: String = String()
    var _requiredPersonalizationInfo: Bloombox_Services_Wallet_V1_CardEnroll.CardSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _passType = source._passType
      _serial = source._serial
      _personalizationToken = source._personalizationToken
      _requiredPersonalizationInfo = source._requiredPersonalizationInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._passType)
        case 2: try decoder.decodeSingularStringField(value: &_storage._serial)
        case 3: try decoder.decodeSingularStringField(value: &_storage._personalizationToken)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._requiredPersonalizationInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._passType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._passType, fieldNumber: 1)
      }
      if !_storage._serial.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serial, fieldNumber: 2)
      }
      if !_storage._personalizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._personalizationToken, fieldNumber: 3)
      }
      if let v = _storage._requiredPersonalizationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardEnroll.Request, rhs: Bloombox_Services_Wallet_V1_CardEnroll.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._passType != rhs_storage._passType {return false}
        if _storage._serial != rhs_storage._serial {return false}
        if _storage._personalizationToken != rhs_storage._personalizationToken {return false}
        if _storage._requiredPersonalizationInfo != rhs_storage._requiredPersonalizationInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardEnroll.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardEnroll.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardEnroll.Response, rhs: Bloombox_Services_Wallet_V1_CardEnroll.Response) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardList, rhs: Bloombox_Services_Wallet_V1_CardList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardList.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardList.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "library"),
    2: .standard(proto: "pass_type"),
    3: .standard(proto: "passes_updated_since"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.library)
      case 2: try decoder.decodeSingularStringField(value: &self.passType)
      case 3: try decoder.decodeSingularStringField(value: &self.passesUpdatedSince)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.library.isEmpty {
      try visitor.visitSingularStringField(value: self.library, fieldNumber: 1)
    }
    if !self.passType.isEmpty {
      try visitor.visitSingularStringField(value: self.passType, fieldNumber: 2)
    }
    if !self.passesUpdatedSince.isEmpty {
      try visitor.visitSingularStringField(value: self.passesUpdatedSince, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardList.Request, rhs: Bloombox_Services_Wallet_V1_CardList.Request) -> Bool {
    if lhs.library != rhs.library {return false}
    if lhs.passType != rhs.passType {return false}
    if lhs.passesUpdatedSince != rhs.passesUpdatedSince {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardList.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardList.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_updated"),
    2: .standard(proto: "serial_numbers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastUpdated)
      case 2: try decoder.decodeRepeatedStringField(value: &self.serialNumbers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastUpdated.isEmpty {
      try visitor.visitSingularStringField(value: self.lastUpdated, fieldNumber: 1)
    }
    if !self.serialNumbers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serialNumbers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardList.Response, rhs: Bloombox_Services_Wallet_V1_CardList.Response) -> Bool {
    if lhs.lastUpdated != rhs.lastUpdated {return false}
    if lhs.serialNumbers != rhs.serialNumbers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardList.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardList.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Services_Wallet_V1_CardList.Request? = nil
    var _response: Bloombox_Services_Wallet_V1_CardList.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardList.Operation, rhs: Bloombox_Services_Wallet_V1_CardList.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardVoid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardVoid"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardVoid, rhs: Bloombox_Services_Wallet_V1_CardVoid) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardVoid.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardVoid.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "library"),
    2: .standard(proto: "pass_type"),
    3: .same(proto: "serial"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.library)
      case 2: try decoder.decodeSingularStringField(value: &self.passType)
      case 3: try decoder.decodeSingularStringField(value: &self.serial)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.library.isEmpty {
      try visitor.visitSingularStringField(value: self.library, fieldNumber: 1)
    }
    if !self.passType.isEmpty {
      try visitor.visitSingularStringField(value: self.passType, fieldNumber: 2)
    }
    if !self.serial.isEmpty {
      try visitor.visitSingularStringField(value: self.serial, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardVoid.Request, rhs: Bloombox_Services_Wallet_V1_CardVoid.Request) -> Bool {
    if lhs.library != rhs.library {return false}
    if lhs.passType != rhs.passType {return false}
    if lhs.serial != rhs.serial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Services_Wallet_V1_CardVoid.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Services_Wallet_V1_CardVoid.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Services_Wallet_V1_CardVoid.Request? = nil
    var _success: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _success = source._success
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._success)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Services_Wallet_V1_CardVoid.Operation, rhs: Bloombox_Services_Wallet_V1_CardVoid.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._success != rhs_storage._success {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
