// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: licensing/Licensure.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies the structure and available enumerated types of cannabis-related licensing. Licenses of different types may
/// be granted by different jurisdictional authorities to an organization or individual.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the supertypes of licenses that are supported by the system. By default, all licenses are considered
/// "permanent," meaning they do not have expiration parameters built in besides regular compliance.
public enum Bloombox_Licensure_LicenseType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Permanent licenses are the default supertype for a license, and indicate that a license does not, by default,
  /// expire based on time. Compliance with all other licensure stipulations is of course required. A license that is
  /// considered "permanent" may still be revoked for any reason, including time-based expiry, but such a mechanism is
  /// not implied to necessitate a separately license.
  case permanent // = 0

  /// Temporary licenses are, by nature, issued on a preliminary or temporary basis. They are frequently issued
  /// separately from permanent licenses and so are treated differently by OCS.
  case temporary // = 1

  /// Compound licenses allow multiple privileges in one license structure. In some jurisdictions, compound licenses are
  /// referred to as "microbusinesses." Many compound licensees perform numerous functions in the supply chain, and carry
  /// privileges for each role with their one compound license.
  case compound // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .permanent
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .permanent
    case 1: self = .temporary
    case 2: self = .compound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .permanent: return 0
    case .temporary: return 1
    case .compound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Licensure_LicenseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Licensure_LicenseType] = [
    .permanent,
    .temporary,
    .compound,
  ]
}

#endif  // swift(>=4.2)

/// Enumerates different types of cannabis licenses that relate to the larger data model. Licensing is based on the role
/// of a given organization or individual in the supply chain.
public enum Bloombox_Licensure_LicensePrivilege: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Specifies that the license type of a given license payload is unknown. This value is not meant for explicit use and
  /// instead provides a backstop for parsing errors with license types.
  case unknownLicense // = 0

  /// Specifies a cultivation license, which is defined as, a license to grow cannabis plants in some amount, to some age
  /// and the right to harvest those plants and sell them or pass them to a licensed distributor.
  case cultivation // = 1

  /// Specifies a distribution license, which allows an organization to broker deals between producers and buyers, and is
  /// usually also licensed for transport. Distributors can vend to other distributors, retailers, or manufacturers, and
  /// are additionally responsible for testing.
  case distribution // = 2

  /// Specifies a license type that allows an organization to physically transport cannabis materials. This can include
  /// trucks/automobiles, trains, boats, etc, but only allows delivery to wholesale or retail actors. Transport in the
  /// last mile of the supply chain (from retail to consumer) is considered a 'delivery' license.
  case transport // = 3

  /// Specifies a license to perform lab testing on cannabis products, and produce certified reports about the content
  /// and composition of cannabis products.
  case laboratory // = 4

  /// Specifies a license to purchase legal cannabis precursor products, and synthesize them into secondary products, for
  /// instance, edibles, concentrates, cartridges, and so on.
  case manufacturing // = 5

  /// Specifies a license to vend or dispense cannabis products directly to consumers. Regular retail licensing covers
  /// brick and mortar locations, not delivery - at least where OCS is concerned, that is considered a different license
  /// type of 'delivery'. Retailers may only purchase from licensed distributors.
  case retail // = 6

  /// Specifies a non-storefront retail license, which is to say, a license to deliver cannabis products directly to
  /// consumers. Often, delivery licenses are bundled with existing retail licenses. Like retail licensees, delivery
  /// licensees may only purchase from licensed distributors.
  case delivery // = 7

  /// Specifies a license to hold cannabis events. Covers only the sale of cannabis products, not necessarily the onsite
  /// consumption of cannabis products (must be bundled with a 'consumption') privilege.
  case events // = 8

  /// Specifies a license that allows consumption of cannabis at a given business premises or event. This license type
  /// covers cannabis lounges, cannabis bars, and cannabis festivals/events.
  case consumption // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownLicense
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownLicense
    case 1: self = .cultivation
    case 2: self = .distribution
    case 3: self = .transport
    case 4: self = .laboratory
    case 5: self = .manufacturing
    case 6: self = .retail
    case 7: self = .delivery
    case 8: self = .events
    case 9: self = .consumption
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownLicense: return 0
    case .cultivation: return 1
    case .distribution: return 2
    case .transport: return 3
    case .laboratory: return 4
    case .manufacturing: return 5
    case .retail: return 6
    case .delivery: return 7
    case .events: return 8
    case .consumption: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Licensure_LicensePrivilege: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Licensure_LicensePrivilege] = [
    .unknownLicense,
    .cultivation,
    .distribution,
    .transport,
    .laboratory,
    .manufacturing,
    .retail,
    .delivery,
    .events,
    .consumption,
  ]
}

#endif  // swift(>=4.2)

/// Specifies states that a given license may exist in. Expiration, revocation, and other actions that may deny access,
/// are enumerated here with descriptions.
public enum Bloombox_Licensure_LicenseStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Specifies a license status that is unknown, or pending review or action to verify.
  case pending // = 0

  /// Specifies an active license that grants specified privileges, stipulating the privileges being active and valid for
  /// the time the subject license is in this status.
  case active // = 1

  /// Specifies a license state where, for reasons other than regular expiry, the subject license is to be considered
  /// no-longer-valid, with no ability to leverage or assert the privileges granted in the license. If the license is
  /// superseded by a new license (or a permanent license issued for a previously-temporary licensee), the status
  /// 'superseded' is used in place of this (implying that 'revoked') is only used for punitive license states. This
  /// license state is considered terminal.
  case revoked // = 2

  /// Specifies a license state where, due to time constraints placed on the license, it is no longer considered valid.
  /// Expired licenses do not imply any punitive action directed at the licensee. Expiration is a terminal status.
  case expired // = 3

  /// Specifies a license that is temporarily not-to-be-considered-valid. In cases where remediation activities must be
  /// enforced by a regulatory agency, a license may be placed in this state for some period of time. Suspension is not
  /// considered a terminal state for the subject license or licensee and does not necessarily imply punitive action.
  case suspended // = 4

  /// Specifies that a license is no longer considered valid, but that the license has been superseded by another, valid
  /// license, that may grant a different set of privileges (but never a subset, lest this subject license be considered
  /// 'revoked' rather than 'superseded').
  case superseded // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .pending
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .active
    case 2: self = .revoked
    case 3: self = .expired
    case 4: self = .suspended
    case 5: self = .superseded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pending: return 0
    case .active: return 1
    case .revoked: return 2
    case .expired: return 3
    case .suspended: return 4
    case .superseded: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Licensure_LicenseStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Licensure_LicenseStatus] = [
    .pending,
    .active,
    .revoked,
    .expired,
    .suspended,
    .superseded,
  ]
}

#endif  // swift(>=4.2)

/// Specifies the jurisdictional authority that issued or is in the process of issuing a license. Jurisdiction is a
/// hierarchical concept, and so, this structure is filled out according to the "leaf" jurisdiction that actually issued
/// the subject license.
public struct Bloombox_Licensure_LicensingAuthority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the jurisdictional authority that applies to a subject license.
  public var jurisdiction: OneOf_Jurisdiction? {
    get {return _storage._jurisdiction}
    set {_uniqueStorage()._jurisdiction = newValue}
  }

  /// Specifies a license issued by a "local" (or municipal) jurisdiction, which is to say, a township or city.
  public var local: Bloombox_Licensure_LicensingAuthority.LocalLicense {
    get {
      if case .local(let v)? = _storage._jurisdiction {return v}
      return Bloombox_Licensure_LicensingAuthority.LocalLicense()
    }
    set {_uniqueStorage()._jurisdiction = .local(newValue)}
  }

  /// Specifies a license issued by a semi-local (provincial) jurisdiction, which is to say, a county.
  public var county: Bloombox_Licensure_LicensingAuthority.CountyLicense {
    get {
      if case .county(let v)? = _storage._jurisdiction {return v}
      return Bloombox_Licensure_LicensingAuthority.CountyLicense()
    }
    set {_uniqueStorage()._jurisdiction = .county(newValue)}
  }

  /// Specifies a license issued by a regional jurisdiction, which is to say, a state.
  public var state: Bloombox_Licensure_LicensingAuthority.StateLicense {
    get {
      if case .state(let v)? = _storage._jurisdiction {return v}
      return Bloombox_Licensure_LicensingAuthority.StateLicense()
    }
    set {_uniqueStorage()._jurisdiction = .state(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the jurisdictional authority that applies to a subject license.
  public enum OneOf_Jurisdiction: Equatable {
    /// Specifies a license issued by a "local" (or municipal) jurisdiction, which is to say, a township or city.
    case local(Bloombox_Licensure_LicensingAuthority.LocalLicense)
    /// Specifies a license issued by a semi-local (provincial) jurisdiction, which is to say, a county.
    case county(Bloombox_Licensure_LicensingAuthority.CountyLicense)
    /// Specifies a license issued by a regional jurisdiction, which is to say, a state.
    case state(Bloombox_Licensure_LicensingAuthority.StateLicense)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.OneOf_Jurisdiction, rhs: Bloombox_Licensure_LicensingAuthority.OneOf_Jurisdiction) -> Bool {
      switch (lhs, rhs) {
      case (.local(let l), .local(let r)): return l == r
      case (.county(let l), .county(let r)): return l == r
      case (.state(let l), .state(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Specifies the concept of a local licensing authority, meaning a municipality with the statutory authority to
  /// authorize industrial cannabis privileges.
  public struct LocalLicense {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the municipality for this license.
    public var municipality: String = String()

    /// Specifies, either via arbitrary name or structured reference, the county containing the municipality.
    public var county: Bloombox_Licensure_LicensingAuthority.LocalLicense.OneOf_County? = nil

    /// Arbitrary name of a given county.
    public var countyName: String {
      get {
        if case .countyName(let v)? = county {return v}
        return String()
      }
      set {county = .countyName(newValue)}
    }

    /// Specifies a California county.
    public var californiaCounty: Opencannabis_Geo_Usa_Ca_CaliforniaCounty {
      get {
        if case .californiaCounty(let v)? = county {return v}
        return .unknownCounty
      }
      set {county = .californiaCounty(newValue)}
    }

    /// Specifies, either via arbitrary name or structured reference, the state containing the municipality.
    public var province: Bloombox_Licensure_LicensingAuthority.LocalLicense.OneOf_Province? = nil

    /// Arbitrary name for a given state or province.
    public var provinceName: String {
      get {
        if case .provinceName(let v)? = province {return v}
        return String()
      }
      set {province = .provinceName(newValue)}
    }

    /// Specifies a U.S. state.
    public var usState: Opencannabis_Geo_Usa_USState {
      get {
        if case .usState(let v)? = province {return v}
        return .unspecified
      }
      set {province = .usState(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies, either via arbitrary name or structured reference, the county containing the municipality.
    public enum OneOf_County: Equatable {
      /// Arbitrary name of a given county.
      case countyName(String)
      /// Specifies a California county.
      case californiaCounty(Opencannabis_Geo_Usa_Ca_CaliforniaCounty)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.LocalLicense.OneOf_County, rhs: Bloombox_Licensure_LicensingAuthority.LocalLicense.OneOf_County) -> Bool {
        switch (lhs, rhs) {
        case (.countyName(let l), .countyName(let r)): return l == r
        case (.californiaCounty(let l), .californiaCounty(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// Specifies, either via arbitrary name or structured reference, the state containing the municipality.
    public enum OneOf_Province: Equatable {
      /// Arbitrary name for a given state or province.
      case provinceName(String)
      /// Specifies a U.S. state.
      case usState(Opencannabis_Geo_Usa_USState)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.LocalLicense.OneOf_Province, rhs: Bloombox_Licensure_LicensingAuthority.LocalLicense.OneOf_Province) -> Bool {
        switch (lhs, rhs) {
        case (.provinceName(let l), .provinceName(let r)): return l == r
        case (.usState(let l), .usState(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Specifies the concept of a county-level licensing authority, meaning a provincial jurisdiction with the statutory
  /// authority to authorize industrial cannabis privileges.
  public struct CountyLicense {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies, either via arbitrary name or structured reference, the county in question.
    public var county: Bloombox_Licensure_LicensingAuthority.CountyLicense.OneOf_County? = nil

    /// Arbitrary name of a given county.
    public var name: String {
      get {
        if case .name(let v)? = county {return v}
        return String()
      }
      set {county = .name(newValue)}
    }

    /// Specifies a California county.
    public var californiaCounty: Opencannabis_Geo_Usa_Ca_CaliforniaCounty {
      get {
        if case .californiaCounty(let v)? = county {return v}
        return .unknownCounty
      }
      set {county = .californiaCounty(newValue)}
    }

    /// Specifies, either via arbitrary name or structured reference, the state containing the county.
    public var province: Bloombox_Licensure_LicensingAuthority.CountyLicense.OneOf_Province? = nil

    /// Arbitrary name for a given state or province.
    public var provinceName: String {
      get {
        if case .provinceName(let v)? = province {return v}
        return String()
      }
      set {province = .provinceName(newValue)}
    }

    /// Specifies a U.S. state.
    public var usState: Opencannabis_Geo_Usa_USState {
      get {
        if case .usState(let v)? = province {return v}
        return .unspecified
      }
      set {province = .usState(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies, either via arbitrary name or structured reference, the county in question.
    public enum OneOf_County: Equatable {
      /// Arbitrary name of a given county.
      case name(String)
      /// Specifies a California county.
      case californiaCounty(Opencannabis_Geo_Usa_Ca_CaliforniaCounty)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.CountyLicense.OneOf_County, rhs: Bloombox_Licensure_LicensingAuthority.CountyLicense.OneOf_County) -> Bool {
        switch (lhs, rhs) {
        case (.name(let l), .name(let r)): return l == r
        case (.californiaCounty(let l), .californiaCounty(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// Specifies, either via arbitrary name or structured reference, the state containing the county.
    public enum OneOf_Province: Equatable {
      /// Arbitrary name for a given state or province.
      case provinceName(String)
      /// Specifies a U.S. state.
      case usState(Opencannabis_Geo_Usa_USState)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.CountyLicense.OneOf_Province, rhs: Bloombox_Licensure_LicensingAuthority.CountyLicense.OneOf_Province) -> Bool {
        switch (lhs, rhs) {
        case (.provinceName(let l), .provinceName(let r)): return l == r
        case (.usState(let l), .usState(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Specifies the concept of a state-level licensing authority, meaning a state or regional jurisdiction with the
  /// statutory authority to authorize industrial cannabis privileges.
  public struct StateLicense {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies, either via arbitrary name or structured reference, the state in question.
    public var province: Bloombox_Licensure_LicensingAuthority.StateLicense.OneOf_Province? = nil

    /// Arbitrary name for a given state or province.
    public var provinceName: String {
      get {
        if case .provinceName(let v)? = province {return v}
        return String()
      }
      set {province = .provinceName(newValue)}
    }

    /// Specifies a U.S. state.
    public var usState: Opencannabis_Geo_Usa_USState {
      get {
        if case .usState(let v)? = province {return v}
        return .unspecified
      }
      set {province = .usState(newValue)}
    }

    /// Specific governing or issuing regulatory body for a given state or provincial license.
    public var agency: Bloombox_Licensure_LicensingAuthority.StateLicense.OneOf_Agency? = nil

    /// Arbitrary name for a given regulatory/licensing agency.
    public var agencyName: String {
      get {
        if case .agencyName(let v)? = agency {return v}
        return String()
      }
      set {agency = .agencyName(newValue)}
    }

    /// Specifies a specific executive agency in the US State of California.
    public var californiaAgency: Opencannabis_Regulatory_Usa_Ca_CaliforniaAgency {
      get {
        if case .californiaAgency(let v)? = agency {return v}
        return .unknownAgency
      }
      set {agency = .californiaAgency(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies, either via arbitrary name or structured reference, the state in question.
    public enum OneOf_Province: Equatable {
      /// Arbitrary name for a given state or province.
      case provinceName(String)
      /// Specifies a U.S. state.
      case usState(Opencannabis_Geo_Usa_USState)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.StateLicense.OneOf_Province, rhs: Bloombox_Licensure_LicensingAuthority.StateLicense.OneOf_Province) -> Bool {
        switch (lhs, rhs) {
        case (.provinceName(let l), .provinceName(let r)): return l == r
        case (.usState(let l), .usState(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// Specific governing or issuing regulatory body for a given state or provincial license.
    public enum OneOf_Agency: Equatable {
      /// Arbitrary name for a given regulatory/licensing agency.
      case agencyName(String)
      /// Specifies a specific executive agency in the US State of California.
      case californiaAgency(Opencannabis_Regulatory_Usa_Ca_CaliforniaAgency)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.StateLicense.OneOf_Agency, rhs: Bloombox_Licensure_LicensingAuthority.StateLicense.OneOf_Agency) -> Bool {
        switch (lhs, rhs) {
        case (.agencyName(let l), .agencyName(let r)): return l == r
        case (.californiaAgency(let l), .californiaAgency(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a unique key that identifies a regulatory license document. It is generally compose of an auto-generated
/// UUID value, and a reference to any jurisdictionally-issued document or license codes.
public struct Bloombox_Licensure_LicenseKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Generated UUID for this particular license. Because a license ID may not yet have been issued by the licensing
  /// agency or jurisdiction, this ID serves as the primary key.
  public var id: String = String()

  /// Jurisdictionally-issued ID code. If the license carries an ID code issued by the state or jurisdiction, it is
  /// recorded here as part of the license's primary key.
  public var jid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies an individual event in the lifecycle of a given industrial cannabis license. History for a given license
/// can be reconstructed from a set of license events.
public struct Bloombox_Licensure_LicenseEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status for the license after this event takes place.
  public var status: Bloombox_Licensure_LicenseStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Privileges attached to this license after this event takes place. If this property is left empty, privileges are
  /// considered unchanged from the previous license event.
  public var privilege: [Bloombox_Licensure_LicensePrivilege] {
    get {return _storage._privilege}
    set {_uniqueStorage()._privilege = newValue}
  }

  /// Specifies an arbitrary message associated with this license event. Optional.
  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// Timestamp for when this license event was committed.
  public var occurred: Opencannabis_Temporal_Instant {
    get {return _storage._occurred ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._occurred = newValue}
  }
  /// Returns true if `occurred` has been explicitly set.
  public var hasOccurred: Bool {return _storage._occurred != nil}
  /// Clears the value of `occurred`. Subsequent reads from it will return its default value.
  public mutating func clearOccurred() {_uniqueStorage()._occurred = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies standard timestamps for a given regulatory license, that are generally considered immutable or at least
/// only updated by changes in the license content or privileges.
public struct Bloombox_Licensure_LicenseTimestamps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Date the license application was submitted to the jurisdictional or licensing agency.
  public var submitted: Opencannabis_Temporal_Date {
    get {return _storage._submitted ?? Opencannabis_Temporal_Date()}
    set {_uniqueStorage()._submitted = newValue}
  }
  /// Returns true if `submitted` has been explicitly set.
  public var hasSubmitted: Bool {return _storage._submitted != nil}
  /// Clears the value of `submitted`. Subsequent reads from it will return its default value.
  public mutating func clearSubmitted() {_uniqueStorage()._submitted = nil}

  /// Date the license was issued.
  public var issued: Opencannabis_Temporal_Date {
    get {return _storage._issued ?? Opencannabis_Temporal_Date()}
    set {_uniqueStorage()._issued = newValue}
  }
  /// Returns true if `issued` has been explicitly set.
  public var hasIssued: Bool {return _storage._issued != nil}
  /// Clears the value of `issued`. Subsequent reads from it will return its default value.
  public mutating func clearIssued() {_uniqueStorage()._issued = nil}

  /// Date the license was processed as an incoming payload by ledger systems.
  public var received: Opencannabis_Temporal_Date {
    get {return _storage._received ?? Opencannabis_Temporal_Date()}
    set {_uniqueStorage()._received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  public var hasReceived: Bool {return _storage._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  public mutating func clearReceived() {_uniqueStorage()._received = nil}

  /// Date and time the license was last verified.
  public var verified: Opencannabis_Temporal_Instant {
    get {return _storage._verified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  public var hasVerified: Bool {return _storage._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  public mutating func clearVerified() {_uniqueStorage()._verified = nil}

  /// Date and time the license was applied and committed.
  public var applied: Opencannabis_Temporal_Instant {
    get {return _storage._applied ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._applied = newValue}
  }
  /// Returns true if `applied` has been explicitly set.
  public var hasApplied: Bool {return _storage._applied != nil}
  /// Clears the value of `applied`. Subsequent reads from it will return its default value.
  public mutating func clearApplied() {_uniqueStorage()._applied = nil}

  /// Date and time the license was last modified.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a persistable claim with details about a regulatory license, presumably granting industrial cannabis
/// participation privileges to a given licensee, under the statutory authority of a given licensing agency or
/// jurisdiction. Licenses are generally considered sub-objects to existing licensee records.
public struct Bloombox_Licensure_RegulatoryLicense {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Primary key for a regulatory license record. This includes an auto-generated UUID, and any external license ID
  /// allocated and issued by the licensing agency.
  public var key: Bloombox_Licensure_LicenseKey {
    get {return _storage._key ?? Bloombox_Licensure_LicenseKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Specifies the main type of a given regulatory license. These types are enumerated in the declared type, but
  /// generally, this value is either 'temporary' or 'permanent'.
  public var type: Bloombox_Licensure_LicenseType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Specifies the agency or jurisdiction with which this license was or will be issued. It is under the authority of
  /// this governing body that the privileges embedded in this license apply to the licensee.
  public var authority: Bloombox_Licensure_LicensingAuthority {
    get {return _storage._authority ?? Bloombox_Licensure_LicensingAuthority()}
    set {_uniqueStorage()._authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  public var hasAuthority: Bool {return _storage._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  public mutating func clearAuthority() {_uniqueStorage()._authority = nil}

  /// Indicate the current, up-to-date status of this regulatory license record, considering all available informaiton.
  /// Docs about each state are available on the declared type.
  public var status: Bloombox_Licensure_LicenseStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// History of events as they occurred, to this license, or involving this license. When a license record is first
  /// allocated, this property is left empty, and begins with an entry after the first mutation of a license record.
  public var event: [Bloombox_Licensure_LicenseEvent] {
    get {return _storage._event}
    set {_uniqueStorage()._event = newValue}
  }

  /// Specifies privileges granted pursuant to the issuance, and validity, of this license. Privileges specified are used
  /// to govern behavior and obtain authorization for various actions.
  public var privilege: [Bloombox_Licensure_LicensePrivilege] {
    get {return _storage._privilege}
    set {_uniqueStorage()._privilege = newValue}
  }

  /// Timestamps that record when various actions or states became active.
  public var timestamps: Bloombox_Licensure_LicenseTimestamps {
    get {return _storage._timestamps ?? Bloombox_Licensure_LicenseTimestamps()}
    set {_uniqueStorage()._timestamps = newValue}
  }
  /// Returns true if `timestamps` has been explicitly set.
  public var hasTimestamps: Bool {return _storage._timestamps != nil}
  /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamps() {_uniqueStorage()._timestamps = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.licensure"

extension Bloombox_Licensure_LicenseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERMANENT"),
    1: .same(proto: "TEMPORARY"),
    2: .same(proto: "COMPOUND"),
  ]
}

extension Bloombox_Licensure_LicensePrivilege: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_LICENSE"),
    1: .same(proto: "CULTIVATION"),
    2: .same(proto: "DISTRIBUTION"),
    3: .same(proto: "TRANSPORT"),
    4: .same(proto: "LABORATORY"),
    5: .same(proto: "MANUFACTURING"),
    6: .same(proto: "RETAIL"),
    7: .same(proto: "DELIVERY"),
    8: .same(proto: "EVENTS"),
    9: .same(proto: "CONSUMPTION"),
  ]
}

extension Bloombox_Licensure_LicenseStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "REVOKED"),
    3: .same(proto: "EXPIRED"),
    4: .same(proto: "SUSPENDED"),
    5: .same(proto: "SUPERSEDED"),
  ]
}

extension Bloombox_Licensure_LicensingAuthority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicensingAuthority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "county"),
    3: .same(proto: "state"),
  ]

  fileprivate class _StorageClass {
    var _jurisdiction: Bloombox_Licensure_LicensingAuthority.OneOf_Jurisdiction?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _jurisdiction = source._jurisdiction
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Bloombox_Licensure_LicensingAuthority.LocalLicense?
          if let current = _storage._jurisdiction {
            try decoder.handleConflictingOneOf()
            if case .local(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._jurisdiction = .local(v)}
        case 2:
          var v: Bloombox_Licensure_LicensingAuthority.CountyLicense?
          if let current = _storage._jurisdiction {
            try decoder.handleConflictingOneOf()
            if case .county(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._jurisdiction = .county(v)}
        case 3:
          var v: Bloombox_Licensure_LicensingAuthority.StateLicense?
          if let current = _storage._jurisdiction {
            try decoder.handleConflictingOneOf()
            if case .state(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._jurisdiction = .state(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._jurisdiction {
      case .local(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .county(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .state(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicensingAuthority, rhs: Bloombox_Licensure_LicensingAuthority) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._jurisdiction != rhs_storage._jurisdiction {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_LicensingAuthority.LocalLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Licensure_LicensingAuthority.protoMessageName + ".LocalLicense"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "municipality"),
    2: .standard(proto: "county_name"),
    3: .standard(proto: "california_county"),
    4: .standard(proto: "province_name"),
    5: .standard(proto: "us_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.municipality)
      case 2:
        if self.county != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.county = .countyName(v)}
      case 3:
        if self.county != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Geo_Usa_Ca_CaliforniaCounty?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.county = .californiaCounty(v)}
      case 4:
        if self.province != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.province = .provinceName(v)}
      case 5:
        if self.province != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Geo_Usa_USState?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.province = .usState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.municipality.isEmpty {
      try visitor.visitSingularStringField(value: self.municipality, fieldNumber: 1)
    }
    switch self.county {
    case .countyName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .californiaCounty(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    case nil: break
    }
    switch self.province {
    case .provinceName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    case .usState(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.LocalLicense, rhs: Bloombox_Licensure_LicensingAuthority.LocalLicense) -> Bool {
    if lhs.municipality != rhs.municipality {return false}
    if lhs.county != rhs.county {return false}
    if lhs.province != rhs.province {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_LicensingAuthority.CountyLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Licensure_LicensingAuthority.protoMessageName + ".CountyLicense"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "california_county"),
    4: .standard(proto: "province_name"),
    5: .standard(proto: "us_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.county != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.county = .name(v)}
      case 2:
        if self.county != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Geo_Usa_Ca_CaliforniaCounty?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.county = .californiaCounty(v)}
      case 4:
        if self.province != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.province = .provinceName(v)}
      case 5:
        if self.province != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Geo_Usa_USState?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.province = .usState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.county {
    case .name(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .californiaCounty(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    case nil: break
    }
    switch self.province {
    case .provinceName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    case .usState(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.CountyLicense, rhs: Bloombox_Licensure_LicensingAuthority.CountyLicense) -> Bool {
    if lhs.county != rhs.county {return false}
    if lhs.province != rhs.province {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_LicensingAuthority.StateLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Licensure_LicensingAuthority.protoMessageName + ".StateLicense"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "province_name"),
    2: .standard(proto: "us_state"),
    3: .standard(proto: "agency_name"),
    4: .standard(proto: "california_agency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.province != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.province = .provinceName(v)}
      case 2:
        if self.province != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Geo_Usa_USState?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.province = .usState(v)}
      case 3:
        if self.agency != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.agency = .agencyName(v)}
      case 4:
        if self.agency != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Regulatory_Usa_Ca_CaliforniaAgency?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.agency = .californiaAgency(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.province {
    case .provinceName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .usState(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    case nil: break
    }
    switch self.agency {
    case .agencyName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case .californiaAgency(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicensingAuthority.StateLicense, rhs: Bloombox_Licensure_LicensingAuthority.StateLicense) -> Bool {
    if lhs.province != rhs.province {return false}
    if lhs.agency != rhs.agency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_LicenseKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicenseKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "jid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.jid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.jid.isEmpty {
      try visitor.visitSingularStringField(value: self.jid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicenseKey, rhs: Bloombox_Licensure_LicenseKey) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.jid != rhs.jid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_LicenseEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicenseEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "privilege"),
    3: .same(proto: "message"),
    4: .same(proto: "occurred"),
  ]

  fileprivate class _StorageClass {
    var _status: Bloombox_Licensure_LicenseStatus = .pending
    var _privilege: [Bloombox_Licensure_LicensePrivilege] = []
    var _message: String = String()
    var _occurred: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _privilege = source._privilege
      _message = source._message
      _occurred = source._occurred
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 2: try decoder.decodeRepeatedEnumField(value: &_storage._privilege)
        case 3: try decoder.decodeSingularStringField(value: &_storage._message)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._occurred)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 1)
      }
      if !_storage._privilege.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._privilege, fieldNumber: 2)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 3)
      }
      if let v = _storage._occurred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicenseEvent, rhs: Bloombox_Licensure_LicenseEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._privilege != rhs_storage._privilege {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._occurred != rhs_storage._occurred {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_LicenseTimestamps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicenseTimestamps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submitted"),
    2: .same(proto: "issued"),
    3: .same(proto: "received"),
    4: .same(proto: "verified"),
    5: .same(proto: "applied"),
    6: .same(proto: "modified"),
  ]

  fileprivate class _StorageClass {
    var _submitted: Opencannabis_Temporal_Date? = nil
    var _issued: Opencannabis_Temporal_Date? = nil
    var _received: Opencannabis_Temporal_Date? = nil
    var _verified: Opencannabis_Temporal_Instant? = nil
    var _applied: Opencannabis_Temporal_Instant? = nil
    var _modified: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _submitted = source._submitted
      _issued = source._issued
      _received = source._received
      _verified = source._verified
      _applied = source._applied
      _modified = source._modified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._submitted)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._issued)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._received)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._verified)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._applied)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._modified)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._submitted {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._issued {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._received {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._verified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._applied {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_LicenseTimestamps, rhs: Bloombox_Licensure_LicenseTimestamps) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._submitted != rhs_storage._submitted {return false}
        if _storage._issued != rhs_storage._issued {return false}
        if _storage._received != rhs_storage._received {return false}
        if _storage._verified != rhs_storage._verified {return false}
        if _storage._applied != rhs_storage._applied {return false}
        if _storage._modified != rhs_storage._modified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Licensure_RegulatoryLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegulatoryLicense"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "type"),
    3: .same(proto: "authority"),
    4: .same(proto: "status"),
    5: .same(proto: "event"),
    6: .same(proto: "privilege"),
    7: .same(proto: "timestamps"),
  ]

  fileprivate class _StorageClass {
    var _key: Bloombox_Licensure_LicenseKey? = nil
    var _type: Bloombox_Licensure_LicenseType = .permanent
    var _authority: Bloombox_Licensure_LicensingAuthority? = nil
    var _status: Bloombox_Licensure_LicenseStatus = .pending
    var _event: [Bloombox_Licensure_LicenseEvent] = []
    var _privilege: [Bloombox_Licensure_LicensePrivilege] = []
    var _timestamps: Bloombox_Licensure_LicenseTimestamps? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _type = source._type
      _authority = source._authority
      _status = source._status
      _event = source._event
      _privilege = source._privilege
      _timestamps = source._timestamps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._authority)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._event)
        case 6: try decoder.decodeRepeatedEnumField(value: &_storage._privilege)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._timestamps)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .permanent {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if let v = _storage._authority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if !_storage._event.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._event, fieldNumber: 5)
      }
      if !_storage._privilege.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._privilege, fieldNumber: 6)
      }
      if let v = _storage._timestamps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Licensure_RegulatoryLicense, rhs: Bloombox_Licensure_RegulatoryLicense) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._authority != rhs_storage._authority {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._event != rhs_storage._event {return false}
        if _storage._privilege != rhs_storage._privilege {return false}
        if _storage._timestamps != rhs_storage._timestamps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
