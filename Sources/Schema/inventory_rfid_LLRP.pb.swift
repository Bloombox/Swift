// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: inventory/rfid/LLRP.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies Low-Level Reader Protocol (LLRP) structures and definitions.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes available regulatory capabilities, each of which map to a jurisdiction or region, and relevant regulatory
/// agency in that region. RFID reader devices support one or more of these region/regulatory configuration profiles and
/// should apply the relevant profile when operating in that subject region.
public enum Opencannabis_Inventory_Rfid_RegulatoryCapability: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified regulatory region capability.
  case unspecifiedRegulatoryRegion // = 0

  /// United States: Federal Communications Commission (FCC), Part 15.
  case usFcc // = 1

  /// ETSI standard 302-208.
  case etsi302208 // = 2

  /// ETSI standard 300-220.
  case etsi300220 // = 3

  /// Australia: LIPD 1W.
  case australiaLipd1W // = 4

  /// Australia: LIPD 4W.
  case australiaLipd4W // = 5

  /// Japan: ARIB Standard T89.
  case japanAribStdT89 // = 6

  /// Hong Kong: OFTA-1049.
  case hongkongOfta1049 // = 7

  /// Taiwan: DGT-LP0002
  case taiwanDgtLp0002 // = 8

  /// Korea: MIC Article 5-2
  case koreaMicArticle52 // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedRegulatoryRegion
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedRegulatoryRegion
    case 1: self = .usFcc
    case 2: self = .etsi302208
    case 3: self = .etsi300220
    case 4: self = .australiaLipd1W
    case 5: self = .australiaLipd4W
    case 6: self = .japanAribStdT89
    case 7: self = .hongkongOfta1049
    case 8: self = .taiwanDgtLp0002
    case 9: self = .koreaMicArticle52
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedRegulatoryRegion: return 0
    case .usFcc: return 1
    case .etsi302208: return 2
    case .etsi300220: return 3
    case .australiaLipd1W: return 4
    case .australiaLipd4W: return 5
    case .japanAribStdT89: return 6
    case .hongkongOfta1049: return 7
    case .taiwanDgtLp0002: return 8
    case .koreaMicArticle52: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Inventory_Rfid_RegulatoryCapability: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Inventory_Rfid_RegulatoryCapability] = [
    .unspecifiedRegulatoryRegion,
    .usFcc,
    .etsi302208,
    .etsi300220,
    .australiaLipd1W,
    .australiaLipd4W,
    .japanAribStdT89,
    .hongkongOfta1049,
    .taiwanDgtLp0002,
    .koreaMicArticle52,
  ]
}

#endif  // swift(>=4.2)

/// Describes the types of start triggers that can be applied to an `ROSpec`. These describe the ways an RFID reader may
/// trigger itself to begin scanning for tags.
public enum Opencannabis_Inventory_Rfid_StartTriggerType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No trigger condition is specified. The `ROSpec` will be triggered manually over LLRP.
  case noStartTrigger // = 0

  /// Immediately trigger the `ROSpec` after installation.
  case immediate // = 1

  /// Trigger the `ROSpec` periodically, on some time-based interval.
  case periodic // = 2

  /// Trigger the `ROSpec` via hardware GPIO signals.
  case gpioStart // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStartTrigger
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStartTrigger
    case 1: self = .immediate
    case 2: self = .periodic
    case 3: self = .gpioStart
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStartTrigger: return 0
    case .immediate: return 1
    case .periodic: return 2
    case .gpioStart: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Inventory_Rfid_StartTriggerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Inventory_Rfid_StartTriggerType] = [
    .noStartTrigger,
    .immediate,
    .periodic,
    .gpioStart,
  ]
}

#endif  // swift(>=4.2)

/// Describes the types of stop triggers that may be applied to an RFID reader and set of antennae, via its use in an
/// `ROSpec` boundary configuration payload. Stop triggers describe how long to scan for, or when to stop scanning.
public enum Opencannabis_Inventory_Rfid_StopTriggerType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No stop trigger condition is specified. Effectively, this means, "scan forever."
  case noStopTrigger // = 0

  /// Specifies a deadline-based duration. After the time is up, scanning will stop.
  case duration // = 1

  /// Specifies GPIO-signal-based stop. Once a hardware signal is received, scanning will stop.
  case gpioStop // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStopTrigger
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStopTrigger
    case 1: self = .duration
    case 2: self = .gpioStop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStopTrigger: return 0
    case .duration: return 1
    case .gpioStop: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Inventory_Rfid_StopTriggerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Inventory_Rfid_StopTriggerType] = [
    .noStopTrigger,
    .duration,
    .gpioStop,
  ]
}

#endif  // swift(>=4.2)

/// Describes a boundary, or triggering, configuration profile for a given RFID reader/controller, or ROSpec,
/// configuration profile. Boundary configs describe when to start, and stop, scanning for tags.
public struct Opencannabis_Inventory_Rfid_BoundaryConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the start trigger for an `ROSpec`, which describes how RF operations, or reading events, should begin and
  /// be emitted to LLRP clients listening for read events.
  public var start: Opencannabis_Inventory_Rfid_BoundaryConfig.StartTrigger {
    get {return _storage._start ?? Opencannabis_Inventory_Rfid_BoundaryConfig.StartTrigger()}
    set {_uniqueStorage()._start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return _storage._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {_uniqueStorage()._start = nil}

  /// Specifies the stop trigger for an `ROSpec`, which describes how long to scan for RF tags. Once a stop trigger is
  /// met or otherwise satisfied, scanning and event reporting stops.
  public var stop: Opencannabis_Inventory_Rfid_BoundaryConfig.StopTrigger {
    get {return _storage._stop ?? Opencannabis_Inventory_Rfid_BoundaryConfig.StopTrigger()}
    set {_uniqueStorage()._stop = newValue}
  }
  /// Returns true if `stop` has been explicitly set.
  public var hasStop: Bool {return _storage._stop != nil}
  /// Clears the value of `stop`. Subsequent reads from it will return its default value.
  public mutating func clearStop() {_uniqueStorage()._stop = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the start trigger boundary parameters to apply.
  public struct StartTrigger {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Start trigger type to set, which may carry parameters, or not. Describes to the unit when to make a given RFID
    /// reader configuration active and begin scanning.
    public var type: Opencannabis_Inventory_Rfid_StartTriggerType = .noStartTrigger

    /// Schedule parameter, which is required for periodic triggering.
    public var schedule: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Describes the stop trigger boundary parameters to apply.
  public struct StopTrigger {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Stop trigger type to set, which may carry parameters, or not, and describes how the unit knows when to stop
    /// scanning for RFID tags and emitting events.
    public var type: Opencannabis_Inventory_Rfid_StopTriggerType = .noStopTrigger

    /// Schedule parameter, which is required for deadline-based stop triggering.
    public var schedule: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describes reporting settings that control what is reported back from the antenna when tags are found. This includes
/// the items that should be reported, frequency, tags to report, and other details.
public struct Opencannabis_Inventory_Rfid_ReportingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a configuration profile that applies settings to an RFID reader and set of connected antennae. `ROSpec`
/// objects correspond with objects in the LLRP spec that control RFID boundary triggers, tag reporting configuration,
/// and other aspects of the RF scanning process.
public struct Opencannabis_Inventory_Rfid_ROSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID assigned to reference this `ROSpec`.
  public var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Priority value this `ROSpec` should assume.
  public var priority: UInt32 {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  /// Configuration of triggering, and scanning, boundaries. Start and stop boundaries define when to start scanning and
  /// for how long, or how to know when to stop.
  public var boundary: Opencannabis_Inventory_Rfid_BoundaryConfig {
    get {return _storage._boundary ?? Opencannabis_Inventory_Rfid_BoundaryConfig()}
    set {_uniqueStorage()._boundary = newValue}
  }
  /// Returns true if `boundary` has been explicitly set.
  public var hasBoundary: Bool {return _storage._boundary != nil}
  /// Clears the value of `boundary`. Subsequent reads from it will return its default value.
  public mutating func clearBoundary() {_uniqueStorage()._boundary = nil}

  /// Reporting settings, that describe what should be reported back for each RFID tag detected within the subject
  /// reader's RFID range. This may include RSSI, antenna number, and more.
  public var reporting: Opencannabis_Inventory_Rfid_ReportingConfig {
    get {return _storage._reporting ?? Opencannabis_Inventory_Rfid_ReportingConfig()}
    set {_uniqueStorage()._reporting = newValue}
  }
  /// Returns true if `reporting` has been explicitly set.
  public var hasReporting: Bool {return _storage._reporting != nil}
  /// Clears the value of `reporting`. Subsequent reads from it will return its default value.
  public mutating func clearReporting() {_uniqueStorage()._reporting = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies where a given tag report came from. This would usually include information about the RFID reader that
/// emitted the tag report, potentially including an antenna index.
public struct Opencannabis_Inventory_Rfid_TagReportOrigin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes the RFID reader/controller device which is reporting a tag. Readers control antennae, and emit read
  /// events over LLRP to facilitate RF operations.
  public var reader: Opencannabis_Inventory_Rfid_Reader {
    get {return _storage._reader ?? Opencannabis_Inventory_Rfid_Reader()}
    set {_uniqueStorage()._reader = newValue}
  }
  /// Returns true if `reader` has been explicitly set.
  public var hasReader: Bool {return _storage._reader != nil}
  /// Clears the value of `reader`. Subsequent reads from it will return its default value.
  public mutating func clearReader() {_uniqueStorage()._reader = nil}

  /// Describes the partner account to which the reader device is assigned, if applicable, so that it may be reported to
  /// telemetry or inventory systems along with the location at which the device is located.
  public var partner: String {
    get {return _storage._partner}
    set {_uniqueStorage()._partner = newValue}
  }

  /// Describes the location account, owned by the partner account specified, where the RFID reader device is physically
  /// located. Annotates RFID traffic with licensure/physical boundaries.
  public var location: String {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Reports ths presence of a set of Radio-Frequency Identifier (RFID) tags, in a given zone, which were detected from a
/// given RFID reader controller device, from a given antenna or antennae under its control.
public struct Opencannabis_Inventory_Rfid_TagReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes information about the antenna that reported a set of tags, if information about the antenna was requested
  /// and made available by the reader.
  public var antenna: Opencannabis_Inventory_Rfid_Antenna {
    get {return _storage._antenna ?? Opencannabis_Inventory_Rfid_Antenna()}
    set {_uniqueStorage()._antenna = newValue}
  }
  /// Returns true if `antenna` has been explicitly set.
  public var hasAntenna: Bool {return _storage._antenna != nil}
  /// Clears the value of `antenna`. Subsequent reads from it will return its default value.
  public mutating func clearAntenna() {_uniqueStorage()._antenna = nil}

  /// Specifies information about the tag that was detected in this event.
  public var tag: Opencannabis_Inventory_Rfid_Tag {
    get {return _storage._tag ?? Opencannabis_Inventory_Rfid_Tag()}
    set {_uniqueStorage()._tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return _storage._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {_uniqueStorage()._tag = nil}

  /// Relative Signal Strength indicator value for this tag reading, which describes the relative strength of the signal
  /// between the subject tag and the reader/antenna that attenuated with it.
  public var rssi: Double {
    get {return _storage._rssi}
    set {_uniqueStorage()._rssi = newValue}
  }

  /// Timestamp describing when this tag was first seen by the RFID apparatus.
  public var firstSeen: Opencannabis_Temporal_Instant {
    get {return _storage._firstSeen ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._firstSeen = newValue}
  }
  /// Returns true if `firstSeen` has been explicitly set.
  public var hasFirstSeen: Bool {return _storage._firstSeen != nil}
  /// Clears the value of `firstSeen`. Subsequent reads from it will return its default value.
  public mutating func clearFirstSeen() {_uniqueStorage()._firstSeen = nil}

  /// Timestamp describing the last moment this tag was seen by the RFID apparatus.
  public var lastSeen: Opencannabis_Temporal_Instant {
    get {return _storage._lastSeen ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._lastSeen = newValue}
  }
  /// Returns true if `lastSeen` has been explicitly set.
  public var hasLastSeen: Bool {return _storage._lastSeen != nil}
  /// Clears the value of `lastSeen`. Subsequent reads from it will return its default value.
  public mutating func clearLastSeen() {_uniqueStorage()._lastSeen = nil}

  /// Timestamp describing when the edge engine received this reading event.
  public var received: Opencannabis_Temporal_Instant {
    get {return _storage._received ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  public var hasReceived: Bool {return _storage._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  public mutating func clearReceived() {_uniqueStorage()._received = nil}

  /// Describes the count of tags read at the same moment, or in the same tag report, as this tag reading.
  public var peers: UInt32 {
    get {return _storage._peers}
    set {_uniqueStorage()._peers = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describes a set of RFID tag reports, produced by an RFID reader device, through an antenna, which has attenuated with
/// one or more tags and detected their contents as part of an RF survey or reader operation run.
public struct Opencannabis_Inventory_Rfid_TagReportSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the origin of this tag report, including the reader device and partnership scope.
  public var origin: Opencannabis_Inventory_Rfid_TagReportOrigin {
    get {return _storage._origin ?? Opencannabis_Inventory_Rfid_TagReportOrigin()}
    set {_uniqueStorage()._origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  public var hasOrigin: Bool {return _storage._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  public mutating func clearOrigin() {_uniqueStorage()._origin = nil}

  /// Describes the tags seen in a given tag report set, including each tag's relative signal strength and the antenna
  /// that detected the tag in question.
  public var report: [Opencannabis_Inventory_Rfid_TagReport] {
    get {return _storage._report}
    set {_uniqueStorage()._report = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencannabis.inventory.rfid"

extension Opencannabis_Inventory_Rfid_RegulatoryCapability: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_REGULATORY_REGION"),
    1: .same(proto: "US_FCC"),
    2: .same(proto: "ETSI_302_208"),
    3: .same(proto: "ETSI_300_220"),
    4: .same(proto: "AUSTRALIA_LIPD_1W"),
    5: .same(proto: "AUSTRALIA_LIPD_4W"),
    6: .same(proto: "JAPAN_ARIB_STD_T89"),
    7: .same(proto: "HONGKONG_OFTA_1049"),
    8: .same(proto: "TAIWAN_DGT_LP0002"),
    9: .same(proto: "KOREA_MIC_ARTICLE_5_2"),
  ]
}

extension Opencannabis_Inventory_Rfid_StartTriggerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_START_TRIGGER"),
    1: .same(proto: "IMMEDIATE"),
    2: .same(proto: "PERIODIC"),
    3: .same(proto: "GPIO_START"),
  ]
}

extension Opencannabis_Inventory_Rfid_StopTriggerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_STOP_TRIGGER"),
    1: .same(proto: "DURATION"),
    2: .same(proto: "GPIO_STOP"),
  ]
}

extension Opencannabis_Inventory_Rfid_BoundaryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundaryConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  fileprivate class _StorageClass {
    var _start: Opencannabis_Inventory_Rfid_BoundaryConfig.StartTrigger? = nil
    var _stop: Opencannabis_Inventory_Rfid_BoundaryConfig.StopTrigger? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _start = source._start
      _stop = source._stop
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._start)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._stop)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._start {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._stop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_BoundaryConfig, rhs: Opencannabis_Inventory_Rfid_BoundaryConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._start != rhs_storage._start {return false}
        if _storage._stop != rhs_storage._stop {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_BoundaryConfig.StartTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencannabis_Inventory_Rfid_BoundaryConfig.protoMessageName + ".StartTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.schedule)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .noStartTrigger {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.schedule != 0 {
      try visitor.visitSingularUInt64Field(value: self.schedule, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_BoundaryConfig.StartTrigger, rhs: Opencannabis_Inventory_Rfid_BoundaryConfig.StartTrigger) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_BoundaryConfig.StopTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencannabis_Inventory_Rfid_BoundaryConfig.protoMessageName + ".StopTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.schedule)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .noStopTrigger {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.schedule != 0 {
      try visitor.visitSingularUInt64Field(value: self.schedule, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_BoundaryConfig.StopTrigger, rhs: Opencannabis_Inventory_Rfid_BoundaryConfig.StopTrigger) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_ReportingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportingConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_ReportingConfig, rhs: Opencannabis_Inventory_Rfid_ReportingConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_ROSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ROSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "priority"),
    3: .same(proto: "boundary"),
    4: .same(proto: "reporting"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _priority: UInt32 = 0
    var _boundary: Opencannabis_Inventory_Rfid_BoundaryConfig? = nil
    var _reporting: Opencannabis_Inventory_Rfid_ReportingConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _priority = source._priority
      _boundary = source._boundary
      _reporting = source._reporting
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._id)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._priority)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._boundary)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._reporting)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._priority != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._priority, fieldNumber: 2)
      }
      if let v = _storage._boundary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._reporting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_ROSpec, rhs: Opencannabis_Inventory_Rfid_ROSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._boundary != rhs_storage._boundary {return false}
        if _storage._reporting != rhs_storage._reporting {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_TagReportOrigin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagReportOrigin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reader"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _reader: Opencannabis_Inventory_Rfid_Reader? = nil
    var _partner: String = String()
    var _location: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _reader = source._reader
      _partner = source._partner
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._reader)
        case 2: try decoder.decodeSingularStringField(value: &_storage._partner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._location)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._reader {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._partner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._partner, fieldNumber: 2)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_TagReportOrigin, rhs: Opencannabis_Inventory_Rfid_TagReportOrigin) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reader != rhs_storage._reader {return false}
        if _storage._partner != rhs_storage._partner {return false}
        if _storage._location != rhs_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_TagReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "antenna"),
    2: .same(proto: "tag"),
    3: .same(proto: "rssi"),
    4: .standard(proto: "first_seen"),
    5: .standard(proto: "last_seen"),
    6: .same(proto: "received"),
    7: .same(proto: "peers"),
  ]

  fileprivate class _StorageClass {
    var _antenna: Opencannabis_Inventory_Rfid_Antenna? = nil
    var _tag: Opencannabis_Inventory_Rfid_Tag? = nil
    var _rssi: Double = 0
    var _firstSeen: Opencannabis_Temporal_Instant? = nil
    var _lastSeen: Opencannabis_Temporal_Instant? = nil
    var _received: Opencannabis_Temporal_Instant? = nil
    var _peers: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _antenna = source._antenna
      _tag = source._tag
      _rssi = source._rssi
      _firstSeen = source._firstSeen
      _lastSeen = source._lastSeen
      _received = source._received
      _peers = source._peers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._antenna)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._tag)
        case 3: try decoder.decodeSingularDoubleField(value: &_storage._rssi)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._firstSeen)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._lastSeen)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._received)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._peers)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._antenna {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._tag {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._rssi != 0 {
        try visitor.visitSingularDoubleField(value: _storage._rssi, fieldNumber: 3)
      }
      if let v = _storage._firstSeen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._lastSeen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._received {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._peers != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._peers, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_TagReport, rhs: Opencannabis_Inventory_Rfid_TagReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._antenna != rhs_storage._antenna {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._rssi != rhs_storage._rssi {return false}
        if _storage._firstSeen != rhs_storage._firstSeen {return false}
        if _storage._lastSeen != rhs_storage._lastSeen {return false}
        if _storage._received != rhs_storage._received {return false}
        if _storage._peers != rhs_storage._peers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_Rfid_TagReportSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagReportSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "report"),
  ]

  fileprivate class _StorageClass {
    var _origin: Opencannabis_Inventory_Rfid_TagReportOrigin? = nil
    var _report: [Opencannabis_Inventory_Rfid_TagReport] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _origin = source._origin
      _report = source._report
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._origin)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._report)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._origin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._report.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._report, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_Rfid_TagReportSet, rhs: Opencannabis_Inventory_Rfid_TagReportSet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._report != rhs_storage._report {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
