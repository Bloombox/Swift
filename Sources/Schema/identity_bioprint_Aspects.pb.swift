// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: identity/bioprint/Aspects.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Defines and enumerates aspects of cannabis use, or, "aspects-of-use." These values are used within the Bioprint
/// payload and greater architecture to attribute product details to responses evoked in consumers.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies groups of aspects, which are gathered into aspect categories for the purpose of data aggregation during
/// Bioprint structure updates.
public enum Bloombox_Identity_Bioprint_AspectCategory: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown, or unspecified, aspect-of-use category. Records associated with this value are rejected during processing.
  case unknownAspectCategory // = 0

  /// Includes product-categorical metrics, such as the product's main and secondary category, and materials data without
  /// including test results.
  case categorical // = 1

  /// Includes data about the product's composition, to include, compound measurements (rounded and/or bounded), non-lab
  /// materials data (also included in the product-categorical aspect group), and ratios between compounds.
  case compositional // = 2

  /// Includes situational information regarding the setting for purchase - i.e. the environment when the user buys the
  /// product. When, how, and where they buy would be considered purchase setting components.
  case purchase // = 3

  /// Includes information regarding the setting for consumption - i.e. the environment around the consumer. When, how,
  /// and where they consume would be considered consumption setting components.
  case consumption // = 4

  /// Includes information about the cost, financially and temporally, of consumption. Purchase tickets (i.e. the amount
  /// paid by the user in a transaction, with accompanying data), and consumption times (if available) are included here.
  case cost // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownAspectCategory
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownAspectCategory
    case 1: self = .categorical
    case 2: self = .compositional
    case 3: self = .purchase
    case 4: self = .consumption
    case 5: self = .cost
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownAspectCategory: return 0
    case .categorical: return 1
    case .compositional: return 2
    case .purchase: return 3
    case .consumption: return 4
    case .cost: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Identity_Bioprint_AspectCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Identity_Bioprint_AspectCategory] = [
    .unknownAspectCategory,
    .categorical,
    .compositional,
    .purchase,
    .consumption,
    .cost,
  ]
}

#endif  // swift(>=4.2)

/// Enumerates aspects of cannabis use. Each of these aspects is recorded against, as applicable, for each purchase or
/// consumption feedback session logged by the consumer. Aspects of use are tied to "affinities," which describe the user
/// response history for a given aspect-of-use over time, be it positive ("promotion") or negative ("rejection").
public enum Bloombox_Identity_Bioprint_AspectOfUse: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown, or unspecified, aspect-of-use. Records associated with this value are rejected during processing.
  case unknownAspect // = 0

  /// Product major or minor category value (i.e. "FLOWERS", or "CHOCOLATE").
  case productCategory // = 1

  /// Product method-of-ingestion value (i.e. "SMOKED").
  case methodOfConsumption // = 2

  /// Cannabinoids rounded to the nearest point value (i.e. "26.251%" becomes "26%").
  case cannabinoidAmount // = 3

  /// Cannabinoids bounded to the nearest 5% boundary (i.e. "0-5%, 5-10%" and so on).
  case cannabinoidAmountBounded // = 4

  /// Ratios between cannabinoids, in rounded form before comparison.
  case cannabinoidRatio // = 5

  /// Ratios between cannabinoids, in bounded form (at a 5% boundary, see above).
  case cannabinoidRatioBounded // = 6

  /// Bounded terpene ratio amounts, to the nearest 0.5% boundary (i.e. "0-0.5%, 0.5-1%" and so on).
  case terpeneAmount // = 7

  /// Ratios between terpenes, in bounded form (see above for further info).
  case terpeneRatio // = 8

  /// Raw materials data for the subject product.
  case materialComposition // = 9

  /// Product purchase times, bucketed into 30-minute increments.
  case timeOfPurchase // = 10

  /// Product consumption times, bucketed into 30-minute increments.
  case timeOfConsumption // = 11

  /// Physical location of purchase, by stacked jurisdiction.
  case locationOfPurchase // = 12

  /// Physical location of consumption, by stacked jurisdiction.
  case locationOfConsumption // = 13

  /// Duration of consumption, bucketed into 30-minute increments.
  case durationOfConsumption // = 14

  /// Raw cost of the consumption session in question, broken down into $1-level buckets.
  case costOfConsumption // = 15

  /// Raw cost of the entire purchase that spawned consumption, broken down into $20-level buckets.
  case costOfPurchase // = 16
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownAspect
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownAspect
    case 1: self = .productCategory
    case 2: self = .methodOfConsumption
    case 3: self = .cannabinoidAmount
    case 4: self = .cannabinoidAmountBounded
    case 5: self = .cannabinoidRatio
    case 6: self = .cannabinoidRatioBounded
    case 7: self = .terpeneAmount
    case 8: self = .terpeneRatio
    case 9: self = .materialComposition
    case 10: self = .timeOfPurchase
    case 11: self = .timeOfConsumption
    case 12: self = .locationOfPurchase
    case 13: self = .locationOfConsumption
    case 14: self = .durationOfConsumption
    case 15: self = .costOfConsumption
    case 16: self = .costOfPurchase
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownAspect: return 0
    case .productCategory: return 1
    case .methodOfConsumption: return 2
    case .cannabinoidAmount: return 3
    case .cannabinoidAmountBounded: return 4
    case .cannabinoidRatio: return 5
    case .cannabinoidRatioBounded: return 6
    case .terpeneAmount: return 7
    case .terpeneRatio: return 8
    case .materialComposition: return 9
    case .timeOfPurchase: return 10
    case .timeOfConsumption: return 11
    case .locationOfPurchase: return 12
    case .locationOfConsumption: return 13
    case .durationOfConsumption: return 14
    case .costOfConsumption: return 15
    case .costOfPurchase: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Identity_Bioprint_AspectOfUse: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Identity_Bioprint_AspectOfUse] = [
    .unknownAspect,
    .productCategory,
    .methodOfConsumption,
    .cannabinoidAmount,
    .cannabinoidAmountBounded,
    .cannabinoidRatio,
    .cannabinoidRatioBounded,
    .terpeneAmount,
    .terpeneRatio,
    .materialComposition,
    .timeOfPurchase,
    .timeOfConsumption,
    .locationOfPurchase,
    .locationOfConsumption,
    .durationOfConsumption,
    .costOfConsumption,
    .costOfPurchase,
  ]
}

#endif  // swift(>=4.2)

/// Describes an aspect of cannabis use, by mapping an enumerated aspect to descriptive information concerning that use
/// aspect. Aspect detail information can be concretely defined in a message for each aspect, each defined as a sub-
/// message here and then mapped in via a protobuf "one-of" field.
public struct Bloombox_Identity_Bioprint_Aspect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the known aspect-of-use described by this aspect record.
  public var aspect: Bloombox_Identity_Bioprint_AspectOfUse {
    get {return _storage._aspect}
    set {_uniqueStorage()._aspect = newValue}
  }

  /// Detail information regarding the above aspect dimension.
  public var detail: OneOf_Detail? {
    get {return _storage._detail}
    set {_uniqueStorage()._detail = newValue}
  }

  /// Specifies categorical details about the product, including its main kind and any subcategory, as applicable.
  public var productCategory: Bloombox_Identity_Bioprint_Aspect.ProductCategory {
    get {
      if case .productCategory(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.ProductCategory()
    }
    set {_uniqueStorage()._detail = .productCategory(newValue)}
  }

  /// Indicates information about the method the consumer used to make use of cannabis.
  public var consumptionMethod: Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption {
    get {
      if case .consumptionMethod(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption()
    }
    set {_uniqueStorage()._detail = .consumptionMethod(newValue)}
  }

  /// Measurement, in rounded form, of some compound found to be part of what constitutes some cannabis product.
  public var compound: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement {
    get {
      if case .compound(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement()
    }
    set {_uniqueStorage()._detail = .compound(newValue)}
  }

  /// Measurement, in ratio form, between two compounds found to be part of what constitutes some cannabis product.
  public var compoundRatio: Bloombox_Identity_Bioprint_Aspect.CompoundRatio {
    get {
      if case .compoundRatio(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.CompoundRatio()
    }
    set {_uniqueStorage()._detail = .compoundRatio(newValue)}
  }

  /// Contextual information relating to the time of consumption or purchase, in exact and bucketed form.
  public var timing: Bloombox_Identity_Bioprint_Aspect.TimingBoundary {
    get {
      if case .timing(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.TimingBoundary()
    }
    set {_uniqueStorage()._detail = .timing(newValue)}
  }

  /// Contextual information related to the location of consumption or purchase, in exact and bucketed form.
  public var location: Bloombox_Identity_Bioprint_Aspect.LocationBoundary {
    get {
      if case .location(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.LocationBoundary()
    }
    set {_uniqueStorage()._detail = .location(newValue)}
  }

  /// Contextual information related to the duration of consumption or purchase, in exact and bucketed form.
  public var duration: Bloombox_Identity_Bioprint_Aspect.DurationBoundary {
    get {
      if case .duration(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.DurationBoundary()
    }
    set {_uniqueStorage()._detail = .duration(newValue)}
  }

  /// Indicates cost information, related to the consumption or purchase of cannabis, in exact and bucketed form.
  public var cost: Bloombox_Identity_Bioprint_Aspect.CostBoundary {
    get {
      if case .cost(let v)? = _storage._detail {return v}
      return Bloombox_Identity_Bioprint_Aspect.CostBoundary()
    }
    set {_uniqueStorage()._detail = .cost(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Detail information regarding the above aspect dimension.
  public enum OneOf_Detail: Equatable {
    /// Specifies categorical details about the product, including its main kind and any subcategory, as applicable.
    case productCategory(Bloombox_Identity_Bioprint_Aspect.ProductCategory)
    /// Indicates information about the method the consumer used to make use of cannabis.
    case consumptionMethod(Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption)
    /// Measurement, in rounded form, of some compound found to be part of what constitutes some cannabis product.
    case compound(Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement)
    /// Measurement, in ratio form, between two compounds found to be part of what constitutes some cannabis product.
    case compoundRatio(Bloombox_Identity_Bioprint_Aspect.CompoundRatio)
    /// Contextual information relating to the time of consumption or purchase, in exact and bucketed form.
    case timing(Bloombox_Identity_Bioprint_Aspect.TimingBoundary)
    /// Contextual information related to the location of consumption or purchase, in exact and bucketed form.
    case location(Bloombox_Identity_Bioprint_Aspect.LocationBoundary)
    /// Contextual information related to the duration of consumption or purchase, in exact and bucketed form.
    case duration(Bloombox_Identity_Bioprint_Aspect.DurationBoundary)
    /// Indicates cost information, related to the consumption or purchase of cannabis, in exact and bucketed form.
    case cost(Bloombox_Identity_Bioprint_Aspect.CostBoundary)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.OneOf_Detail, rhs: Bloombox_Identity_Bioprint_Aspect.OneOf_Detail) -> Bool {
      switch (lhs, rhs) {
      case (.productCategory(let l), .productCategory(let r)): return l == r
      case (.consumptionMethod(let l), .consumptionMethod(let r)): return l == r
      case (.compound(let l), .compound(let r)): return l == r
      case (.compoundRatio(let l), .compoundRatio(let r)): return l == r
      case (.timing(let l), .timing(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      case (.duration(let l), .duration(let r)): return l == r
      case (.cost(let l), .cost(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Aspect description payload that carries detail information regarding a product's categorical identity. This would
  /// include the main product kind and any type-specific subcategory, as applicable.
  public struct ProductCategory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Main product category value.
    public var kind: Opencannabis_Base_ProductKind = .flowers

    public var subcategory: Bloombox_Identity_Bioprint_Aspect.ProductCategory.OneOf_Subcategory? = nil

    /// Subcategory value for an apothecary product.
    public var apothecary: Opencannabis_Products_ApothecaryType {
      get {
        if case .apothecary(let v)? = subcategory {return v}
        return .unspecifiedApothecary
      }
      set {subcategory = .apothecary(newValue)}
    }

    /// Subcategory value for a cartridge product.
    public var cartridge: Opencannabis_Products_CartridgeType {
      get {
        if case .cartridge(let v)? = subcategory {return v}
        return .unspecifiedCartridge
      }
      set {subcategory = .cartridge(newValue)}
    }

    /// Subcategory value for an edible product.
    public var edible: Opencannabis_Products_EdibleType {
      get {
        if case .edible(let v)? = subcategory {return v}
        return .unspecifiedEdible
      }
      set {subcategory = .edible(newValue)}
    }

    /// Subcategory value for an extracted cannabis product.
    public var extract: Opencannabis_Products_ExtractType {
      get {
        if case .extract(let v)? = subcategory {return v}
        return .unspecifiedExtract
      }
      set {subcategory = .extract(newValue)}
    }

    /// Subcategory value for a cannabis plant or seed.
    public var plant: Opencannabis_Products_PlantType {
      get {
        if case .plant(let v)? = subcategory {return v}
        return .unspecifiedPlant
      }
      set {subcategory = .plant(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Subcategory: Equatable {
      /// Subcategory value for an apothecary product.
      case apothecary(Opencannabis_Products_ApothecaryType)
      /// Subcategory value for a cartridge product.
      case cartridge(Opencannabis_Products_CartridgeType)
      /// Subcategory value for an edible product.
      case edible(Opencannabis_Products_EdibleType)
      /// Subcategory value for an extracted cannabis product.
      case extract(Opencannabis_Products_ExtractType)
      /// Subcategory value for a cannabis plant or seed.
      case plant(Opencannabis_Products_PlantType)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.ProductCategory.OneOf_Subcategory, rhs: Bloombox_Identity_Bioprint_Aspect.ProductCategory.OneOf_Subcategory) -> Bool {
        switch (lhs, rhs) {
        case (.apothecary(let l), .apothecary(let r)): return l == r
        case (.cartridge(let l), .cartridge(let r)): return l == r
        case (.edible(let l), .edible(let r)): return l == r
        case (.extract(let l), .extract(let r)): return l == r
        case (.plant(let l), .plant(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Indicates *how* cannabis is consumed, i.e., the method of cannabis consumption employed by the consumer to make use
  /// of cannabis. This indicates whether it was smoked, eaten, somehow taken otherwise.
  public struct MethodOfConsumption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates the method of biodelivery, and details associated with that type of biodelivery method.
    public var bioDelivery: Bloombox_Consumption_BiodeliveryInfo {
      get {return _storage._bioDelivery ?? Bloombox_Consumption_BiodeliveryInfo()}
      set {_uniqueStorage()._bioDelivery = newValue}
    }
    /// Returns true if `bioDelivery` has been explicitly set.
    public var hasBioDelivery: Bool {return _storage._bioDelivery != nil}
    /// Clears the value of `bioDelivery`. Subsequent reads from it will return its default value.
    public mutating func clearBioDelivery() {_uniqueStorage()._bioDelivery = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Indicates the average, or rounded, measurement for a given compound found to be present in some cannabis product.
  public struct CompoundMeasurement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the minimum witnessed amount for a particular compound.
    public var minimum: Opencannabis_Structs_Labtesting_TestValue {
      get {return _storage._minimum ?? Opencannabis_Structs_Labtesting_TestValue()}
      set {_uniqueStorage()._minimum = newValue}
    }
    /// Returns true if `minimum` has been explicitly set.
    public var hasMinimum: Bool {return _storage._minimum != nil}
    /// Clears the value of `minimum`. Subsequent reads from it will return its default value.
    public mutating func clearMinimum() {_uniqueStorage()._minimum = nil}

    /// Specifies the average witnessed amount for a particular compound.
    public var average: Opencannabis_Structs_Labtesting_TestValue {
      get {return _storage._average ?? Opencannabis_Structs_Labtesting_TestValue()}
      set {_uniqueStorage()._average = newValue}
    }
    /// Returns true if `average` has been explicitly set.
    public var hasAverage: Bool {return _storage._average != nil}
    /// Clears the value of `average`. Subsequent reads from it will return its default value.
    public mutating func clearAverage() {_uniqueStorage()._average = nil}

    /// Specifies the maximum witnessed amount for a particular compound.
    public var maximum: Opencannabis_Structs_Labtesting_TestValue {
      get {return _storage._maximum ?? Opencannabis_Structs_Labtesting_TestValue()}
      set {_uniqueStorage()._maximum = newValue}
    }
    /// Returns true if `maximum` has been explicitly set.
    public var hasMaximum: Bool {return _storage._maximum != nil}
    /// Clears the value of `maximum`. Subsequent reads from it will return its default value.
    public mutating func clearMaximum() {_uniqueStorage()._maximum = nil}

    /// Specifies the rounded-average value witnessed for a particular compound.
    public var rounded: Opencannabis_Structs_Labtesting_TestValue {
      get {return _storage._rounded ?? Opencannabis_Structs_Labtesting_TestValue()}
      set {_uniqueStorage()._rounded = newValue}
    }
    /// Returns true if `rounded` has been explicitly set.
    public var hasRounded: Bool {return _storage._rounded != nil}
    /// Clears the value of `rounded`. Subsequent reads from it will return its default value.
    public mutating func clearRounded() {_uniqueStorage()._rounded = nil}

    /// Specifies the absolute up/down presence of a given compound.
    public var presence: Bool {
      get {return _storage._presence}
      set {_uniqueStorage()._presence = newValue}
    }

    /// Specifies the compound we are expressing measurements for.
    public var compound: OneOf_Compound? {
      get {return _storage._compound}
      set {_uniqueStorage()._compound = newValue}
    }

    /// Specifies compound measurements for a given cannabinoid.
    public var cannabinoid: Opencannabis_Structs_Labtesting_Cannabinoid {
      get {
        if case .cannabinoid(let v)? = _storage._compound {return v}
        return .thc
      }
      set {_uniqueStorage()._compound = .cannabinoid(newValue)}
    }

    /// Specifies compound measurements for a given terpene or terpenoid.
    public var terpene: Opencannabis_Structs_Labtesting_Terpene {
      get {
        if case .terpene(let v)? = _storage._compound {return v}
        return .camphene
      }
      set {_uniqueStorage()._compound = .terpene(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies the compound we are expressing measurements for.
    public enum OneOf_Compound: Equatable {
      /// Specifies compound measurements for a given cannabinoid.
      case cannabinoid(Opencannabis_Structs_Labtesting_Cannabinoid)
      /// Specifies compound measurements for a given terpene or terpenoid.
      case terpene(Opencannabis_Structs_Labtesting_Terpene)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement.OneOf_Compound, rhs: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement.OneOf_Compound) -> Bool {
        switch (lhs, rhs) {
        case (.cannabinoid(let l), .cannabinoid(let r)): return l == r
        case (.terpene(let l), .terpene(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// Specifies the type of compound for which measurements are being declared.
    public enum CompoundType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Specifies measurements for a cannabinoid.
      case cannabinoid // = 0

      /// Specifies measurements for a terpene.
      case terpene // = 1

      /// Specifies measurements for a pesticide.
      case pesticide // = 2

      /// Specifies measurements for a heavy metal.
      case metal // = 3

      /// Specifies measurements for mold and mildew.
      case moldMildew // = 4

      /// Specifies measurements for moisture.
      case moisture // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .cannabinoid
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .cannabinoid
        case 1: self = .terpene
        case 2: self = .pesticide
        case 3: self = .metal
        case 4: self = .moldMildew
        case 5: self = .moisture
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .cannabinoid: return 0
        case .terpene: return 1
        case .pesticide: return 2
        case .metal: return 3
        case .moldMildew: return 4
        case .moisture: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Indicates the boundary/bucket identity of a given compound found to be present, or not present, in some cannabis
  /// product.
  public struct BoundedCompoundMeasurement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Bucket under which this compound should be filed.
    public var bucket: Bloombox_Identity_Bioprint_Aspect.BoundedCompoundMeasurement.CompoundBucket = .notPresent

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies the general bucket within which a compound's magnitude for a given test result can reside.
    public enum CompoundBucket: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The compound could not be detected with any significant presence.
      case notPresent // = 0

      /// Trace amounts of the compound were detected.
      case trace // = 1

      /// Minimal amounts of the compound were detected, relatively speaking.
      case minimal // = 2

      /// There are standard amounts of the compound detected, relatively speaking.
      case standard // = 3

      /// There were significant amounts of the compound detected, relatively speaking.
      case significant // = 4

      /// The compound was present in dominant amounts, relatively speaking.
      case dominant // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .notPresent
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .notPresent
        case 1: self = .trace
        case 2: self = .minimal
        case 3: self = .standard
        case 4: self = .significant
        case 5: self = .dominant
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .notPresent: return 0
        case .trace: return 1
        case .minimal: return 2
        case .standard: return 3
        case .significant: return 4
        case .dominant: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// Indicates the ratio between two compounds found to be present, or not present, in some cannabis product.
  public struct CompoundRatio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Left-side of the compound ratio.
    public var left: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion {
      get {return _storage._left ?? Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion()}
      set {_uniqueStorage()._left = newValue}
    }
    /// Returns true if `left` has been explicitly set.
    public var hasLeft: Bool {return _storage._left != nil}
    /// Clears the value of `left`. Subsequent reads from it will return its default value.
    public mutating func clearLeft() {_uniqueStorage()._left = nil}

    /// Right-side of the compound ratio.
    public var right: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion {
      get {return _storage._right ?? Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion()}
      set {_uniqueStorage()._right = newValue}
    }
    /// Returns true if `right` has been explicitly set.
    public var hasRight: Bool {return _storage._right != nil}
    /// Clears the value of `right`. Subsequent reads from it will return its default value.
    public mutating func clearRight() {_uniqueStorage()._right = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies a left, or right, portion of a given compound ratio, along with the compound involved.
    public struct RatioPortion {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Value of the ratio portion.
      public var value: UInt32 = 0

      /// Describes the compound for which we are indicating a ratio portion.
      public var compound: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion.OneOf_Compound? = nil

      /// Specifies compound measurements for a given cannabinoid.
      public var cannabinoid: Opencannabis_Structs_Labtesting_Cannabinoid {
        get {
          if case .cannabinoid(let v)? = compound {return v}
          return .thc
        }
        set {compound = .cannabinoid(newValue)}
      }

      /// Specifies compound measurements for a given terpene or terpenoid.
      public var terpene: Opencannabis_Structs_Labtesting_Terpene {
        get {
          if case .terpene(let v)? = compound {return v}
          return .camphene
        }
        set {compound = .terpene(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Describes the compound for which we are indicating a ratio portion.
      public enum OneOf_Compound: Equatable {
        /// Specifies compound measurements for a given cannabinoid.
        case cannabinoid(Opencannabis_Structs_Labtesting_Cannabinoid)
        /// Specifies compound measurements for a given terpene or terpenoid.
        case terpene(Opencannabis_Structs_Labtesting_Terpene)

      #if !swift(>=4.1)
        public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion.OneOf_Compound, rhs: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion.OneOf_Compound) -> Bool {
          switch (lhs, rhs) {
          case (.cannabinoid(let l), .cannabinoid(let r)): return l == r
          case (.terpene(let l), .terpene(let r)): return l == r
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Indicates a timing-based boundary or bucket within which some cannabis use or product resides. This structure may
  /// be used both with consumption timing and purchase timing boundaries.
  public struct TimingBoundary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The first point in a timing boundary.
    public var first: Opencannabis_Temporal_Timehash {
      get {return _storage._first ?? Opencannabis_Temporal_Timehash()}
      set {_uniqueStorage()._first = newValue}
    }
    /// Returns true if `first` has been explicitly set.
    public var hasFirst: Bool {return _storage._first != nil}
    /// Clears the value of `first`. Subsequent reads from it will return its default value.
    public mutating func clearFirst() {_uniqueStorage()._first = nil}

    /// The latest point in a timing boundary.
    public var latest: Opencannabis_Temporal_Timehash {
      get {return _storage._latest ?? Opencannabis_Temporal_Timehash()}
      set {_uniqueStorage()._latest = newValue}
    }
    /// Returns true if `latest` has been explicitly set.
    public var hasLatest: Bool {return _storage._latest != nil}
    /// Clears the value of `latest`. Subsequent reads from it will return its default value.
    public mutating func clearLatest() {_uniqueStorage()._latest = nil}

    /// The narrowest-common-area within which behavior of some kind was observed.
    public var area: Opencannabis_Temporal_Timehash {
      get {return _storage._area ?? Opencannabis_Temporal_Timehash()}
      set {_uniqueStorage()._area = newValue}
    }
    /// Returns true if `area` has been explicitly set.
    public var hasArea: Bool {return _storage._area != nil}
    /// Clears the value of `area`. Subsequent reads from it will return its default value.
    public mutating func clearArea() {_uniqueStorage()._area = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Indicates a location-based boundary or bucket within which some cannabis use or product resides. This structure may
  /// be used both with consumption and purchase location boundaries.
  public struct LocationBoundary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates the narrowest-common-area within which behavior of some kind was observed.
    public var area: Opencannabis_Geo_Geohash {
      get {return _storage._area ?? Opencannabis_Geo_Geohash()}
      set {_uniqueStorage()._area = newValue}
    }
    /// Returns true if `area` has been explicitly set.
    public var hasArea: Bool {return _storage._area != nil}
    /// Clears the value of `area`. Subsequent reads from it will return its default value.
    public mutating func clearArea() {_uniqueStorage()._area = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Indicates a duration-based boundary or bucket within which some cannabis use or product resides. This structure may
  /// be used both with consumption and purchase duration boundaries.
  public struct DurationBoundary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies a minimum duration for a given time-based metric.
    public var minimum: Opencannabis_Temporal_Duration {
      get {return _storage._minimum ?? Opencannabis_Temporal_Duration()}
      set {_uniqueStorage()._minimum = newValue}
    }
    /// Returns true if `minimum` has been explicitly set.
    public var hasMinimum: Bool {return _storage._minimum != nil}
    /// Clears the value of `minimum`. Subsequent reads from it will return its default value.
    public mutating func clearMinimum() {_uniqueStorage()._minimum = nil}

    /// Specifies an average duration for a given time-based metric.
    public var average: Opencannabis_Temporal_Duration {
      get {return _storage._average ?? Opencannabis_Temporal_Duration()}
      set {_uniqueStorage()._average = newValue}
    }
    /// Returns true if `average` has been explicitly set.
    public var hasAverage: Bool {return _storage._average != nil}
    /// Clears the value of `average`. Subsequent reads from it will return its default value.
    public mutating func clearAverage() {_uniqueStorage()._average = nil}

    /// Specifies a maximum duration for a given time-based metric.
    public var maximum: Opencannabis_Temporal_Duration {
      get {return _storage._maximum ?? Opencannabis_Temporal_Duration()}
      set {_uniqueStorage()._maximum = newValue}
    }
    /// Returns true if `maximum` has been explicitly set.
    public var hasMaximum: Bool {return _storage._maximum != nil}
    /// Clears the value of `maximum`. Subsequent reads from it will return its default value.
    public mutating func clearMaximum() {_uniqueStorage()._maximum = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Indicates a cost-based boundary or bucket within which some cannabis use or product resides. This structure may be
  /// used both with consumption and purchase cost boundaries.
  public struct CostBoundary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies a minimum cost boundary.
    public var minimum: Opencannabis_Commerce_CurrencyValue {
      get {return _storage._minimum ?? Opencannabis_Commerce_CurrencyValue()}
      set {_uniqueStorage()._minimum = newValue}
    }
    /// Returns true if `minimum` has been explicitly set.
    public var hasMinimum: Bool {return _storage._minimum != nil}
    /// Clears the value of `minimum`. Subsequent reads from it will return its default value.
    public mutating func clearMinimum() {_uniqueStorage()._minimum = nil}

    /// Specifies an average cost boundary.
    public var average: Opencannabis_Commerce_CurrencyValue {
      get {return _storage._average ?? Opencannabis_Commerce_CurrencyValue()}
      set {_uniqueStorage()._average = newValue}
    }
    /// Returns true if `average` has been explicitly set.
    public var hasAverage: Bool {return _storage._average != nil}
    /// Clears the value of `average`. Subsequent reads from it will return its default value.
    public mutating func clearAverage() {_uniqueStorage()._average = nil}

    /// Specifies a maximum cost boundary.
    public var maximum: Opencannabis_Commerce_CurrencyValue {
      get {return _storage._maximum ?? Opencannabis_Commerce_CurrencyValue()}
      set {_uniqueStorage()._maximum = newValue}
    }
    /// Returns true if `maximum` has been explicitly set.
    public var hasMaximum: Bool {return _storage._maximum != nil}
    /// Clears the value of `maximum`. Subsequent reads from it will return its default value.
    public mutating func clearMaximum() {_uniqueStorage()._maximum = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describes a set of aspects that relate to one another in some manner. For instance, general composition or compound
/// specific composition aspects, versus aspects that deal with how or when the user consumed. Aspect groups are another
/// opportunity to map user affinities, in this case, in aggregate across any sub-aspects that apply.
public struct Bloombox_Identity_Bioprint_AspectGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Category defining this group of aspects. Only one instance of any given category group may be present in a Bioprint
  /// content payload - i.e., duplicate payloads (by category) are not allowed.
  public var category: Bloombox_Identity_Bioprint_AspectCategory = .unknownAspectCategory

  /// Aspects constituting this aspect group. Structurally, aspect groups contain aspects, with each aspect payload
  /// constrained to a unique presence in each category (which themselves are unique per-Bioprint). Aspects are grouped
  /// in such a manner to create meaningful aggregations between individual aspects. Semantically, this relationship
  /// declares a super-category for a given aspect.
  public var aspect: [Bloombox_Identity_Bioprint_Aspect] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Extension support defined in Aspects.proto.

extension Google_Protobuf_EnumValueOptions {

  /// Describes the aspect group for a given aspect-of-use.
  public var Bloombox_Identity_Bioprint_aspectGroup: Bloombox_Identity_Bioprint_AspectCategory {
    get {return getExtensionValue(ext: Bloombox_Identity_Bioprint_Extensions_aspect_group) ?? .unknownAspectCategory}
    set {setExtensionValue(ext: Bloombox_Identity_Bioprint_Extensions_aspect_group, value: newValue)}
  }
  /// Returns true if extension `Bloombox_Identity_Bioprint_Extensions_aspect_group`
  /// has been explicitly set.
  public var hasBloombox_Identity_Bioprint_aspectGroup: Bool {
    return hasExtensionValue(ext: Bloombox_Identity_Bioprint_Extensions_aspect_group)
  }
  /// Clears the value of extension `Bloombox_Identity_Bioprint_Extensions_aspect_group`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBloombox_Identity_Bioprint_aspectGroup() {
    clearExtensionValue(ext: Bloombox_Identity_Bioprint_Extensions_aspect_group)
  }

}

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let Bloombox_Identity_Bioprint_Aspects_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Bloombox_Identity_Bioprint_Extensions_aspect_group
]

/// Describes the aspect group for a given aspect-of-use.
let Bloombox_Identity_Bioprint_Extensions_aspect_group = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalEnumExtensionField<Bloombox_Identity_Bioprint_AspectCategory>, Google_Protobuf_EnumValueOptions>(
  _protobuf_fieldNumber: 8005,
  fieldName: "bloombox.identity.bioprint.aspect_group"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.identity.bioprint"

extension Bloombox_Identity_Bioprint_AspectCategory: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ASPECT_CATEGORY"),
    1: .same(proto: "CATEGORICAL"),
    2: .same(proto: "COMPOSITIONAL"),
    3: .same(proto: "PURCHASE"),
    4: .same(proto: "CONSUMPTION"),
    5: .same(proto: "COST"),
  ]
}

extension Bloombox_Identity_Bioprint_AspectOfUse: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ASPECT"),
    1: .same(proto: "PRODUCT_CATEGORY"),
    2: .same(proto: "METHOD_OF_CONSUMPTION"),
    3: .same(proto: "CANNABINOID_AMOUNT"),
    4: .same(proto: "CANNABINOID_AMOUNT_BOUNDED"),
    5: .same(proto: "CANNABINOID_RATIO"),
    6: .same(proto: "CANNABINOID_RATIO_BOUNDED"),
    7: .same(proto: "TERPENE_AMOUNT"),
    8: .same(proto: "TERPENE_RATIO"),
    9: .same(proto: "MATERIAL_COMPOSITION"),
    10: .same(proto: "TIME_OF_PURCHASE"),
    11: .same(proto: "TIME_OF_CONSUMPTION"),
    12: .same(proto: "LOCATION_OF_PURCHASE"),
    13: .same(proto: "LOCATION_OF_CONSUMPTION"),
    14: .same(proto: "DURATION_OF_CONSUMPTION"),
    15: .same(proto: "COST_OF_CONSUMPTION"),
    16: .same(proto: "COST_OF_PURCHASE"),
  ]
}

extension Bloombox_Identity_Bioprint_Aspect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aspect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aspect"),
    10: .standard(proto: "product_category"),
    11: .standard(proto: "consumption_method"),
    12: .same(proto: "compound"),
    13: .standard(proto: "compound_ratio"),
    14: .same(proto: "timing"),
    15: .same(proto: "location"),
    16: .same(proto: "duration"),
    17: .same(proto: "cost"),
  ]

  fileprivate class _StorageClass {
    var _aspect: Bloombox_Identity_Bioprint_AspectOfUse = .unknownAspect
    var _detail: Bloombox_Identity_Bioprint_Aspect.OneOf_Detail?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _aspect = source._aspect
      _detail = source._detail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._aspect)
        case 10:
          var v: Bloombox_Identity_Bioprint_Aspect.ProductCategory?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .productCategory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .productCategory(v)}
        case 11:
          var v: Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .consumptionMethod(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .consumptionMethod(v)}
        case 12:
          var v: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .compound(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .compound(v)}
        case 13:
          var v: Bloombox_Identity_Bioprint_Aspect.CompoundRatio?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .compoundRatio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .compoundRatio(v)}
        case 14:
          var v: Bloombox_Identity_Bioprint_Aspect.TimingBoundary?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .timing(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .timing(v)}
        case 15:
          var v: Bloombox_Identity_Bioprint_Aspect.LocationBoundary?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .location(v)}
        case 16:
          var v: Bloombox_Identity_Bioprint_Aspect.DurationBoundary?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .duration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .duration(v)}
        case 17:
          var v: Bloombox_Identity_Bioprint_Aspect.CostBoundary?
          if let current = _storage._detail {
            try decoder.handleConflictingOneOf()
            if case .cost(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._detail = .cost(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._aspect != .unknownAspect {
        try visitor.visitSingularEnumField(value: _storage._aspect, fieldNumber: 1)
      }
      switch _storage._detail {
      case .productCategory(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .consumptionMethod(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .compound(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .compoundRatio(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .timing(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .duration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .cost(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect, rhs: Bloombox_Identity_Bioprint_Aspect) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._aspect != rhs_storage._aspect {return false}
        if _storage._detail != rhs_storage._detail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.ProductCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".ProductCategory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    10: .same(proto: "apothecary"),
    11: .same(proto: "cartridge"),
    12: .same(proto: "edible"),
    13: .same(proto: "extract"),
    14: .same(proto: "plant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.kind)
      case 10:
        if self.subcategory != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Products_ApothecaryType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.subcategory = .apothecary(v)}
      case 11:
        if self.subcategory != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Products_CartridgeType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.subcategory = .cartridge(v)}
      case 12:
        if self.subcategory != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Products_EdibleType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.subcategory = .edible(v)}
      case 13:
        if self.subcategory != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Products_ExtractType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.subcategory = .extract(v)}
      case 14:
        if self.subcategory != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Products_PlantType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.subcategory = .plant(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .flowers {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    switch self.subcategory {
    case .apothecary(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    case .cartridge(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    case .edible(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    case .extract(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
    case .plant(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.ProductCategory, rhs: Bloombox_Identity_Bioprint_Aspect.ProductCategory) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subcategory != rhs.subcategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".MethodOfConsumption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bio_delivery"),
  ]

  fileprivate class _StorageClass {
    var _bioDelivery: Bloombox_Consumption_BiodeliveryInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bioDelivery = source._bioDelivery
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._bioDelivery)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._bioDelivery {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption, rhs: Bloombox_Identity_Bioprint_Aspect.MethodOfConsumption) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bioDelivery != rhs_storage._bioDelivery {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".CompoundMeasurement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minimum"),
    2: .same(proto: "average"),
    3: .same(proto: "maximum"),
    4: .same(proto: "rounded"),
    5: .same(proto: "presence"),
    10: .same(proto: "cannabinoid"),
    11: .same(proto: "terpene"),
  ]

  fileprivate class _StorageClass {
    var _minimum: Opencannabis_Structs_Labtesting_TestValue? = nil
    var _average: Opencannabis_Structs_Labtesting_TestValue? = nil
    var _maximum: Opencannabis_Structs_Labtesting_TestValue? = nil
    var _rounded: Opencannabis_Structs_Labtesting_TestValue? = nil
    var _presence: Bool = false
    var _compound: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement.OneOf_Compound?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _minimum = source._minimum
      _average = source._average
      _maximum = source._maximum
      _rounded = source._rounded
      _presence = source._presence
      _compound = source._compound
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._minimum)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._average)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._maximum)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._rounded)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._presence)
        case 10:
          if _storage._compound != nil {try decoder.handleConflictingOneOf()}
          var v: Opencannabis_Structs_Labtesting_Cannabinoid?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._compound = .cannabinoid(v)}
        case 11:
          if _storage._compound != nil {try decoder.handleConflictingOneOf()}
          var v: Opencannabis_Structs_Labtesting_Terpene?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._compound = .terpene(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._minimum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._average {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._maximum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._rounded {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._presence != false {
        try visitor.visitSingularBoolField(value: _storage._presence, fieldNumber: 5)
      }
      switch _storage._compound {
      case .cannabinoid(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      case .terpene(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement, rhs: Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._minimum != rhs_storage._minimum {return false}
        if _storage._average != rhs_storage._average {return false}
        if _storage._maximum != rhs_storage._maximum {return false}
        if _storage._rounded != rhs_storage._rounded {return false}
        if _storage._presence != rhs_storage._presence {return false}
        if _storage._compound != rhs_storage._compound {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.CompoundMeasurement.CompoundType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANNABINOID"),
    1: .same(proto: "TERPENE"),
    2: .same(proto: "PESTICIDE"),
    3: .same(proto: "METAL"),
    4: .same(proto: "MOLD_MILDEW"),
    5: .same(proto: "MOISTURE"),
  ]
}

extension Bloombox_Identity_Bioprint_Aspect.BoundedCompoundMeasurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".BoundedCompoundMeasurement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.bucket)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bucket != .notPresent {
      try visitor.visitSingularEnumField(value: self.bucket, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.BoundedCompoundMeasurement, rhs: Bloombox_Identity_Bioprint_Aspect.BoundedCompoundMeasurement) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.BoundedCompoundMeasurement.CompoundBucket: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_PRESENT"),
    1: .same(proto: "TRACE"),
    2: .same(proto: "MINIMAL"),
    3: .same(proto: "STANDARD"),
    4: .same(proto: "SIGNIFICANT"),
    5: .same(proto: "DOMINANT"),
  ]
}

extension Bloombox_Identity_Bioprint_Aspect.CompoundRatio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".CompoundRatio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "right"),
  ]

  fileprivate class _StorageClass {
    var _left: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion? = nil
    var _right: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _left = source._left
      _right = source._right
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._left)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._right)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.CompoundRatio, rhs: Bloombox_Identity_Bioprint_Aspect.CompoundRatio) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.CompoundRatio.protoMessageName + ".RatioPortion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    10: .same(proto: "cannabinoid"),
    11: .same(proto: "terpene"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.value)
      case 10:
        if self.compound != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Structs_Labtesting_Cannabinoid?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.compound = .cannabinoid(v)}
      case 11:
        if self.compound != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Structs_Labtesting_Terpene?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.compound = .terpene(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    switch self.compound {
    case .cannabinoid(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    case .terpene(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion, rhs: Bloombox_Identity_Bioprint_Aspect.CompoundRatio.RatioPortion) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.compound != rhs.compound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.TimingBoundary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".TimingBoundary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "first"),
    2: .same(proto: "latest"),
    3: .same(proto: "area"),
  ]

  fileprivate class _StorageClass {
    var _first: Opencannabis_Temporal_Timehash? = nil
    var _latest: Opencannabis_Temporal_Timehash? = nil
    var _area: Opencannabis_Temporal_Timehash? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _first = source._first
      _latest = source._latest
      _area = source._area
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._first)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._latest)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._area)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._first {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._latest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._area {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.TimingBoundary, rhs: Bloombox_Identity_Bioprint_Aspect.TimingBoundary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._first != rhs_storage._first {return false}
        if _storage._latest != rhs_storage._latest {return false}
        if _storage._area != rhs_storage._area {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.LocationBoundary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".LocationBoundary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "area"),
  ]

  fileprivate class _StorageClass {
    var _area: Opencannabis_Geo_Geohash? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _area = source._area
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._area)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._area {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.LocationBoundary, rhs: Bloombox_Identity_Bioprint_Aspect.LocationBoundary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._area != rhs_storage._area {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.DurationBoundary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".DurationBoundary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minimum"),
    2: .same(proto: "average"),
    3: .same(proto: "maximum"),
  ]

  fileprivate class _StorageClass {
    var _minimum: Opencannabis_Temporal_Duration? = nil
    var _average: Opencannabis_Temporal_Duration? = nil
    var _maximum: Opencannabis_Temporal_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _minimum = source._minimum
      _average = source._average
      _maximum = source._maximum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._minimum)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._average)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._maximum)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._minimum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._average {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._maximum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.DurationBoundary, rhs: Bloombox_Identity_Bioprint_Aspect.DurationBoundary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._minimum != rhs_storage._minimum {return false}
        if _storage._average != rhs_storage._average {return false}
        if _storage._maximum != rhs_storage._maximum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Aspect.CostBoundary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Identity_Bioprint_Aspect.protoMessageName + ".CostBoundary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minimum"),
    2: .same(proto: "average"),
    3: .same(proto: "maximum"),
  ]

  fileprivate class _StorageClass {
    var _minimum: Opencannabis_Commerce_CurrencyValue? = nil
    var _average: Opencannabis_Commerce_CurrencyValue? = nil
    var _maximum: Opencannabis_Commerce_CurrencyValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _minimum = source._minimum
      _average = source._average
      _maximum = source._maximum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._minimum)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._average)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._maximum)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._minimum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._average {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._maximum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Aspect.CostBoundary, rhs: Bloombox_Identity_Bioprint_Aspect.CostBoundary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._minimum != rhs_storage._minimum {return false}
        if _storage._average != rhs_storage._average {return false}
        if _storage._maximum != rhs_storage._maximum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_AspectGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AspectGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.category)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.aspect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .unknownAspectCategory {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aspect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_AspectGroup, rhs: Bloombox_Identity_Bioprint_AspectGroup) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
