// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wallet/v1beta1/WalletService_Beta1.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Provides the Wallet API, which offers the ability to issue, manage, resolve and list digital pass cards from the
/// perspective of the subject customer/user. Membership cards, from the dispensary/retailer's perspective, are managed
/// via membership methods in the Dashboard API.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates known errors that may be thrown by wallet operations.
public enum Bloombox_Schema_Services_Wallet_V1beta1_WalletError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// There was no error.
  case noError // = 0

  /// The specified partner key was invalid.
  case invalidPartner // = 1

  /// The specified location key was invalid.
  case invalidLocation // = 2

  /// The specified device key was invalid.
  case invalidDevice // = 3

  /// The specified ID or authorization token was invalid.
  case invalidToken // = 4

  /// The subject partner could not be found.
  case partnerNotFound // = 5

  /// The subject location could not be found.
  case locationNotFound // = 6

  /// Generic access-denied-error.
  case accessDenied // = 98

  /// An internal error was encountered.
  case internalError // = 99
  case UNRECOGNIZED(Int)

  public init() {
    self = .noError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 1: self = .invalidPartner
    case 2: self = .invalidLocation
    case 3: self = .invalidDevice
    case 4: self = .invalidToken
    case 5: self = .partnerNotFound
    case 6: self = .locationNotFound
    case 98: self = .accessDenied
    case 99: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noError: return 0
    case .invalidPartner: return 1
    case .invalidLocation: return 2
    case .invalidDevice: return 3
    case .invalidToken: return 4
    case .partnerNotFound: return 5
    case .locationNotFound: return 6
    case .accessDenied: return 98
    case .internalError: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Schema_Services_Wallet_V1beta1_WalletError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Schema_Services_Wallet_V1beta1_WalletError] = [
    .noError,
    .invalidPartner,
    .invalidLocation,
    .invalidDevice,
    .invalidToken,
    .partnerNotFound,
    .locationNotFound,
    .accessDenied,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

/// Request to list cards for a given user, from their own perspective, optionally filtering by partner/location key.
public struct Bloombox_Schema_Services_Wallet_V1beta1_CardList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to list cards for a given user.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User that cards are being requested for.
    public var user: Bloombox_Schema_Identity_UserKey {
      get {return _storage._user ?? Bloombox_Schema_Identity_UserKey()}
      set {_uniqueStorage()._user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {return _storage._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {_uniqueStorage()._user = nil}

    /// Partner record for which cards are being requested.
    public var partner: String {
      get {return _storage._partner}
      set {_uniqueStorage()._partner = newValue}
    }

    /// Location record for which cards are being requested.
    public var location: String {
      get {return _storage._location}
      set {_uniqueStorage()._location = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to list cards for a given user.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Wallet pass keys matching the specified request.
    public var card: [Bloombox_Schema_Identity_Pass_PassKey] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Operation to list cards for a given user.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to list cards for a given user.
    public var request: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Request {
      get {return _storage._request ?? Bloombox_Schema_Services_Wallet_V1beta1_CardList.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to list cards for a given user.
    public var response: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Response {
      get {return _storage._response ?? Bloombox_Schema_Services_Wallet_V1beta1_CardList.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Retrieve an individual digital wallet pass card record, from the owning user's perspective.
public struct Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to retrieve a digital wallet pass record, addressed by its key.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Wallet pass key being requested.
    public var card: Bloombox_Schema_Identity_Pass_PassKey {
      get {return _storage._card ?? Bloombox_Schema_Identity_Pass_PassKey()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to retrieve one or more digital wallet passes.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resulting record for the digital pass in question.
    public var record: Bloombox_Schema_Identity_Pass_Pass {
      get {return _storage._record ?? Bloombox_Schema_Identity_Pass_Pass()}
      set {_uniqueStorage()._record = newValue}
    }
    /// Returns true if `record` has been explicitly set.
    public var hasRecord: Bool {return _storage._record != nil}
    /// Clears the value of `record`. Subsequent reads from it will return its default value.
    public mutating func clearRecord() {_uniqueStorage()._record = nil}

    /// Cryptographic hash of the raw pass record, for later verification.
    public var fingerprint: Opencannabis_Crypto_Primitives_Integrity_Hash {
      get {return _storage._fingerprint ?? Opencannabis_Crypto_Primitives_Integrity_Hash()}
      set {_uniqueStorage()._fingerprint = newValue}
    }
    /// Returns true if `fingerprint` has been explicitly set.
    public var hasFingerprint: Bool {return _storage._fingerprint != nil}
    /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
    public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Operation to retrieve an individual digital card record.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to retrieve a digital wallet pass record, addressed by its key.
    public var request: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Request {
      get {return _storage._request ?? Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to retrieve one or more digital card records.
    public var response: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Response {
      get {return _storage._response ?? Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies a request and response flow for an RPC operation to provision a new digital wallet card. Provisioning a
/// card occurs first in the card lifecycle, before the card is issued, and after the user has already satisfied any
/// constraints or requirements related to the partner or location context for which the card is being issued.
public struct Bloombox_Schema_Services_Wallet_V1beta1_CardProvision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request, issued from the user's perspective, to issue a new digital card.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User that the card provision request is being issued for.
    public var user: Bloombox_Schema_Identity_UserKey {
      get {return _storage._user ?? Bloombox_Schema_Identity_UserKey()}
      set {_uniqueStorage()._user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {return _storage._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {_uniqueStorage()._user = nil}

    /// Specifies the context under which this card is being provisioned.
    public var context: OneOf_Context? {
      get {return _storage._context}
      set {_uniqueStorage()._context = newValue}
    }

    /// Partner record for which this card is being provisioned.
    public var partner: Bloombox_Schema_Partner_PartnerKey {
      get {
        if case .partner(let v)? = _storage._context {return v}
        return Bloombox_Schema_Partner_PartnerKey()
      }
      set {_uniqueStorage()._context = .partner(newValue)}
    }

    /// Location record for which this card is being provisioned.
    public var location: Bloombox_Schema_Partner_LocationKey {
      get {
        if case .location(let v)? = _storage._context {return v}
        return Bloombox_Schema_Partner_LocationKey()
      }
      set {_uniqueStorage()._context = .location(newValue)}
    }

    /// Special flag indicating a globally-usable identity card for the user.
    public var identity: Bool {
      get {
        if case .identity(let v)? = _storage._context {return v}
        return false
      }
      set {_uniqueStorage()._context = .identity(newValue)}
    }

    /// Public key for the user, so their signatures later on may be verified.
    public var publicKey: Opencannabis_Crypto_Primitives_Pki_KeyMaterial {
      get {return _storage._publicKey ?? Opencannabis_Crypto_Primitives_Pki_KeyMaterial()}
      set {_uniqueStorage()._publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    public var hasPublicKey: Bool {return _storage._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies the context under which this card is being provisioned.
    public enum OneOf_Context: Equatable {
      /// Partner record for which this card is being provisioned.
      case partner(Bloombox_Schema_Partner_PartnerKey)
      /// Location record for which this card is being provisioned.
      case location(Bloombox_Schema_Partner_LocationKey)
      /// Special flag indicating a globally-usable identity card for the user.
      case identity(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request.OneOf_Context, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request.OneOf_Context) -> Bool {
        switch (lhs, rhs) {
        case (.partner(let l), .partner(let r)): return l == r
        case (.location(let l), .location(let r)): return l == r
        case (.identity(let l), .identity(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to provision a new digital card.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Wallet pass key provisioned for the requested ID card.
    public var card: Bloombox_Schema_Identity_Pass_PassKey {
      get {return _storage._card ?? Bloombox_Schema_Identity_Pass_PassKey()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    /// Issuance nonce, used in the card-issue step to claim this provisioned digital wallet card.
    public var nonce: String {
      get {return _storage._nonce}
      set {_uniqueStorage()._nonce = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies an operation to provision a new digital card.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to provision a new card.
    public var request: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request {
      get {return _storage._request ?? Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to provision a new digital card.
    public var response: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Response {
      get {return _storage._response ?? Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Issue a digital card for a given user, from the user's perspective.
public struct Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request from a user to issue a digital wallet pass in a given commercial context.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User that cards are being requested for.
    public var user: Bloombox_Schema_Identity_UserKey {
      get {return _storage._user ?? Bloombox_Schema_Identity_UserKey()}
      set {_uniqueStorage()._user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {return _storage._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {_uniqueStorage()._user = nil}

    /// Wallet pass key provisioned for the requested ID card.
    public var card: Bloombox_Schema_Identity_Pass_PassKey {
      get {return _storage._card ?? Bloombox_Schema_Identity_Pass_PassKey()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    /// Nonce, provisioned via the card provisioning process, and provided to the device requesting issuance of the
    /// digital card.
    public var nonce: String {
      get {return _storage._nonce}
      set {_uniqueStorage()._nonce = newValue}
    }

    /// Signature from the user's private key, performed over the user key and context value.
    public var signature: Opencannabis_Crypto_Signature {
      get {return _storage._signature ?? Opencannabis_Crypto_Signature()}
      set {_uniqueStorage()._signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return _storage._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {_uniqueStorage()._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to issue a pass. Includes the issued-pass record, which should have a URI attached where the
  /// raw pass content can be downloaded.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Record for the digital pass in question, after it has been shifted to an issued-state.
    public var card: Bloombox_Schema_Identity_Pass_Pass {
      get {return _storage._card ?? Bloombox_Schema_Identity_Pass_Pass()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Represents an entire operation to request the issuance of a digital wallet pass card.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to issue a digital pass card.
    public var request: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Request {
      get {return _storage._request ?? Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Response to a request to issue a digital pass card.
    public var response: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Response {
      get {return _storage._response ?? Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Response()}
      set {_uniqueStorage()._response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {return _storage._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {_uniqueStorage()._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies a request, on behalf of a user, to decommission a given card they own.
public struct Bloombox_Schema_Services_Wallet_V1beta1_CardVoid {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to void a digital card, on a user's behalf.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Wallet pass key for the digital card that should be decommissioned.
    public var card: Bloombox_Schema_Identity_Pass_PassKey {
      get {return _storage._card ?? Bloombox_Schema_Identity_Pass_PassKey()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    public var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    public mutating func clearCard() {_uniqueStorage()._card = nil}

    /// Signature from the user's private key, performed over the pass key to be voided.
    public var signature: Opencannabis_Crypto_Signature {
      get {return _storage._signature ?? Opencannabis_Crypto_Signature()}
      set {_uniqueStorage()._signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    public var hasSignature: Bool {return _storage._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    public mutating func clearSignature() {_uniqueStorage()._signature = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Represents an entire operation to decommission a card on a user's behalf.
  public struct Operation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Request to void a given digital card.
    public var request: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Request {
      get {return _storage._request ?? Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Request()}
      set {_uniqueStorage()._request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {return _storage._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {_uniqueStorage()._request = nil}

    /// Whether the deletion was successful or not.
    public var success: Bool {
      get {return _storage._success}
      set {_uniqueStorage()._success = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.schema.services.wallet.v1beta1"

extension Bloombox_Schema_Services_Wallet_V1beta1_WalletError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    1: .same(proto: "INVALID_PARTNER"),
    2: .same(proto: "INVALID_LOCATION"),
    3: .same(proto: "INVALID_DEVICE"),
    4: .same(proto: "INVALID_TOKEN"),
    5: .same(proto: "PARTNER_NOT_FOUND"),
    6: .same(proto: "LOCATION_NOT_FOUND"),
    98: .same(proto: "ACCESS_DENIED"),
    99: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardList.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardList.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _user: Bloombox_Schema_Identity_UserKey? = nil
    var _partner: String = String()
    var _location: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _partner = source._partner
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularStringField(value: &_storage._partner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._location)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._partner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._partner, fieldNumber: 2)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Request, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._partner != rhs_storage._partner {return false}
        if _storage._location != rhs_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardList.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardList.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.card)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.card.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.card, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Response, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Response) -> Bool {
    if lhs.card != rhs.card {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardList.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardList.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Request? = nil
    var _response: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Operation, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardList.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardRetrieve"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
  ]

  fileprivate class _StorageClass {
    var _card: Bloombox_Schema_Identity_Pass_PassKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _card = source._card
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._card)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Request, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._card != rhs_storage._card {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "record"),
    2: .same(proto: "fingerprint"),
  ]

  fileprivate class _StorageClass {
    var _record: Bloombox_Schema_Identity_Pass_Pass? = nil
    var _fingerprint: Opencannabis_Crypto_Primitives_Integrity_Hash? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _record = source._record
      _fingerprint = source._fingerprint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._record)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._record {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Response, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._record != rhs_storage._record {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Request? = nil
    var _response: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Operation, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardRetrieve.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardProvision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardProvision"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
    4: .same(proto: "identity"),
    5: .standard(proto: "public_key"),
  ]

  fileprivate class _StorageClass {
    var _user: Bloombox_Schema_Identity_UserKey? = nil
    var _context: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request.OneOf_Context?
    var _publicKey: Opencannabis_Crypto_Primitives_Pki_KeyMaterial? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _context = source._context
      _publicKey = source._publicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2:
          var v: Bloombox_Schema_Partner_PartnerKey?
          if let current = _storage._context {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._context = .partner(v)}
        case 3:
          var v: Bloombox_Schema_Partner_LocationKey?
          if let current = _storage._context {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._context = .location(v)}
        case 4:
          if _storage._context != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._context = .identity(v)}
        case 5: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._context {
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .identity(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case nil: break
      }
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
    2: .same(proto: "nonce"),
  ]

  fileprivate class _StorageClass {
    var _card: Bloombox_Schema_Identity_Pass_PassKey? = nil
    var _nonce: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _card = source._card
      _nonce = source._nonce
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._card)
        case 2: try decoder.decodeSingularStringField(value: &_storage._nonce)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Response, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._card != rhs_storage._card {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Request? = nil
    var _response: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Operation, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardProvision.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardIssuance"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "card"),
    3: .same(proto: "nonce"),
    4: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _user: Bloombox_Schema_Identity_UserKey? = nil
    var _card: Bloombox_Schema_Identity_Pass_PassKey? = nil
    var _nonce: String = String()
    var _signature: Opencannabis_Crypto_Signature? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _card = source._card
      _nonce = source._nonce
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._card)
        case 3: try decoder.decodeSingularStringField(value: &_storage._nonce)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._nonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nonce, fieldNumber: 3)
      }
      if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Request, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._card != rhs_storage._card {return false}
        if _storage._nonce != rhs_storage._nonce {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
  ]

  fileprivate class _StorageClass {
    var _card: Bloombox_Schema_Identity_Pass_Pass? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _card = source._card
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._card)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Response, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._card != rhs_storage._card {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Request? = nil
    var _response: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Response? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._response)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Operation, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardIssuance.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardVoid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardVoid"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
    2: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _card: Bloombox_Schema_Identity_Pass_PassKey? = nil
    var _signature: Opencannabis_Crypto_Signature? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _card = source._card
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._card)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Request, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._card != rhs_storage._card {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.protoMessageName + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "success"),
  ]

  fileprivate class _StorageClass {
    var _request: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Request? = nil
    var _success: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
      _success = source._success
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._success)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Operation, rhs: Bloombox_Schema_Services_Wallet_V1beta1_CardVoid.Operation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        if _storage._success != rhs_storage._success {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
