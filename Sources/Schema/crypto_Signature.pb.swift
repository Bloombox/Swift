// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: crypto/Signature.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies structures that carry or otherwise contain cryptographic signatures.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the concept of a cryptographic signature, including the raw signature bytes, a fingerprint of the data that
/// was signed, and information about the public key corresponding to the private key that performed the signing.
public struct Opencannabis_Crypto_Signature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key fingerprint, or raw content of the public key, that performed the signing operation.
  public var publicKey: Opencannabis_Crypto_KeyMaterial {
    get {return _storage._publicKey ?? Opencannabis_Crypto_KeyMaterial()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  /// Cryptographic fingerprint of the subject data that was signed. This is the actual value that should be signed by
  /// the private key and recomputed via the public key.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  /// Specifies the content of the digital signature being carried by this payload.
  public var signature: OneOf_Signature? {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// Raw bytes of the digital signature, performed over `fingerprint` by the private key corresponding to the
  /// `public_key` listed in this request.
  public var raw: Data {
    get {
      if case .raw(let v)? = _storage._signature {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._signature = .raw(newValue)}
  }

  /// Base-64 encoded raw bytes of the digital signature, performed over `fingerprint` by the private key corresponding
  /// to the `public_key` listed in this request.
  public var b64: String {
    get {
      if case .b64(let v)? = _storage._signature {return v}
      return String()
    }
    set {_uniqueStorage()._signature = .b64(newValue)}
  }

  /// Hex-encoded and uppercased raw bytes of the digital signature, performed over `fingerprint` by the private key
  /// corresponding to the `public_key` listed in the request.
  public var hex: String {
    get {
      if case .hex(let v)? = _storage._signature {return v}
      return String()
    }
    set {_uniqueStorage()._signature = .hex(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the content of the digital signature being carried by this payload.
  public enum OneOf_Signature: Equatable {
    /// Raw bytes of the digital signature, performed over `fingerprint` by the private key corresponding to the
    /// `public_key` listed in this request.
    case raw(Data)
    /// Base-64 encoded raw bytes of the digital signature, performed over `fingerprint` by the private key corresponding
    /// to the `public_key` listed in this request.
    case b64(String)
    /// Hex-encoded and uppercased raw bytes of the digital signature, performed over `fingerprint` by the private key
    /// corresponding to the `public_key` listed in the request.
    case hex(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Crypto_Signature.OneOf_Signature, rhs: Opencannabis_Crypto_Signature.OneOf_Signature) -> Bool {
      switch (lhs, rhs) {
      case (.raw(let l), .raw(let r)): return l == r
      case (.b64(let l), .b64(let r)): return l == r
      case (.hex(let l), .hex(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencannabis.crypto"

extension Opencannabis_Crypto_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Signature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .same(proto: "fingerprint"),
    5: .same(proto: "raw"),
    6: .same(proto: "b64"),
    7: .same(proto: "hex"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Opencannabis_Crypto_KeyMaterial? = nil
    var _fingerprint: Opencannabis_Crypto_Hash? = nil
    var _signature: Opencannabis_Crypto_Signature.OneOf_Signature?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _fingerprint = source._fingerprint
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._publicKey)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        case 5:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._signature = .raw(v)}
        case 6:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._signature = .b64(v)}
        case 7:
          if _storage._signature != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._signature = .hex(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._publicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._signature {
      case .raw(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      case .b64(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case .hex(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_Signature, rhs: Opencannabis_Crypto_Signature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
