// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: media/MediaType.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the type of media being attached or described.
public struct Opencannabis_Media_MediaType: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".MediaType"

  /// Specifies the generic kind of media being described or attached.
  public var kind: Opencannabis_Media_MediaType.Kind = .link

  /// Specifies the content type for the media item.
  public var content: Opencannabis_Media_MediaType.OneOf_Content? = nil

  /// Specifies content type for an image-based media item.
  public var imageType: Opencannabis_Media_MediaType.ImageKind {
    get {
      if case .imageType(let v)? = content {return v}
      return .unspecifiedImageType
    }
    set {content = .imageType(newValue)}
  }

  /// Specifies content type for a document-based media item.
  public var documentType: Opencannabis_Media_MediaType.DocumentKind {
    get {
      if case .documentType(let v)? = content {return v}
      return .unspecifiedDocumentType
    }
    set {content = .documentType(newValue)}
  }

  /// Specifies content type for a video-based media item.
  public var videoType: Opencannabis_Media_MediaType.VideoKind {
    get {
      if case .videoType(let v)? = content {return v}
      return .unspecifiedVideoType
    }
    set {content = .videoType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the content type for the media item.
  public enum OneOf_Content: Equatable {
    /// Specifies content type for an image-based media item.
    case imageType(Opencannabis_Media_MediaType.ImageKind)
    /// Specifies content type for a document-based media item.
    case documentType(Opencannabis_Media_MediaType.DocumentKind)
    /// Specifies content type for a video-based media item.
    case videoType(Opencannabis_Media_MediaType.VideoKind)

    public static func ==(lhs: Opencannabis_Media_MediaType.OneOf_Content, rhs: Opencannabis_Media_MediaType.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.imageType(let l), .imageType(let r)): return l == r
      case (.documentType(let l), .documentType(let r)): return l == r
      case (.videoType(let l), .videoType(let r)): return l == r
      default: return false
      }
    }
  }

  /// Enumerates, in generic terms, the kinds of media that can be attached or described.
  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Web link, or URI.
    case link // = 0

    /// Image or photograph.
    case image // = 1

    /// Document or text data.
    case document // = 2

    /// Video data.
    case video // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .link
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .link
      case 1: self = .image
      case 2: self = .document
      case 3: self = .video
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .link: return 0
      case .image: return 1
      case .document: return 2
      case .video: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies kinds of images that may be attached or described.
  public enum ImageKind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified image type.
    case unspecifiedImageType // = 0

    /// PNG image.
    case png // = 1

    /// JPG image.
    case jpg // = 2

    /// GIF image.
    case gif // = 3

    /// SVG image.
    case svg // = 4

    /// WEBP image.
    case webp // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecifiedImageType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedImageType
      case 1: self = .png
      case 2: self = .jpg
      case 3: self = .gif
      case 4: self = .svg
      case 5: self = .webp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecifiedImageType: return 0
      case .png: return 1
      case .jpg: return 2
      case .gif: return 3
      case .svg: return 4
      case .webp: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies the pixel density setting for an image.
  public enum ImageDPI: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The image has normal, 1:1 pixel density.
    case x1 // = 0

    /// The image has double pixel density.
    case x2 // = 1

    /// The image has triple pixel density.
    case x3 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .x1
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .x1
      case 1: self = .x2
      case 2: self = .x3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .x1: return 0
      case .x2: return 1
      case .x3: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies kinds of documents that may be attached or described.
  public enum DocumentKind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified document type.
    case unspecifiedDocumentType // = 0

    /// Plaintext format.
    case txt // = 1

    /// HTML format.
    case html // = 2

    /// PDF format.
    case pdf // = 3

    /// Markdown format.
    case markdown // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecifiedDocumentType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedDocumentType
      case 1: self = .txt
      case 2: self = .html
      case 3: self = .pdf
      case 4: self = .markdown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecifiedDocumentType: return 0
      case .txt: return 1
      case .html: return 2
      case .pdf: return 3
      case .markdown: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies kinds of videos that may be attached or described.
  public enum VideoKind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified video type.
    case unspecifiedVideoType // = 0

    /// MP4 video.
    case mp4 // = 1

    /// Flash video.
    case flv // = 2

    /// HTTP Live Streaming video.
    case hls // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecifiedVideoType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedVideoType
      case 1: self = .mp4
      case 2: self = .flv
      case 3: self = .hls
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecifiedVideoType: return 0
      case .mp4: return 1
      case .flv: return 2
      case .hls: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.kind)
      case 101:
        if self.content != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Media_MediaType.ImageKind?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.content = .imageType(v)}
      case 201:
        if self.content != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Media_MediaType.DocumentKind?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.content = .documentType(v)}
      case 301:
        if self.content != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Media_MediaType.VideoKind?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.content = .videoType(v)}
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .link {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    switch self.content {
    case .imageType(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 101)
    case .documentType(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 201)
    case .videoType(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 301)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencannabis.media"

extension Opencannabis_Media_MediaType: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    101: .standard(proto: "image_type"),
    201: .standard(proto: "document_type"),
    301: .standard(proto: "video_type"),
  ]

  public func _protobuf_generated_isEqualTo(other: Opencannabis_Media_MediaType) -> Bool {
    if self.kind != other.kind {return false}
    if self.content != other.content {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Media_MediaType.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK"),
    1: .same(proto: "IMAGE"),
    2: .same(proto: "DOCUMENT"),
    3: .same(proto: "VIDEO"),
  ]
}

extension Opencannabis_Media_MediaType.ImageKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_IMAGE_TYPE"),
    1: .same(proto: "PNG"),
    2: .same(proto: "JPG"),
    3: .same(proto: "GIF"),
    4: .same(proto: "SVG"),
    5: .same(proto: "WEBP"),
  ]
}

extension Opencannabis_Media_MediaType.ImageDPI: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "X1"),
    1: .same(proto: "X2"),
    2: .same(proto: "X3"),
  ]
}

extension Opencannabis_Media_MediaType.DocumentKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_DOCUMENT_TYPE"),
    1: .same(proto: "TXT"),
    2: .same(proto: "HTML"),
    3: .same(proto: "PDF"),
    4: .same(proto: "MARKDOWN"),
  ]
}

extension Opencannabis_Media_MediaType.VideoKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_VIDEO_TYPE"),
    1: .same(proto: "MP4"),
    2: .same(proto: "FLV"),
    3: .same(proto: "HLS"),
  ]
}
