// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: page/Page.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Models related to page structure and rendering flow.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies a given language, along with a nationality for that language.
public struct Bloombox_Page_LanguageSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Main language to specify as part of this language spec.
  public var language: Opencannabis_Base_Language = .unspecified

  /// Dialect to specify as part of this language spec.
  public var dialect: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines top-level web page context, to include metadata like the title and description, any media
/// that should be attached (like OpenGraph images, etc), for render via Soy.
public struct Bloombox_Page_Context {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata definitions for this web page render context.
  public var meta: Bloombox_Page_Context.Metadata {
    get {return _storage._meta ?? Bloombox_Page_Context.Metadata()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {_uniqueStorage()._meta = nil}

  /// CSS definitions and lifted code for the page head.
  public var styles: Bloombox_Page_Context.Styles {
    get {return _storage._styles ?? Bloombox_Page_Context.Styles()}
    set {_uniqueStorage()._styles = newValue}
  }
  /// Returns true if `styles` has been explicitly set.
  public var hasStyles: Bool {return _storage._styles != nil}
  /// Clears the value of `styles`. Subsequent reads from it will return its default value.
  public mutating func clearStyles() {_uniqueStorage()._styles = nil}

  /// Fonts to include/load on the page.
  public var fonts: Bloombox_Page_Context.Fonts {
    get {return _storage._fonts ?? Bloombox_Page_Context.Fonts()}
    set {_uniqueStorage()._fonts = newValue}
  }
  /// Returns true if `fonts` has been explicitly set.
  public var hasFonts: Bool {return _storage._fonts != nil}
  /// Clears the value of `fonts`. Subsequent reads from it will return its default value.
  public mutating func clearFonts() {_uniqueStorage()._fonts = nil}

  /// Scripts to include on the page or lift into the head.
  public var scripts: Bloombox_Page_Context.Scripts {
    get {return _storage._scripts ?? Bloombox_Page_Context.Scripts()}
    set {_uniqueStorage()._scripts = newValue}
  }
  /// Returns true if `scripts` has been explicitly set.
  public var hasScripts: Bool {return _storage._scripts != nil}
  /// Clears the value of `scripts`. Subsequent reads from it will return its default value.
  public mutating func clearScripts() {_uniqueStorage()._scripts = nil}

  /// Specifies configuration regarding telemetry data.
  public var telemetry: Bloombox_Page_Context.Telemetry {
    get {return _storage._telemetry ?? Bloombox_Page_Context.Telemetry()}
    set {_uniqueStorage()._telemetry = newValue}
  }
  /// Returns true if `telemetry` has been explicitly set.
  public var hasTelemetry: Bool {return _storage._telemetry != nil}
  /// Clears the value of `telemetry`. Subsequent reads from it will return its default value.
  public mutating func clearTelemetry() {_uniqueStorage()._telemetry = nil}

  /// Partnership scope for a given page render.
  public var scope: Bloombox_Page_Context.PartnerContext {
    get {return _storage._scope ?? Bloombox_Page_Context.PartnerContext()}
    set {_uniqueStorage()._scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  public var hasScope: Bool {return _storage._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  public mutating func clearScope() {_uniqueStorage()._scope = nil}

  /// Application manifest for a given page or web app.
  public var manifest: Bloombox_Page_Context.AppManifest {
    get {return _storage._manifest ?? Bloombox_Page_Context.AppManifest()}
    set {_uniqueStorage()._manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  public var hasManifest: Bool {return _storage._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  public mutating func clearManifest() {_uniqueStorage()._manifest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines the structure of well known page-level metadata, including the page title, description,
  /// keywords, and so on.
  public struct Metadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Defines the HTML title for the page, emitted in the <head>.
    public var title: String {
      get {return _storage._title}
      set {_uniqueStorage()._title = newValue}
    }

    /// Defines the meta description content for the page.
    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    /// Defines meta tag keywords, to be included in the page.
    public var keyword: [String] {
      get {return _storage._keyword}
      set {_uniqueStorage()._keyword = newValue}
    }

    /// Defines semantic content structure and binding content.
    public var semantic: Bloombox_Page_SemanticMetadata {
      get {return _storage._semantic ?? Bloombox_Page_SemanticMetadata()}
      set {_uniqueStorage()._semantic = newValue}
    }
    /// Returns true if `semantic` has been explicitly set.
    public var hasSemantic: Bool {return _storage._semantic != nil}
    /// Clears the value of `semantic`. Subsequent reads from it will return its default value.
    public mutating func clearSemantic() {_uniqueStorage()._semantic = nil}

    /// Defines the viewport settings that should be used by the rendered page.
    public var viewport: String {
      get {return _storage._viewport}
      set {_uniqueStorage()._viewport = newValue}
    }

    /// Defines a link to a web application manifest, if applicable.
    public var manifest: String {
      get {return _storage._manifest}
      set {_uniqueStorage()._manifest = newValue}
    }

    /// Defines a hex code to use as the primary theme color for the application.
    public var theme: String {
      get {return _storage._theme}
      set {_uniqueStorage()._theme = newValue}
    }

    /// Defines an icon to use in iOS circumstances, when used as an app shortcut.
    public var touchIcon: String {
      get {return _storage._touchIcon}
      set {_uniqueStorage()._touchIcon = newValue}
    }

    /// Defines an image to use in iOS circumstances, when launching as an app shorcut.
    public var startupImage: String {
      get {return _storage._startupImage}
      set {_uniqueStorage()._startupImage = newValue}
    }

    /// Defines a favicon image link to apply to the browser tab.
    public var favicon: String {
      get {return _storage._favicon}
      set {_uniqueStorage()._favicon = newValue}
    }

    /// Defines the language we are rendering the page for.
    public var language: Bloombox_Page_LanguageSpec {
      get {return _storage._language ?? Bloombox_Page_LanguageSpec()}
      set {_uniqueStorage()._language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return _storage._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {_uniqueStorage()._language = nil}

    /// Identifier for Google Tag Manager.
    public var gtmID: String {
      get {return _storage._gtmID}
      set {_uniqueStorage()._gtmID = newValue}
    }

    /// Facebook application identifier.
    public var fbAppID: String {
      get {return _storage._fbAppID}
      set {_uniqueStorage()._fbAppID = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Tags for the Facebook Crawler.
    public struct OpenGraph {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Name of the website.
      public var siteName: String {
        get {return _storage._siteName}
        set {_uniqueStorage()._siteName = newValue}
      }

      /// Title of the page.
      public var title: String {
        get {return _storage._title}
        set {_uniqueStorage()._title = newValue}
      }

      /// Description of the page.
      public var description_p: String {
        get {return _storage._description_p}
        set {_uniqueStorage()._description_p = newValue}
      }

      /// The language the page is written in.
      public var locale: Bloombox_Page_LanguageSpec {
        get {return _storage._locale ?? Bloombox_Page_LanguageSpec()}
        set {_uniqueStorage()._locale = newValue}
      }
      /// Returns true if `locale` has been explicitly set.
      public var hasLocale: Bool {return _storage._locale != nil}
      /// Clears the value of `locale`. Subsequent reads from it will return its default value.
      public mutating func clearLocale() {_uniqueStorage()._locale = nil}

      /// The type of page - i.e. article, website, video.
      public var type: String {
        get {return _storage._type}
        set {_uniqueStorage()._type = newValue}
      }

      /// Thumbnail to display when page is shared.
      public var image: String {
        get {return _storage._image}
        set {_uniqueStorage()._image = newValue}
      }

      /// Directs facebook to scrape another url instead of the url the page was served from.
      public var url: String {
        get {return _storage._url}
        set {_uniqueStorage()._url = newValue}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies details about an application manifest, which should be or is linked to a given web
  /// page, that is being rendered by the render engine.
  public struct AppManifest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Full name for this application.
    public var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    /// Short name for this application.
    public var shortName: String {
      get {return _storage._shortName}
      set {_uniqueStorage()._shortName = newValue}
    }

    /// Starting URL where this application can be entered.
    public var startURL: String {
      get {return _storage._startURL}
      set {_uniqueStorage()._startURL = newValue}
    }

    /// Defines the developers' preferred display mode for this application.
    public var display: Bloombox_Page_Context.AppManifest.DisplayMode {
      get {return _storage._display}
      set {_uniqueStorage()._display = newValue}
    }

    /// Defines the expected application background color.
    public var backgroundColor: String {
      get {return _storage._backgroundColor}
      set {_uniqueStorage()._backgroundColor = newValue}
    }

    /// Specifies a narrative description about this application.
    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    /// Specifies the language direction - RTL or LTR, for this application.
    public var direction: String {
      get {return _storage._direction}
      set {_uniqueStorage()._direction = newValue}
    }

    /// Specifies the language this application is being served in.
    public var language: Bloombox_Page_LanguageSpec {
      get {return _storage._language ?? Bloombox_Page_LanguageSpec()}
      set {_uniqueStorage()._language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return _storage._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {_uniqueStorage()._language = nil}

    /// Specifies expected screen orientation for this application.
    public var orientation: Bloombox_Page_Context.AppManifest.OrientationMode {
      get {return _storage._orientation}
      set {_uniqueStorage()._orientation = newValue}
    }

    /// Defines the navigation scope for this web application's context.
    public var scope: String {
      get {return _storage._scope}
      set {_uniqueStorage()._scope = newValue}
    }

    /// Flag indicating whether we want to prefer native apps for the user's experience.
    public var preferRelatedApplications: Bool {
      get {return _storage._preferRelatedApplications}
      set {_uniqueStorage()._preferRelatedApplications = newValue}
    }

    /// Related native applications that should be considered along with this web application.
    public var relatedApplication: [Bloombox_Page_Context.AppManifest.RelatedApplication] {
      get {return _storage._relatedApplication}
      set {_uniqueStorage()._relatedApplication = newValue}
    }

    /// Application icons listed with this manifest.
    public var appIcon: [Bloombox_Page_Context.AppManifest.Icon] {
      get {return _storage._appIcon}
      set {_uniqueStorage()._appIcon = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Enumerates display modes which are available for selection in the web application manifest
    /// spec. Each display mode is described herein.
    public enum DisplayMode: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Regular browser UI. Default value if left unspecified.
      case browser // = 0

      /// All of the available display area is used and no user agent chrome is shown.
      case fullscreen // = 1

      /// The application will look and feel like a standalone application. This can include the application
      /// having a different window, its own icon in the application launcher, etc. In this mode, the user
      /// agent will exclude UI elements for controlling navigation, but can include other UI elements such
      /// as a status bar.
      case standalone // = 2

      /// The application will look and feel like a standalone application, but will have a minimal set of UI
      /// elements for controlling navigation. The elements will vary by browser.
      case minimalUi // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .browser
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .browser
        case 1: self = .fullscreen
        case 2: self = .standalone
        case 3: self = .minimalUi
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .browser: return 0
        case .fullscreen: return 1
        case .standalone: return 2
        case .minimalUi: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Describes available orientation modes, for specifying the default orientation mode for an application
    /// within a web app manifest.
    public enum OrientationMode: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified, or default, orientation mode/settings.
      case unspecifiedOrientation // = 0

      /// Any orientation mode is supported.
      case any // = 1

      /// Use the natural orientation mode for the device.
      case natural // = 2

      /// Use landscape mode by default.
      case landscape // = 3

      /// Use portrait mode by default.
      case portrait // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecifiedOrientation
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecifiedOrientation
        case 1: self = .any
        case 2: self = .natural
        case 3: self = .landscape
        case 4: self = .portrait
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecifiedOrientation: return 0
        case .any: return 1
        case .natural: return 2
        case .landscape: return 3
        case .portrait: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Specifies the structure of an icon graphic linked to this web page via an application manifest.
    /// Icons can be specified in multiple formats and sizes.
    public struct Icon {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Specifies the URI for a given icon.
      public var src: String = String()

      /// Specifies the sizes that a given icon is available in.
      public var size: [UInt32] = []

      /// Specifies the content type of a given icon.
      public var type: Opencannabis_Media_MediaType.ImageKind = .unspecifiedImageType

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Specifies details about a related application, which should be considered canonically the same
    /// as this application, but for a different platform.
    public struct RelatedApplication {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// ID for this alternative application option.
      public var id: String = String()

      /// Platform that the related app is listed on.
      public var platform: Bloombox_Page_Context.AppManifest.RelatedApplication.AppPlatform = .unspecifiedAppPlatform

      /// URI where the alternative application can be downloaded.
      public var uri: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Enumerates known platforms where related applications might reside.
      public enum AppPlatform: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Unspecified application platform.
        case unspecifiedAppPlatform // = 0

        /// Apple App Store.
        case appstore // = 1

        /// Google Play Store.
        case playstore // = 2

        /// Additional web application.
        case web // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecifiedAppPlatform
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecifiedAppPlatform
          case 1: self = .appstore
          case 2: self = .playstore
          case 3: self = .web
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecifiedAppPlatform: return 0
          case .appstore: return 1
          case .playstore: return 2
          case .web: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Defines page-level style settings (CSS), including external stylesheets, lifted CSS that should
  /// be rendered in the <head>, and more.
  public struct Styles {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// CSS code that should be emitted early in the <head>.
    public var lifted: String = String()

    /// External CSS code to be included in <link> tags.
    public var link: [Bloombox_Page_Context.Styles.Stylesheet] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies known stylesheets, which provide framework or other shared utilities.
    public enum KnownStylesheet: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Initialization stylesheet, applied internally to all pages.
      case `internal` // = 0

      /// Material Web stylesheet assets.
      case material // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .internal
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .internal
        case 1: self = .material
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .internal: return 0
        case .material: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Defines the notion of an external stylesheet document, written in CSS, which should be included
    /// via reference rather than inline.
    public struct Stylesheet {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var ref: OneOf_Ref? {
        get {return _storage._ref}
        set {_uniqueStorage()._ref = newValue}
      }

      /// Standard OpenCannabis media reference to attach via stylesheet reference.
      public var reference: Opencannabis_Media_MediaReference {
        get {
          if case .reference(let v)? = _storage._ref {return v}
          return Opencannabis_Media_MediaReference()
        }
        set {_uniqueStorage()._ref = .reference(newValue)}
      }

      /// URI to a given stylesheet asset.
      public var uri: String {
        get {
          if case .uri(let v)? = _storage._ref {return v}
          return String()
        }
        set {_uniqueStorage()._ref = .uri(newValue)}
      }

      /// Known, or structured, stylesheet reference.
      public var known: Bloombox_Page_Context.Styles.KnownStylesheet {
        get {
          if case .known(let v)? = _storage._ref {return v}
          return .internal
        }
        set {_uniqueStorage()._ref = .known(newValue)}
      }

      /// Media setting to apply to the style sheet.
      public var media: String {
        get {
          if case .media(let v)? = _storage._ref {return v}
          return String()
        }
        set {_uniqueStorage()._ref = .media(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Ref: Equatable {
        /// Standard OpenCannabis media reference to attach via stylesheet reference.
        case reference(Opencannabis_Media_MediaReference)
        /// URI to a given stylesheet asset.
        case uri(String)
        /// Known, or structured, stylesheet reference.
        case known(Bloombox_Page_Context.Styles.KnownStylesheet)
        /// Media setting to apply to the style sheet.
        case media(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Bloombox_Page_Context.Styles.Stylesheet.OneOf_Ref, rhs: Bloombox_Page_Context.Styles.Stylesheet.OneOf_Ref) -> Bool {
          switch (lhs, rhs) {
          case (.reference(let l), .reference(let r)): return l == r
          case (.uri(let l), .uri(let r)): return l == r
          case (.known(let l), .known(let r)): return l == r
          case (.media(let l), .media(let r)): return l == r
          default: return false
          }
        }
      #endif
      }

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}
  }

  /// Specifies information about sets of fonts to include in the page via CSS declarations, or imports/link
  /// references. Fonts are considered part of the stylesheet set of a page.
  public struct Fonts {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies packages of fonts included for reference.
    public var package: [Bloombox_Page_Context.Fonts.FontPackage] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies types of references to font assets that are understood by the rendering system.
    public enum FontReferenceType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Specifies an internal font, or an explicit set of font assets.
      case `internal` // = 0

      /// Specifies a font hosted on Google Fonts.
      case googleFonts // = 1

      /// Specifies a font hosted on Hoefler Cloud.Typography.
      case hoefler // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .internal
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .internal
        case 1: self = .googleFonts
        case 2: self = .hoefler
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .internal: return 0
        case .googleFonts: return 1
        case .hoefler: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Specifies types of font formats supported for serving by the system.
    public enum FontFormat: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified font format.
      case unspecifiedFormat // = 0

      /// OpenType Format (OTF).
      case opentype // = 1

      /// TrueType Format (TTF).
      case truetype // = 2

      /// Scalable Vector Graphics (SVG).
      case vector // = 3

      /// Web Open Font Format (WOFF).
      case webfont // = 4

      /// Web Open Font Format 2 (WOFF2).
      case webfont2 // = 5

      /// Embedded OpenType (EOT).
      case embeddedOpentype // = 6
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecifiedFormat
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecifiedFormat
        case 1: self = .opentype
        case 2: self = .truetype
        case 3: self = .vector
        case 4: self = .webfont
        case 5: self = .webfont2
        case 6: self = .embeddedOpentype
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecifiedFormat: return 0
        case .opentype: return 1
        case .truetype: return 2
        case .vector: return 3
        case .webfont: return 4
        case .webfont2: return 5
        case .embeddedOpentype: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Specifies information about an individual reference to a font file.
    public struct FontReference {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Specifies the type of reference being made.
      public var type: Bloombox_Page_Context.Fonts.FontReferenceType {
        get {return _storage._type}
        set {_uniqueStorage()._type = newValue}
      }

      /// Speecifies the format of the font reference being made.
      public var format: Bloombox_Page_Context.Fonts.FontFormat {
        get {return _storage._format}
        set {_uniqueStorage()._format = newValue}
      }

      /// Name of the font reference.
      public var name: String {
        get {return _storage._name}
        set {_uniqueStorage()._name = newValue}
      }

      /// Weight of the font reference.
      public var weight: String {
        get {return _storage._weight}
        set {_uniqueStorage()._weight = newValue}
      }

      /// Variant of the font reference.
      public var variant: String {
        get {return _storage._variant}
        set {_uniqueStorage()._variant = newValue}
      }

      public var ref: OneOf_Ref? {
        get {return _storage._ref}
        set {_uniqueStorage()._ref = newValue}
      }

      /// Standard OpenCannabis media reference to attach via font reference.
      public var media: Opencannabis_Media_MediaReference {
        get {
          if case .media(let v)? = _storage._ref {return v}
          return Opencannabis_Media_MediaReference()
        }
        set {_uniqueStorage()._ref = .media(newValue)}
      }

      /// URI reference to this font asset.
      public var uri: String {
        get {
          if case .uri(let v)? = _storage._ref {return v}
          return String()
        }
        set {_uniqueStorage()._ref = .uri(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Ref: Equatable {
        /// Standard OpenCannabis media reference to attach via font reference.
        case media(Opencannabis_Media_MediaReference)
        /// URI reference to this font asset.
        case uri(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Bloombox_Page_Context.Fonts.FontReference.OneOf_Ref, rhs: Bloombox_Page_Context.Fonts.FontReference.OneOf_Ref) -> Bool {
          switch (lhs, rhs) {
          case (.media(let l), .media(let r)): return l == r
          case (.uri(let l), .uri(let r)): return l == r
          default: return false
          }
        }
      #endif
      }

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// Specifies a package of fonts included for reference in a given web page.
    public struct FontPackage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Specifies the CSS name used for this font package/family.
      public var name: String = String()

      /// References to individual constituent font assets.
      public var reference: [Bloombox_Page_Context.Fonts.FontReference] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Specifies information about JavaScript code that should be included with a given page render. Scripts
  /// included in this manner may be emitted inline or by reference (URI).
  public struct Scripts {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// JavaScript code that should be emitted early in the <head>.
    public var lifted: String = String()

    /// External JavaScript code to be included in <link> tags.
    public var link: [Bloombox_Page_Context.Scripts.JavaScript] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies known scripts, which provide framework or other shared utilities.
    public enum KnownScript: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Initialization script, applied internally to all pages.
      case `internal` // = 0

      /// Bloombox SDK for JavaScript.
      case jsSdk // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .internal
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .internal
        case 1: self = .jsSdk
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .internal: return 0
        case .jsSdk: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Defines the notion of an external script document, written in JavaScript, which should be included
    /// via reference rather than inline.
    public struct JavaScript {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var ref: OneOf_Ref? {
        get {return _storage._ref}
        set {_uniqueStorage()._ref = newValue}
      }

      /// Standard OpenCannabis media reference to attach via script reference.
      public var media: Opencannabis_Media_MediaReference {
        get {
          if case .media(let v)? = _storage._ref {return v}
          return Opencannabis_Media_MediaReference()
        }
        set {_uniqueStorage()._ref = .media(newValue)}
      }

      /// URI to a given script asset.
      public var uri: String {
        get {
          if case .uri(let v)? = _storage._ref {return v}
          return String()
        }
        set {_uniqueStorage()._ref = .uri(newValue)}
      }

      /// Known, or structured, script reference.
      public var known: Bloombox_Page_Context.Scripts.KnownScript {
        get {
          if case .known(let v)? = _storage._ref {return v}
          return .internal
        }
        set {_uniqueStorage()._ref = .known(newValue)}
      }

      /// Whether to add the `module` flag to a script.
      public var module: Bool {
        get {return _storage._module}
        set {_uniqueStorage()._module = newValue}
      }

      /// Whether to add the `defer` flag to a script.
      public var `defer`: Bool {
        get {return _storage._defer}
        set {_uniqueStorage()._defer = newValue}
      }

      /// Whether to add the `async` flag to a script.
      public var async: Bool {
        get {return _storage._async}
        set {_uniqueStorage()._async = newValue}
      }

      /// ID at which to attach the script tag.
      public var id: String {
        get {return _storage._id}
        set {_uniqueStorage()._id = newValue}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Ref: Equatable {
        /// Standard OpenCannabis media reference to attach via script reference.
        case media(Opencannabis_Media_MediaReference)
        /// URI to a given script asset.
        case uri(String)
        /// Known, or structured, script reference.
        case known(Bloombox_Page_Context.Scripts.KnownScript)

      #if !swift(>=4.1)
        public static func ==(lhs: Bloombox_Page_Context.Scripts.JavaScript.OneOf_Ref, rhs: Bloombox_Page_Context.Scripts.JavaScript.OneOf_Ref) -> Bool {
          switch (lhs, rhs) {
          case (.media(let l), .media(let r)): return l == r
          case (.uri(let l), .uri(let r)): return l == r
          case (.known(let l), .known(let r)): return l == r
          default: return false
          }
        }
      #endif
      }

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}
  }

  /// Defines the notion of partnership context, with regard to a given web page rendering routine.
  public struct PartnerContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Scope definition for partnership context.
    public var scope: OneOf_Scope? {
      get {return _storage._scope}
      set {_uniqueStorage()._scope = newValue}
    }

    /// The scope is internal and has no partnership context.
    public var `internal`: Bool {
      get {
        if case .internal(let v)? = _storage._scope {return v}
        return false
      }
      set {_uniqueStorage()._scope = .internal(newValue)}
    }

    /// Partner-level render context scope.
    public var partner: Bloombox_Partner_PartnerKey {
      get {
        if case .partner(let v)? = _storage._scope {return v}
        return Bloombox_Partner_PartnerKey()
      }
      set {_uniqueStorage()._scope = .partner(newValue)}
    }

    /// Location-level render context scope.
    public var location: Bloombox_Partner_LocationKey {
      get {
        if case .location(let v)? = _storage._scope {return v}
        return Bloombox_Partner_LocationKey()
      }
      set {_uniqueStorage()._scope = .location(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Scope definition for partnership context.
    public enum OneOf_Scope: Equatable {
      /// The scope is internal and has no partnership context.
      case `internal`(Bool)
      /// Partner-level render context scope.
      case partner(Bloombox_Partner_PartnerKey)
      /// Location-level render context scope.
      case location(Bloombox_Partner_LocationKey)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Page_Context.PartnerContext.OneOf_Scope, rhs: Bloombox_Page_Context.PartnerContext.OneOf_Scope) -> Bool {
        switch (lhs, rhs) {
        case (.internal(let l), .internal(let r)): return l == r
        case (.partner(let l), .partner(let r)): return l == r
        case (.location(let l), .location(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies configuration for telemetry logic.
  public struct Telemetry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the Google Tag Manager site ID for a given web page.
    public var tagManagerID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.page"

extension Bloombox_Page_LanguageSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LanguageSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
    2: .same(proto: "dialect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.language)
      case 2: try decoder.decodeSingularStringField(value: &self.dialect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.language != .unspecified {
      try visitor.visitSingularEnumField(value: self.language, fieldNumber: 1)
    }
    if !self.dialect.isEmpty {
      try visitor.visitSingularStringField(value: self.dialect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_LanguageSpec, rhs: Bloombox_Page_LanguageSpec) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.dialect != rhs.dialect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Context"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "meta"),
    2: .same(proto: "styles"),
    3: .same(proto: "fonts"),
    4: .same(proto: "scripts"),
    5: .same(proto: "telemetry"),
    6: .same(proto: "scope"),
    7: .same(proto: "manifest"),
  ]

  fileprivate class _StorageClass {
    var _meta: Bloombox_Page_Context.Metadata? = nil
    var _styles: Bloombox_Page_Context.Styles? = nil
    var _fonts: Bloombox_Page_Context.Fonts? = nil
    var _scripts: Bloombox_Page_Context.Scripts? = nil
    var _telemetry: Bloombox_Page_Context.Telemetry? = nil
    var _scope: Bloombox_Page_Context.PartnerContext? = nil
    var _manifest: Bloombox_Page_Context.AppManifest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _meta = source._meta
      _styles = source._styles
      _fonts = source._fonts
      _scripts = source._scripts
      _telemetry = source._telemetry
      _scope = source._scope
      _manifest = source._manifest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._meta)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._styles)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._fonts)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._scripts)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._telemetry)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._scope)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._manifest)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._styles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fonts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._scripts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._telemetry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._scope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._manifest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context, rhs: Bloombox_Page_Context) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._styles != rhs_storage._styles {return false}
        if _storage._fonts != rhs_storage._fonts {return false}
        if _storage._scripts != rhs_storage._scripts {return false}
        if _storage._telemetry != rhs_storage._telemetry {return false}
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._manifest != rhs_storage._manifest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "keyword"),
    4: .same(proto: "semantic"),
    5: .same(proto: "viewport"),
    6: .same(proto: "manifest"),
    7: .same(proto: "theme"),
    8: .standard(proto: "touch_icon"),
    9: .standard(proto: "startup_image"),
    10: .same(proto: "favicon"),
    11: .same(proto: "language"),
    12: .standard(proto: "gtm_id"),
    13: .standard(proto: "fb_app_id"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _description_p: String = String()
    var _keyword: [String] = []
    var _semantic: Bloombox_Page_SemanticMetadata? = nil
    var _viewport: String = String()
    var _manifest: String = String()
    var _theme: String = String()
    var _touchIcon: String = String()
    var _startupImage: String = String()
    var _favicon: String = String()
    var _language: Bloombox_Page_LanguageSpec? = nil
    var _gtmID: String = String()
    var _fbAppID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _description_p = source._description_p
      _keyword = source._keyword
      _semantic = source._semantic
      _viewport = source._viewport
      _manifest = source._manifest
      _theme = source._theme
      _touchIcon = source._touchIcon
      _startupImage = source._startupImage
      _favicon = source._favicon
      _language = source._language
      _gtmID = source._gtmID
      _fbAppID = source._fbAppID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._title)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._keyword)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._semantic)
        case 5: try decoder.decodeSingularStringField(value: &_storage._viewport)
        case 6: try decoder.decodeSingularStringField(value: &_storage._manifest)
        case 7: try decoder.decodeSingularStringField(value: &_storage._theme)
        case 8: try decoder.decodeSingularStringField(value: &_storage._touchIcon)
        case 9: try decoder.decodeSingularStringField(value: &_storage._startupImage)
        case 10: try decoder.decodeSingularStringField(value: &_storage._favicon)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._language)
        case 12: try decoder.decodeSingularStringField(value: &_storage._gtmID)
        case 13: try decoder.decodeSingularStringField(value: &_storage._fbAppID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._keyword.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._keyword, fieldNumber: 3)
      }
      if let v = _storage._semantic {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._viewport.isEmpty {
        try visitor.visitSingularStringField(value: _storage._viewport, fieldNumber: 5)
      }
      if !_storage._manifest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._manifest, fieldNumber: 6)
      }
      if !_storage._theme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._theme, fieldNumber: 7)
      }
      if !_storage._touchIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._touchIcon, fieldNumber: 8)
      }
      if !_storage._startupImage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._startupImage, fieldNumber: 9)
      }
      if !_storage._favicon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._favicon, fieldNumber: 10)
      }
      if let v = _storage._language {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._gtmID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gtmID, fieldNumber: 12)
      }
      if !_storage._fbAppID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fbAppID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Metadata, rhs: Bloombox_Page_Context.Metadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._keyword != rhs_storage._keyword {return false}
        if _storage._semantic != rhs_storage._semantic {return false}
        if _storage._viewport != rhs_storage._viewport {return false}
        if _storage._manifest != rhs_storage._manifest {return false}
        if _storage._theme != rhs_storage._theme {return false}
        if _storage._touchIcon != rhs_storage._touchIcon {return false}
        if _storage._startupImage != rhs_storage._startupImage {return false}
        if _storage._favicon != rhs_storage._favicon {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._gtmID != rhs_storage._gtmID {return false}
        if _storage._fbAppID != rhs_storage._fbAppID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Metadata.OpenGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.Metadata.protoMessageName + ".OpenGraph"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "site_name"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "locale"),
    5: .same(proto: "type"),
    6: .same(proto: "image"),
    7: .same(proto: "url"),
  ]

  fileprivate class _StorageClass {
    var _siteName: String = String()
    var _title: String = String()
    var _description_p: String = String()
    var _locale: Bloombox_Page_LanguageSpec? = nil
    var _type: String = String()
    var _image: String = String()
    var _url: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _siteName = source._siteName
      _title = source._title
      _description_p = source._description_p
      _locale = source._locale
      _type = source._type
      _image = source._image
      _url = source._url
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._siteName)
        case 2: try decoder.decodeSingularStringField(value: &_storage._title)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._locale)
        case 5: try decoder.decodeSingularStringField(value: &_storage._type)
        case 6: try decoder.decodeSingularStringField(value: &_storage._image)
        case 7: try decoder.decodeSingularStringField(value: &_storage._url)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._siteName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._siteName, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if let v = _storage._locale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 5)
      }
      if !_storage._image.isEmpty {
        try visitor.visitSingularStringField(value: _storage._image, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Metadata.OpenGraph, rhs: Bloombox_Page_Context.Metadata.OpenGraph) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._siteName != rhs_storage._siteName {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._url != rhs_storage._url {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.AppManifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".AppManifest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "short_name"),
    3: .standard(proto: "start_url"),
    4: .same(proto: "display"),
    5: .standard(proto: "background_color"),
    6: .same(proto: "description"),
    7: .same(proto: "direction"),
    8: .same(proto: "language"),
    9: .same(proto: "orientation"),
    11: .same(proto: "scope"),
    12: .standard(proto: "prefer_related_applications"),
    13: .standard(proto: "related_application"),
    14: .standard(proto: "app_icon"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _shortName: String = String()
    var _startURL: String = String()
    var _display: Bloombox_Page_Context.AppManifest.DisplayMode = .browser
    var _backgroundColor: String = String()
    var _description_p: String = String()
    var _direction: String = String()
    var _language: Bloombox_Page_LanguageSpec? = nil
    var _orientation: Bloombox_Page_Context.AppManifest.OrientationMode = .unspecifiedOrientation
    var _scope: String = String()
    var _preferRelatedApplications: Bool = false
    var _relatedApplication: [Bloombox_Page_Context.AppManifest.RelatedApplication] = []
    var _appIcon: [Bloombox_Page_Context.AppManifest.Icon] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _shortName = source._shortName
      _startURL = source._startURL
      _display = source._display
      _backgroundColor = source._backgroundColor
      _description_p = source._description_p
      _direction = source._direction
      _language = source._language
      _orientation = source._orientation
      _scope = source._scope
      _preferRelatedApplications = source._preferRelatedApplications
      _relatedApplication = source._relatedApplication
      _appIcon = source._appIcon
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._shortName)
        case 3: try decoder.decodeSingularStringField(value: &_storage._startURL)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._display)
        case 5: try decoder.decodeSingularStringField(value: &_storage._backgroundColor)
        case 6: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 7: try decoder.decodeSingularStringField(value: &_storage._direction)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._language)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._orientation)
        case 11: try decoder.decodeSingularStringField(value: &_storage._scope)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._preferRelatedApplications)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._relatedApplication)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._appIcon)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._shortName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shortName, fieldNumber: 2)
      }
      if !_storage._startURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._startURL, fieldNumber: 3)
      }
      if _storage._display != .browser {
        try visitor.visitSingularEnumField(value: _storage._display, fieldNumber: 4)
      }
      if !_storage._backgroundColor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backgroundColor, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if !_storage._direction.isEmpty {
        try visitor.visitSingularStringField(value: _storage._direction, fieldNumber: 7)
      }
      if let v = _storage._language {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._orientation != .unspecifiedOrientation {
        try visitor.visitSingularEnumField(value: _storage._orientation, fieldNumber: 9)
      }
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 11)
      }
      if _storage._preferRelatedApplications != false {
        try visitor.visitSingularBoolField(value: _storage._preferRelatedApplications, fieldNumber: 12)
      }
      if !_storage._relatedApplication.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._relatedApplication, fieldNumber: 13)
      }
      if !_storage._appIcon.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._appIcon, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.AppManifest, rhs: Bloombox_Page_Context.AppManifest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._shortName != rhs_storage._shortName {return false}
        if _storage._startURL != rhs_storage._startURL {return false}
        if _storage._display != rhs_storage._display {return false}
        if _storage._backgroundColor != rhs_storage._backgroundColor {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._direction != rhs_storage._direction {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._orientation != rhs_storage._orientation {return false}
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._preferRelatedApplications != rhs_storage._preferRelatedApplications {return false}
        if _storage._relatedApplication != rhs_storage._relatedApplication {return false}
        if _storage._appIcon != rhs_storage._appIcon {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.AppManifest.DisplayMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BROWSER"),
    1: .same(proto: "FULLSCREEN"),
    2: .same(proto: "STANDALONE"),
    3: .same(proto: "MINIMAL_UI"),
  ]
}

extension Bloombox_Page_Context.AppManifest.OrientationMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_ORIENTATION"),
    1: .same(proto: "ANY"),
    2: .same(proto: "NATURAL"),
    3: .same(proto: "LANDSCAPE"),
    4: .same(proto: "PORTRAIT"),
  ]
}

extension Bloombox_Page_Context.AppManifest.Icon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.AppManifest.protoMessageName + ".Icon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "src"),
    2: .same(proto: "size"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.src)
      case 2: try decoder.decodeRepeatedUInt32Field(value: &self.size)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.src.isEmpty {
      try visitor.visitSingularStringField(value: self.src, fieldNumber: 1)
    }
    if !self.size.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.type != .unspecifiedImageType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.AppManifest.Icon, rhs: Bloombox_Page_Context.AppManifest.Icon) -> Bool {
    if lhs.src != rhs.src {return false}
    if lhs.size != rhs.size {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.AppManifest.RelatedApplication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.AppManifest.protoMessageName + ".RelatedApplication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "platform"),
    3: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.platform)
      case 3: try decoder.decodeSingularStringField(value: &self.uri)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.platform != .unspecifiedAppPlatform {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 2)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.AppManifest.RelatedApplication, rhs: Bloombox_Page_Context.AppManifest.RelatedApplication) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.AppManifest.RelatedApplication.AppPlatform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_APP_PLATFORM"),
    1: .same(proto: "APPSTORE"),
    2: .same(proto: "PLAYSTORE"),
    3: .same(proto: "WEB"),
  ]
}

extension Bloombox_Page_Context.Styles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".Styles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lifted"),
    2: .same(proto: "link"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lifted)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.link)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lifted.isEmpty {
      try visitor.visitSingularStringField(value: self.lifted, fieldNumber: 1)
    }
    if !self.link.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.link, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Styles, rhs: Bloombox_Page_Context.Styles) -> Bool {
    if lhs.lifted != rhs.lifted {return false}
    if lhs.link != rhs.link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Styles.KnownStylesheet: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERNAL"),
    1: .same(proto: "MATERIAL"),
  ]
}

extension Bloombox_Page_Context.Styles.Stylesheet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.Styles.protoMessageName + ".Stylesheet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reference"),
    2: .same(proto: "uri"),
    3: .same(proto: "known"),
    4: .same(proto: "media"),
  ]

  fileprivate class _StorageClass {
    var _ref: Bloombox_Page_Context.Styles.Stylesheet.OneOf_Ref?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ref = source._ref
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Opencannabis_Media_MediaReference?
          if let current = _storage._ref {
            try decoder.handleConflictingOneOf()
            if case .reference(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._ref = .reference(v)}
        case 2:
          if _storage._ref != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._ref = .uri(v)}
        case 3:
          if _storage._ref != nil {try decoder.handleConflictingOneOf()}
          var v: Bloombox_Page_Context.Styles.KnownStylesheet?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._ref = .known(v)}
        case 4:
          if _storage._ref != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._ref = .media(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._ref {
      case .reference(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .known(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      case .media(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Styles.Stylesheet, rhs: Bloombox_Page_Context.Styles.Stylesheet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ref != rhs_storage._ref {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Fonts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".Fonts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.package)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.package.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.package, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Fonts, rhs: Bloombox_Page_Context.Fonts) -> Bool {
    if lhs.package != rhs.package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Fonts.FontReferenceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERNAL"),
    1: .same(proto: "GOOGLE_FONTS"),
    2: .same(proto: "HOEFLER"),
  ]
}

extension Bloombox_Page_Context.Fonts.FontFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_FORMAT"),
    1: .same(proto: "OPENTYPE"),
    2: .same(proto: "TRUETYPE"),
    3: .same(proto: "VECTOR"),
    4: .same(proto: "WEBFONT"),
    5: .same(proto: "WEBFONT2"),
    6: .same(proto: "EMBEDDED_OPENTYPE"),
  ]
}

extension Bloombox_Page_Context.Fonts.FontReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.Fonts.protoMessageName + ".FontReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "format"),
    3: .same(proto: "name"),
    4: .same(proto: "weight"),
    5: .same(proto: "variant"),
    6: .same(proto: "media"),
    7: .same(proto: "uri"),
  ]

  fileprivate class _StorageClass {
    var _type: Bloombox_Page_Context.Fonts.FontReferenceType = .internal
    var _format: Bloombox_Page_Context.Fonts.FontFormat = .unspecifiedFormat
    var _name: String = String()
    var _weight: String = String()
    var _variant: String = String()
    var _ref: Bloombox_Page_Context.Fonts.FontReference.OneOf_Ref?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _format = source._format
      _name = source._name
      _weight = source._weight
      _variant = source._variant
      _ref = source._ref
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._format)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularStringField(value: &_storage._weight)
        case 5: try decoder.decodeSingularStringField(value: &_storage._variant)
        case 6:
          var v: Opencannabis_Media_MediaReference?
          if let current = _storage._ref {
            try decoder.handleConflictingOneOf()
            if case .media(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._ref = .media(v)}
        case 7:
          if _storage._ref != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._ref = .uri(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .internal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._format != .unspecifiedFormat {
        try visitor.visitSingularEnumField(value: _storage._format, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._weight.isEmpty {
        try visitor.visitSingularStringField(value: _storage._weight, fieldNumber: 4)
      }
      if !_storage._variant.isEmpty {
        try visitor.visitSingularStringField(value: _storage._variant, fieldNumber: 5)
      }
      switch _storage._ref {
      case .media(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Fonts.FontReference, rhs: Bloombox_Page_Context.Fonts.FontReference) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._format != rhs_storage._format {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._weight != rhs_storage._weight {return false}
        if _storage._variant != rhs_storage._variant {return false}
        if _storage._ref != rhs_storage._ref {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Fonts.FontPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.Fonts.protoMessageName + ".FontPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.reference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.reference.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reference, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Fonts.FontPackage, rhs: Bloombox_Page_Context.Fonts.FontPackage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Scripts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".Scripts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lifted"),
    2: .same(proto: "link"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lifted)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.link)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lifted.isEmpty {
      try visitor.visitSingularStringField(value: self.lifted, fieldNumber: 1)
    }
    if !self.link.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.link, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Scripts, rhs: Bloombox_Page_Context.Scripts) -> Bool {
    if lhs.lifted != rhs.lifted {return false}
    if lhs.link != rhs.link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Scripts.KnownScript: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERNAL"),
    1: .same(proto: "JS_SDK"),
  ]
}

extension Bloombox_Page_Context.Scripts.JavaScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.Scripts.protoMessageName + ".JavaScript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "media"),
    2: .same(proto: "uri"),
    3: .same(proto: "known"),
    4: .same(proto: "module"),
    5: .same(proto: "defer"),
    6: .same(proto: "async"),
    7: .same(proto: "id"),
  ]

  fileprivate class _StorageClass {
    var _ref: Bloombox_Page_Context.Scripts.JavaScript.OneOf_Ref?
    var _module: Bool = false
    var _defer: Bool = false
    var _async: Bool = false
    var _id: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ref = source._ref
      _module = source._module
      _defer = source._defer
      _async = source._async
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Opencannabis_Media_MediaReference?
          if let current = _storage._ref {
            try decoder.handleConflictingOneOf()
            if case .media(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._ref = .media(v)}
        case 2:
          if _storage._ref != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._ref = .uri(v)}
        case 3:
          if _storage._ref != nil {try decoder.handleConflictingOneOf()}
          var v: Bloombox_Page_Context.Scripts.KnownScript?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._ref = .known(v)}
        case 4: try decoder.decodeSingularBoolField(value: &_storage._module)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._defer)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._async)
        case 7: try decoder.decodeSingularStringField(value: &_storage._id)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._ref {
      case .media(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .known(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      case nil: break
      }
      if _storage._module != false {
        try visitor.visitSingularBoolField(value: _storage._module, fieldNumber: 4)
      }
      if _storage._defer != false {
        try visitor.visitSingularBoolField(value: _storage._defer, fieldNumber: 5)
      }
      if _storage._async != false {
        try visitor.visitSingularBoolField(value: _storage._async, fieldNumber: 6)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Scripts.JavaScript, rhs: Bloombox_Page_Context.Scripts.JavaScript) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ref != rhs_storage._ref {return false}
        if _storage._module != rhs_storage._module {return false}
        if _storage._defer != rhs_storage._defer {return false}
        if _storage._async != rhs_storage._async {return false}
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.PartnerContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".PartnerContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "internal"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _scope: Bloombox_Page_Context.PartnerContext.OneOf_Scope?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._scope != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._scope = .internal(v)}
        case 2:
          var v: Bloombox_Partner_PartnerKey?
          if let current = _storage._scope {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scope = .partner(v)}
        case 3:
          var v: Bloombox_Partner_LocationKey?
          if let current = _storage._scope {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scope = .location(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._scope {
      case .internal(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.PartnerContext, rhs: Bloombox_Page_Context.PartnerContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Page_Context.Telemetry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Page_Context.protoMessageName + ".Telemetry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tag_manager_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tagManagerID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagManagerID.isEmpty {
      try visitor.visitSingularStringField(value: self.tagManagerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Page_Context.Telemetry, rhs: Bloombox_Page_Context.Telemetry) -> Bool {
    if lhs.tagManagerID != rhs.tagManagerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
