// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pos/PointOfSale.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies details, objects, and enumerates related to physical point-of-sale devices.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates states that a point-of-sale session may take.
public enum Bloombox_Pos_SessionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The session has been established, but no cash register session is open yet.
  case established // = 0

  /// This session is actively open.
  case active // = 1

  /// This session is paused temporarily.
  case suspended // = 2

  /// This session timed out/expired.
  case expired // = 3

  /// This session was formally terminated.
  case terminated // = 4

  /// The connection has been lost for this session.
  case lost // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .established
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .established
    case 1: self = .active
    case 2: self = .suspended
    case 3: self = .expired
    case 4: self = .terminated
    case 5: self = .lost
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .established: return 0
    case .active: return 1
    case .suspended: return 2
    case .expired: return 3
    case .terminated: return 4
    case .lost: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Pos_SessionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Pos_SessionStatus] = [
    .established,
    .active,
    .suspended,
    .expired,
    .terminated,
    .lost,
  ]
}

#endif  // swift(>=4.2)

/// Enumerates available point-of-sale device states.
public enum Bloombox_Pos_POSDeviceStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Specifies a state where the POS device is not being used.
  case idle // = 0

  /// Specifies a state where a session currently claims a POS device.
  case claimed // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .idle
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .claimed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .idle: return 0
    case .claimed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Pos_POSDeviceStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Pos_POSDeviceStatus] = [
    .idle,
    .claimed,
  ]
}

#endif  // swift(>=4.2)

/// Specifies information about the hardware powering a point-of-sale device.
public struct Bloombox_Pos_POSHardware {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the type of POS hardware.
  public var type: Bloombox_Pos_POSHardware.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Specifies the features supported by the POS hardware.
  public var support: Bloombox_Pos_POSHardware.Features {
    get {return _storage._support ?? Bloombox_Pos_POSHardware.Features()}
    set {_uniqueStorage()._support = newValue}
  }
  /// Returns true if `support` has been explicitly set.
  public var hasSupport: Bool {return _storage._support != nil}
  /// Clears the value of `support`. Subsequent reads from it will return its default value.
  public mutating func clearSupport() {_uniqueStorage()._support = nil}

  /// Arbitrary version name string.
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumerated, known types of point-of-sale hardware.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified point-of-sale hardware.
    case unspecified // = 0

    /// Bloombox Point-of-Sale.
    case bloombox // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .bloombox
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .bloombox: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies hardware features supported by the point-of-sale system.
  public enum Feature: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The system has a barcode printer.
    case printer // = 0

    /// The system has a barcode scanner.
    case bcs // = 1

    /// The system has a magnetic stripe reader.
    case msr // = 2

    /// The system has a Bluetooth Low Energy (BLE) antenna.
    case ble // = 3

    /// The system has a scale attached.
    case scale // = 4

    /// The system has a label printer attached.
    case labeller // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .printer
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .printer
      case 1: self = .bcs
      case 2: self = .msr
      case 3: self = .ble
      case 4: self = .scale
      case 5: self = .labeller
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .printer: return 0
      case .bcs: return 1
      case .msr: return 2
      case .ble: return 3
      case .scale: return 4
      case .labeller: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies the features available on a POS device.
  public struct Features {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies features supported by the POS hardware.
    public var feature: [Bloombox_Pos_POSHardware.Feature] = []

    /// Number of cash drawers supported by the hardware.
    public var drawers: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Bloombox_Pos_POSHardware.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Pos_POSHardware.TypeEnum] = [
    .unspecified,
    .bloombox,
  ]
}

extension Bloombox_Pos_POSHardware.Feature: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Pos_POSHardware.Feature] = [
    .printer,
    .bcs,
    .msr,
    .ble,
    .scale,
    .labeller,
  ]
}

#endif  // swift(>=4.2)

/// Specifies a point of sale device, co-located at a retailer location, that is suitable for processing retail to
/// consumer cannabis purchase transactions.
public struct Bloombox_Pos_PointOfSaleDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID assigned to, or gathered from, the device.
  public var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  /// Label/human name for the point-of-sale device.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Specifies the current status of this POS device.
  public var status: Bloombox_Pos_POSDeviceStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Specifies the string session ID currently claiming (or that was last to claim) this register.
  public var claim: String {
    get {return _storage._claim}
    set {_uniqueStorage()._claim = newValue}
  }

  /// Specifies information about the point-of-sale hardware in use.
  public var hardware: Bloombox_Pos_POSHardware {
    get {return _storage._hardware ?? Bloombox_Pos_POSHardware()}
    set {_uniqueStorage()._hardware = newValue}
  }
  /// Returns true if `hardware` has been explicitly set.
  public var hasHardware: Bool {return _storage._hardware != nil}
  /// Clears the value of `hardware`. Subsequent reads from it will return its default value.
  public mutating func clearHardware() {_uniqueStorage()._hardware = nil}

  /// Information about the last-seen POS app in use.
  public var app: Bloombox_Analytics_Context_DeviceApplication {
    get {return _storage._app ?? Bloombox_Analytics_Context_DeviceApplication()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {_uniqueStorage()._app = nil}

  /// Specifies sessions attached to this point of sale device.
  public var session: [Bloombox_Pos_PointOfSaleSession] {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  /// Indicates the current state of the point-of-sale device, including the current till value.
  public var state: Bloombox_Pos_PointOfSaleState {
    get {return _storage._state ?? Bloombox_Pos_PointOfSaleState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  /// Last time this point-of-sale device was seen.
  public var seen: Opencannabis_Temporal_Instant {
    get {return _storage._seen ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._seen = newValue}
  }
  /// Returns true if `seen` has been explicitly set.
  public var hasSeen: Bool {return _storage._seen != nil}
  /// Clears the value of `seen`. Subsequent reads from it will return its default value.
  public mutating func clearSeen() {_uniqueStorage()._seen = nil}

  /// Timestamp for when this device was created.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// Timestamp for when this device was last modified.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a combined state payload, provided to the point-of-sale unit once a session changes status.
public struct Bloombox_Pos_PointOfSaleState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes the opening state of a point of sale session.
  public var `open`: Bloombox_Pos_PointOfSaleState.SessionOpen {
    get {return _storage._open ?? Bloombox_Pos_PointOfSaleState.SessionOpen()}
    set {_uniqueStorage()._open = newValue}
  }
  /// Returns true if ``open`` has been explicitly set.
  public var hasOpen: Bool {return _storage._open != nil}
  /// Clears the value of ``open``. Subsequent reads from it will return its default value.
  public mutating func clearOpen() {_uniqueStorage()._open = nil}

  /// Describes all transactions that occurred during a point of sale session.
  public var transaction: [Opencannabis_Commerce_PurchaseKey] {
    get {return _storage._transaction}
    set {_uniqueStorage()._transaction = newValue}
  }

  /// Specifies the current, complete, aggregated bill-of-charges state. Computed by the backend.
  public var current: Opencannabis_Commerce_BillOfCharges {
    get {return _storage._current ?? Opencannabis_Commerce_BillOfCharges()}
    set {_uniqueStorage()._current = newValue}
  }
  /// Returns true if `current` has been explicitly set.
  public var hasCurrent: Bool {return _storage._current != nil}
  /// Clears the value of `current`. Subsequent reads from it will return its default value.
  public mutating func clearCurrent() {_uniqueStorage()._current = nil}

  /// Describes the closing state of a point of sale session.
  public var close: Bloombox_Pos_PointOfSaleState.SessionClose {
    get {return _storage._close ?? Bloombox_Pos_PointOfSaleState.SessionClose()}
    set {_uniqueStorage()._close = newValue}
  }
  /// Returns true if `close` has been explicitly set.
  public var hasClose: Bool {return _storage._close != nil}
  /// Clears the value of `close`. Subsequent reads from it will return its default value.
  public mutating func clearClose() {_uniqueStorage()._close = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message payload when a session has been opened.
  public struct SessionOpen {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Opening float value for the cash register. This is the initial cash amount used for change, etc.
    public var openingFloat: Opencannabis_Commerce_CurrencyValue {
      get {return _storage._openingFloat ?? Opencannabis_Commerce_CurrencyValue()}
      set {_uniqueStorage()._openingFloat = newValue}
    }
    /// Returns true if `openingFloat` has been explicitly set.
    public var hasOpeningFloat: Bool {return _storage._openingFloat != nil}
    /// Clears the value of `openingFloat`. Subsequent reads from it will return its default value.
    public mutating func clearOpeningFloat() {_uniqueStorage()._openingFloat = nil}

    /// Describes the moment the session was actually opened.
    public var occurred: Opencannabis_Temporal_Instant {
      get {return _storage._occurred ?? Opencannabis_Temporal_Instant()}
      set {_uniqueStorage()._occurred = newValue}
    }
    /// Returns true if `occurred` has been explicitly set.
    public var hasOccurred: Bool {return _storage._occurred != nil}
    /// Clears the value of `occurred`. Subsequent reads from it will return its default value.
    public mutating func clearOccurred() {_uniqueStorage()._occurred = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Message payload when a session has been closed.
  public struct SessionClose {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Closing cash value for the session. This is the total cash amount in the register upon closing.
    public var closingCount: Opencannabis_Commerce_CurrencyValue {
      get {return _storage._closingCount ?? Opencannabis_Commerce_CurrencyValue()}
      set {_uniqueStorage()._closingCount = newValue}
    }
    /// Returns true if `closingCount` has been explicitly set.
    public var hasClosingCount: Bool {return _storage._closingCount != nil}
    /// Clears the value of `closingCount`. Subsequent reads from it will return its default value.
    public mutating func clearClosingCount() {_uniqueStorage()._closingCount = nil}

    /// Describes the moment the session was actually opened.
    public var occurred: Opencannabis_Temporal_Instant {
      get {return _storage._occurred ?? Opencannabis_Temporal_Instant()}
      set {_uniqueStorage()._occurred = newValue}
    }
    /// Returns true if `occurred` has been explicitly set.
    public var hasOccurred: Bool {return _storage._occurred != nil}
    /// Clears the value of `occurred`. Subsequent reads from it will return its default value.
    public mutating func clearOccurred() {_uniqueStorage()._occurred = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a record of a purchase made by a consumer at a retail cannabis location. Purchases are like orders, in that
/// they are both consumer interactions with retailers in a commercial setting, but purchases are always made in-person
/// using a point-of-sale device, and never online or from remote.
public struct Bloombox_Pos_PurchaseTicket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique key generated to address this purchase. Usually consists of a string UUID.
  public var key: Opencannabis_Commerce_PurchaseKey {
    get {return _storage._key ?? Opencannabis_Commerce_PurchaseKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Version or revision number for this purchase ticket.
  public var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Specifies the current status of this individual purchase transaction.
  public var status: Opencannabis_Commerce_PurchaseStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Point-of-sale session that is currently claiming this ticket, or last claimed this ticket.
  public var claim: String {
    get {return _storage._claim}
    set {_uniqueStorage()._claim = newValue}
  }

  /// Partner organization, location, device, and staff member that facilitated this transaction.
  public var facilitator: Opencannabis_Commerce_PurchaseFacilitator {
    get {return _storage._facilitator ?? Opencannabis_Commerce_PurchaseFacilitator()}
    set {_uniqueStorage()._facilitator = newValue}
  }
  /// Returns true if `facilitator` has been explicitly set.
  public var hasFacilitator: Bool {return _storage._facilitator != nil}
  /// Clears the value of `facilitator`. Subsequent reads from it will return its default value.
  public mutating func clearFacilitator() {_uniqueStorage()._facilitator = nil}

  /// Specifies information regarding the customer that made this purchase.
  public var customer: Opencannabis_Commerce_PurchaseCustomer {
    get {return _storage._customer ?? Opencannabis_Commerce_PurchaseCustomer()}
    set {_uniqueStorage()._customer = newValue}
  }
  /// Returns true if `customer` has been explicitly set.
  public var hasCustomer: Bool {return _storage._customer != nil}
  /// Clears the value of `customer`. Subsequent reads from it will return its default value.
  public mutating func clearCustomer() {_uniqueStorage()._customer = nil}

  /// Line-item bill of charges, or purchase sums. Includes taxes and discounts.
  public var bill: Opencannabis_Commerce_BillOfCharges {
    get {return _storage._bill ?? Opencannabis_Commerce_BillOfCharges()}
    set {_uniqueStorage()._bill = newValue}
  }
  /// Returns true if `bill` has been explicitly set.
  public var hasBill: Bool {return _storage._bill != nil}
  /// Clears the value of `bill`. Subsequent reads from it will return its default value.
  public mutating func clearBill() {_uniqueStorage()._bill = nil}

  /// Constituent items purchased as part of this commercial purchase ticket.
  public var item: [Opencannabis_Commerce_TicketItem] {
    get {return _storage._item}
    set {_uniqueStorage()._item = newValue}
  }

  /// Specifies how this order was paid for, if applicable at this point in the ticket lifecycle.
  public var payment: [Opencannabis_Commerce_Payment] {
    get {return _storage._payment}
    set {_uniqueStorage()._payment = newValue}
  }

  /// Actions taken on this order.
  public var action: [Opencannabis_Commerce_PurchaseLogEntry] {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// Timestamps that record the temporal position of individual purchase lifecycle events.
  public var ts: Opencannabis_Commerce_PurchaseTimestamps {
    get {return _storage._ts ?? Opencannabis_Commerce_PurchaseTimestamps()}
    set {_uniqueStorage()._ts = newValue}
  }
  /// Returns true if `ts` has been explicitly set.
  public var hasTs: Bool {return _storage._ts != nil}
  /// Clears the value of `ts`. Subsequent reads from it will return its default value.
  public mutating func clearTs() {_uniqueStorage()._ts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the notion of a cash register session. All transactions must be conducted under a valid point of sale
/// session, previously established and then opened by an authorized user on an authorized device. Tickets may only be
/// part of one POS session, and POS sessions may contain many transactions (or 'purchases').
public struct Bloombox_Pos_PointOfSaleSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID generated to address this session.
  public var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  /// Specifies the current status of this POS session.
  public var status: Bloombox_Pos_SessionStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Specifies the authorized user account bound to this POS session.
  public var user: Bloombox_Identity_UserKey {
    get {return _storage._user ?? Bloombox_Identity_UserKey()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Specifies sessions attached to this point of sale device.
  public var ticket: [Bloombox_Pos_PurchaseTicket] {
    get {return _storage._ticket}
    set {_uniqueStorage()._ticket = newValue}
  }

  /// Opening and closing state of the cash register.
  public var state: Bloombox_Pos_PointOfSaleState {
    get {return _storage._state ?? Bloombox_Pos_PointOfSaleState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  /// Specifies the last moment this session was witnessed on the API.
  public var seen: Opencannabis_Temporal_Instant {
    get {return _storage._seen ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._seen = newValue}
  }
  /// Returns true if `seen` has been explicitly set.
  public var hasSeen: Bool {return _storage._seen != nil}
  /// Clears the value of `seen`. Subsequent reads from it will return its default value.
  public mutating func clearSeen() {_uniqueStorage()._seen = nil}

  /// Specifies the moment this session was created on the API.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// Specifies the last time this session was changed, except for `seen` updates.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.pos"

extension Bloombox_Pos_SessionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ESTABLISHED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "SUSPENDED"),
    3: .same(proto: "EXPIRED"),
    4: .same(proto: "TERMINATED"),
    5: .same(proto: "LOST"),
  ]
}

extension Bloombox_Pos_POSDeviceStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDLE"),
    1: .same(proto: "CLAIMED"),
  ]
}

extension Bloombox_Pos_POSHardware: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".POSHardware"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "support"),
    3: .same(proto: "version"),
  ]

  fileprivate class _StorageClass {
    var _type: Bloombox_Pos_POSHardware.TypeEnum = .unspecified
    var _support: Bloombox_Pos_POSHardware.Features? = nil
    var _version: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _support = source._support
      _version = source._version
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._support)
        case 3: try decoder.decodeSingularStringField(value: &_storage._version)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._support {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_POSHardware, rhs: Bloombox_Pos_POSHardware) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._support != rhs_storage._support {return false}
        if _storage._version != rhs_storage._version {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_POSHardware.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "BLOOMBOX"),
  ]
}

extension Bloombox_Pos_POSHardware.Feature: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRINTER"),
    1: .same(proto: "BCS"),
    2: .same(proto: "MSR"),
    3: .same(proto: "BLE"),
    4: .same(proto: "SCALE"),
    5: .same(proto: "LABELLER"),
  ]
}

extension Bloombox_Pos_POSHardware.Features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Pos_POSHardware.protoMessageName + ".Features"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feature"),
    2: .same(proto: "drawers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.feature)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.drawers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feature.isEmpty {
      try visitor.visitPackedEnumField(value: self.feature, fieldNumber: 1)
    }
    if self.drawers != 0 {
      try visitor.visitSingularUInt32Field(value: self.drawers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_POSHardware.Features, rhs: Bloombox_Pos_POSHardware.Features) -> Bool {
    if lhs.feature != rhs.feature {return false}
    if lhs.drawers != rhs.drawers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_PointOfSaleDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointOfSaleDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "name"),
    3: .same(proto: "status"),
    4: .same(proto: "claim"),
    5: .same(proto: "hardware"),
    6: .same(proto: "app"),
    7: .same(proto: "session"),
    8: .same(proto: "state"),
    9: .same(proto: "seen"),
    98: .same(proto: "created"),
    99: .same(proto: "modified"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _name: String = String()
    var _status: Bloombox_Pos_POSDeviceStatus = .idle
    var _claim: String = String()
    var _hardware: Bloombox_Pos_POSHardware? = nil
    var _app: Bloombox_Analytics_Context_DeviceApplication? = nil
    var _session: [Bloombox_Pos_PointOfSaleSession] = []
    var _state: Bloombox_Pos_PointOfSaleState? = nil
    var _seen: Opencannabis_Temporal_Instant? = nil
    var _created: Opencannabis_Temporal_Instant? = nil
    var _modified: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _name = source._name
      _status = source._status
      _claim = source._claim
      _hardware = source._hardware
      _app = source._app
      _session = source._session
      _state = source._state
      _seen = source._seen
      _created = source._created
      _modified = source._modified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._uuid)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 4: try decoder.decodeSingularStringField(value: &_storage._claim)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._hardware)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._app)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._session)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._state)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._seen)
        case 98: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 99: try decoder.decodeSingularMessageField(value: &_storage._modified)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._status != .idle {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      if !_storage._claim.isEmpty {
        try visitor.visitSingularStringField(value: _storage._claim, fieldNumber: 4)
      }
      if let v = _storage._hardware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._session.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._session, fieldNumber: 7)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._seen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_PointOfSaleDevice, rhs: Bloombox_Pos_PointOfSaleDevice) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._claim != rhs_storage._claim {return false}
        if _storage._hardware != rhs_storage._hardware {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._seen != rhs_storage._seen {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._modified != rhs_storage._modified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_PointOfSaleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointOfSaleState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "transaction"),
    3: .same(proto: "current"),
    4: .same(proto: "close"),
  ]

  fileprivate class _StorageClass {
    var _open: Bloombox_Pos_PointOfSaleState.SessionOpen? = nil
    var _transaction: [Opencannabis_Commerce_PurchaseKey] = []
    var _current: Opencannabis_Commerce_BillOfCharges? = nil
    var _close: Bloombox_Pos_PointOfSaleState.SessionClose? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _open = source._open
      _transaction = source._transaction
      _current = source._current
      _close = source._close
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._open)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._transaction)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._current)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._close)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._open {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._transaction.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transaction, fieldNumber: 2)
      }
      if let v = _storage._current {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._close {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_PointOfSaleState, rhs: Bloombox_Pos_PointOfSaleState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._open != rhs_storage._open {return false}
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._current != rhs_storage._current {return false}
        if _storage._close != rhs_storage._close {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_PointOfSaleState.SessionOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Pos_PointOfSaleState.protoMessageName + ".SessionOpen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opening_float"),
    2: .same(proto: "occurred"),
  ]

  fileprivate class _StorageClass {
    var _openingFloat: Opencannabis_Commerce_CurrencyValue? = nil
    var _occurred: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _openingFloat = source._openingFloat
      _occurred = source._occurred
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._openingFloat)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._occurred)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._openingFloat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._occurred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_PointOfSaleState.SessionOpen, rhs: Bloombox_Pos_PointOfSaleState.SessionOpen) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._openingFloat != rhs_storage._openingFloat {return false}
        if _storage._occurred != rhs_storage._occurred {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_PointOfSaleState.SessionClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Pos_PointOfSaleState.protoMessageName + ".SessionClose"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "closing_count"),
    2: .same(proto: "occurred"),
  ]

  fileprivate class _StorageClass {
    var _closingCount: Opencannabis_Commerce_CurrencyValue? = nil
    var _occurred: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _closingCount = source._closingCount
      _occurred = source._occurred
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._closingCount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._occurred)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._closingCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._occurred {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_PointOfSaleState.SessionClose, rhs: Bloombox_Pos_PointOfSaleState.SessionClose) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._closingCount != rhs_storage._closingCount {return false}
        if _storage._occurred != rhs_storage._occurred {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_PurchaseTicket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurchaseTicket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "version"),
    3: .same(proto: "status"),
    4: .same(proto: "claim"),
    5: .same(proto: "facilitator"),
    6: .same(proto: "customer"),
    7: .same(proto: "bill"),
    8: .same(proto: "item"),
    9: .same(proto: "payment"),
    10: .same(proto: "action"),
    11: .same(proto: "ts"),
  ]

  fileprivate class _StorageClass {
    var _key: Opencannabis_Commerce_PurchaseKey? = nil
    var _version: UInt32 = 0
    var _status: Opencannabis_Commerce_PurchaseStatus = .fresh
    var _claim: String = String()
    var _facilitator: Opencannabis_Commerce_PurchaseFacilitator? = nil
    var _customer: Opencannabis_Commerce_PurchaseCustomer? = nil
    var _bill: Opencannabis_Commerce_BillOfCharges? = nil
    var _item: [Opencannabis_Commerce_TicketItem] = []
    var _payment: [Opencannabis_Commerce_Payment] = []
    var _action: [Opencannabis_Commerce_PurchaseLogEntry] = []
    var _ts: Opencannabis_Commerce_PurchaseTimestamps? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _version = source._version
      _status = source._status
      _claim = source._claim
      _facilitator = source._facilitator
      _customer = source._customer
      _bill = source._bill
      _item = source._item
      _payment = source._payment
      _action = source._action
      _ts = source._ts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 4: try decoder.decodeSingularStringField(value: &_storage._claim)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._facilitator)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._customer)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._bill)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._item)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._payment)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._action)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._ts)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 2)
      }
      if _storage._status != .fresh {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      if !_storage._claim.isEmpty {
        try visitor.visitSingularStringField(value: _storage._claim, fieldNumber: 4)
      }
      if let v = _storage._facilitator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._customer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._bill {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._item.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._item, fieldNumber: 8)
      }
      if !_storage._payment.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._payment, fieldNumber: 9)
      }
      if !_storage._action.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._action, fieldNumber: 10)
      }
      if let v = _storage._ts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_PurchaseTicket, rhs: Bloombox_Pos_PurchaseTicket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._claim != rhs_storage._claim {return false}
        if _storage._facilitator != rhs_storage._facilitator {return false}
        if _storage._customer != rhs_storage._customer {return false}
        if _storage._bill != rhs_storage._bill {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._ts != rhs_storage._ts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Pos_PointOfSaleSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointOfSaleSession"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "status"),
    3: .same(proto: "user"),
    4: .same(proto: "ticket"),
    5: .same(proto: "state"),
    6: .same(proto: "seen"),
    7: .same(proto: "created"),
    8: .same(proto: "modified"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _status: Bloombox_Pos_SessionStatus = .established
    var _user: Bloombox_Identity_UserKey? = nil
    var _ticket: [Bloombox_Pos_PurchaseTicket] = []
    var _state: Bloombox_Pos_PointOfSaleState? = nil
    var _seen: Opencannabis_Temporal_Instant? = nil
    var _created: Opencannabis_Temporal_Instant? = nil
    var _modified: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _status = source._status
      _user = source._user
      _ticket = source._ticket
      _state = source._state
      _seen = source._seen
      _created = source._created
      _modified = source._modified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._uuid)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._ticket)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._state)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._seen)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._modified)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if _storage._status != .established {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 2)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._ticket.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ticket, fieldNumber: 4)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._seen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Pos_PointOfSaleSession, rhs: Bloombox_Pos_PointOfSaleSession) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._ticket != rhs_storage._ticket {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._seen != rhs_storage._seen {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._modified != rhs_storage._modified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
