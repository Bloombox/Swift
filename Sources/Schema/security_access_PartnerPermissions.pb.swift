// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: security/access/PartnerPermissions.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies access-related notions for security/privacy/authorization systems. "Partners," or organization-level
/// accounts, can retain one or more "locations," which are individual containers for commerce and data. These structures
/// enumerate and specify permissions as they occur between those entities and end-user accounts.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates roles that may be granted, on behalf of a partner or partner location account, to an end-user account, by
/// a location or partner admin.
public enum Bloombox_Security_Access_PartnerRole: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Read-only permission for the specified scope.
  case readonly // = 0

  /// Supervisor (edit, but not admin) permission for the specified scope.
  case supervisor // = 1

  /// Billing administration rights. Can edit payment methods and see/manage invoices.
  case billing // = 2

  /// Audit rights. Allows outside auditors to see account data in a read-only manner.
  case audit // = 3

  /// Employee rights. Can manage data but not settings.
  case employee // = 4

  /// Software-level access, with ability to manage API keys and technical settings.
  case developer // = 5

  /// Administrator account, with full access to user and account-level settings.
  case admin // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .readonly
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .readonly
    case 1: self = .supervisor
    case 2: self = .billing
    case 3: self = .audit
    case 4: self = .employee
    case 5: self = .developer
    case 6: self = .admin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .readonly: return 0
    case .supervisor: return 1
    case .billing: return 2
    case .audit: return 3
    case .employee: return 4
    case .developer: return 5
    case .admin: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Security_Access_PartnerRole: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Security_Access_PartnerRole] = [
    .readonly,
    .supervisor,
    .billing,
    .audit,
    .employee,
    .developer,
    .admin,
  ]
}

#endif  // swift(>=4.2)

/// Specifies the subject account for a given access policy. The subject "account," in this case, is the partner or
/// partner location for which right are being specified.
public struct Bloombox_Security_Access_AccessSubject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the subject account (partner or location) for this rights subject payload.
  public var account: OneOf_Account? {
    get {return _storage._account}
    set {_uniqueStorage()._account = newValue}
  }

  /// Partner-level access scope.
  public var partner: Bloombox_Partner_PartnerKey {
    get {
      if case .partner(let v)? = _storage._account {return v}
      return Bloombox_Partner_PartnerKey()
    }
    set {_uniqueStorage()._account = .partner(newValue)}
  }

  /// Partner location-level access scope.
  public var location: Bloombox_Partner_LocationKey {
    get {
      if case .location(let v)? = _storage._account {return v}
      return Bloombox_Partner_LocationKey()
    }
    set {_uniqueStorage()._account = .location(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the subject account (partner or location) for this rights subject payload.
  public enum OneOf_Account: Equatable {
    /// Partner-level access scope.
    case partner(Bloombox_Partner_PartnerKey)
    /// Partner location-level access scope.
    case location(Bloombox_Partner_LocationKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Security_Access_AccessSubject.OneOf_Account, rhs: Bloombox_Security_Access_AccessSubject.OneOf_Account) -> Bool {
      switch (lhs, rhs) {
      case (.partner(let l), .partner(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a policy that grants access to a given security subject (a user or a domain) for a given resource (a kind
/// of data, login access at all, etc).
public struct Bloombox_Security_Access_AccessPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID assigned to this access policy.
  public var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  /// Partner account or location that we are specifying access rights for.
  public var subject: Bloombox_Security_Access_AccessSubject {
    get {return _storage._subject ?? Bloombox_Security_Access_AccessSubject()}
    set {_uniqueStorage()._subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return _storage._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {_uniqueStorage()._subject = nil}

  /// Roles granted as part of this policy.
  public var privilege: [Bloombox_Security_Access_PartnerRole] {
    get {return _storage._privilege}
    set {_uniqueStorage()._privilege = newValue}
  }

  /// User being granted rights as part of this policy.
  public var user: Bloombox_Identity_UserKey {
    get {return _storage._user ?? Bloombox_Identity_UserKey()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Permissions grantor.
  public var grantor: Bloombox_Identity_UserKey {
    get {return _storage._grantor ?? Bloombox_Identity_UserKey()}
    set {_uniqueStorage()._grantor = newValue}
  }
  /// Returns true if `grantor` has been explicitly set.
  public var hasGrantor: Bool {return _storage._grantor != nil}
  /// Clears the value of `grantor`. Subsequent reads from it will return its default value.
  public mutating func clearGrantor() {_uniqueStorage()._grantor = nil}

  /// Modified timestamp for this record.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  /// Created timestmap for this record.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.security.access"

extension Bloombox_Security_Access_PartnerRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "READONLY"),
    1: .same(proto: "SUPERVISOR"),
    2: .same(proto: "BILLING"),
    3: .same(proto: "AUDIT"),
    4: .same(proto: "EMPLOYEE"),
    5: .same(proto: "DEVELOPER"),
    6: .same(proto: "ADMIN"),
  ]
}

extension Bloombox_Security_Access_AccessSubject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessSubject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "partner"),
    20: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _account: Bloombox_Security_Access_AccessSubject.OneOf_Account?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 10:
          var v: Bloombox_Partner_PartnerKey?
          if let current = _storage._account {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._account = .partner(v)}
        case 20:
          var v: Bloombox_Partner_LocationKey?
          if let current = _storage._account {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._account = .location(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._account {
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Security_Access_AccessSubject, rhs: Bloombox_Security_Access_AccessSubject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Security_Access_AccessPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "subject"),
    3: .same(proto: "privilege"),
    4: .same(proto: "user"),
    5: .same(proto: "grantor"),
    98: .same(proto: "modified"),
    99: .same(proto: "created"),
  ]

  fileprivate class _StorageClass {
    var _uuid: String = String()
    var _subject: Bloombox_Security_Access_AccessSubject? = nil
    var _privilege: [Bloombox_Security_Access_PartnerRole] = []
    var _user: Bloombox_Identity_UserKey? = nil
    var _grantor: Bloombox_Identity_UserKey? = nil
    var _modified: Opencannabis_Temporal_Instant? = nil
    var _created: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _subject = source._subject
      _privilege = source._privilege
      _user = source._user
      _grantor = source._grantor
      _modified = source._modified
      _created = source._created
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._uuid)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._subject)
        case 3: try decoder.decodeRepeatedEnumField(value: &_storage._privilege)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._grantor)
        case 98: try decoder.decodeSingularMessageField(value: &_storage._modified)
        case 99: try decoder.decodeSingularMessageField(value: &_storage._created)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 1)
      }
      if let v = _storage._subject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._privilege.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._privilege, fieldNumber: 3)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._grantor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Security_Access_AccessPolicy, rhs: Bloombox_Security_Access_AccessPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._privilege != rhs_storage._privilege {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._grantor != rhs_storage._grantor {return false}
        if _storage._modified != rhs_storage._modified {return false}
        if _storage._created != rhs_storage._created {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
