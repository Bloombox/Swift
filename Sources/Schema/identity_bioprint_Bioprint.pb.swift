// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: identity/bioprint/Bioprint.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Defines a Bioprint, which is a structure used for summarizing and logging an individual user's cannabis history and
/// experiential response. Elements that structure the inner Bioprint payloads, and the resulting outer main Bioprint
/// payload, are defined here. See architecture design for the Bioprint Architecture for more information.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies a master symmetric key, referred to in the spec as the *Profile Access Key*. This key acts as the main
/// access method for the user's local device to load and read/mutate the underlying Bioprint data. It never leaves the
/// user's device.
public struct Bloombox_Identity_Bioprint_MasterKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name for the key, which is generally set from the device name that owns the key.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The key sequence number, which refers to the generation for this key (considering key rotation).
  public var sequence: UInt32 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  /// Whether this key is considered active or revoked. If not present or false, the key is considered active (assuming
  /// it has not been superseded).
  public var disabled: Bool {
    get {return _storage._disabled}
    set {_uniqueStorage()._disabled = newValue}
  }

  /// Whether this key is considered primary or superseded. Superseded keys have been rotated for other keys, and can be
  /// safely deleted from the subject profile.
  public var superseded: Bool {
    get {return _storage._superseded}
    set {_uniqueStorage()._superseded = newValue}
  }

  /// Symmetric key material, including the raw bytes of the underlying secret key.
  public var key: Opencannabis_Crypto_SymmetricKey {
    get {return _storage._key ?? Opencannabis_Crypto_SymmetricKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Timestamp specifying the time this key was last-used.
  public var used: Opencannabis_Temporal_Instant {
    get {return _storage._used ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._used = newValue}
  }
  /// Returns true if `used` has been explicitly set.
  public var hasUsed: Bool {return _storage._used != nil}
  /// Clears the value of `used`. Subsequent reads from it will return its default value.
  public mutating func clearUsed() {_uniqueStorage()._used = nil}

  /// Timestamp specifying the time this key was first generated.
  public var generated: Opencannabis_Temporal_Instant {
    get {return _storage._generated ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._generated = newValue}
  }
  /// Returns true if `generated` has been explicitly set.
  public var hasGenerated: Bool {return _storage._generated != nil}
  /// Clears the value of `generated`. Subsequent reads from it will return its default value.
  public mutating func clearGenerated() {_uniqueStorage()._generated = nil}

  /// Timestamp specifying the time this key was revoked.
  public var revoked: Opencannabis_Temporal_Instant {
    get {return _storage._revoked ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._revoked = newValue}
  }
  /// Returns true if `revoked` has been explicitly set.
  public var hasRevoked: Bool {return _storage._revoked != nil}
  /// Clears the value of `revoked`. Subsequent reads from it will return its default value.
  public mutating func clearRevoked() {_uniqueStorage()._revoked = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a restoration symmetric key, referred to in the spec as the *Backup Access Key*. This key acts as a one-off
/// safeguard to restore a backup version of the user's *Bioprint*. It is generated on-demand for each export/backup of
/// that includes the private portion of the user's *Bioprint*. Because their use depends on an online service, they are
/// revocable by the user in cases of service or backup compromise.
public struct Bloombox_Identity_Bioprint_RestorationKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name for the key, which is generally set from the export name or service.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Whether this key should be considered revoked or not. If not present or false, the key is considered active.
  public var disabled: Bool {
    get {return _storage._disabled}
    set {_uniqueStorage()._disabled = newValue}
  }

  /// Symmetric key material, including the raw bytes of the underlying secret key.
  public var key: Opencannabis_Crypto_SymmetricKey {
    get {return _storage._key ?? Opencannabis_Crypto_SymmetricKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Timestamp specifying the time this key was last-used.
  public var generated: Opencannabis_Temporal_Instant {
    get {return _storage._generated ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._generated = newValue}
  }
  /// Returns true if `generated` has been explicitly set.
  public var hasGenerated: Bool {return _storage._generated != nil}
  /// Clears the value of `generated`. Subsequent reads from it will return its default value.
  public mutating func clearGenerated() {_uniqueStorage()._generated = nil}

  /// Timestamp specifying the time this key was revoked.
  public var revoked: Opencannabis_Temporal_Instant {
    get {return _storage._revoked ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._revoked = newValue}
  }
  /// Returns true if `revoked` has been explicitly set.
  public var hasRevoked: Bool {return _storage._revoked != nil}
  /// Clears the value of `revoked`. Subsequent reads from it will return its default value.
  public mutating func clearRevoked() {_uniqueStorage()._revoked = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies an ephemeral symmetric key, generated for the purposes of sharing a *Bioprint* with a specific, authorized
/// partner organization. These keys are generated on-demand and on a per-partner basis. Because the use of stub keys
/// depends on a signed payload from an online service, they are revocable by the user. Only the public portion of the
/// *Bioprint* is shared, and can be decrypted, by a stub key.
public struct Bloombox_Identity_Bioprint_StubKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ephemeral ID provisioned for this Bioprint payload.
  public var id: Bloombox_Identity_Bioprint_BioprintID {
    get {return _storage._id ?? Bloombox_Identity_Bioprint_BioprintID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Name for the key, which is generally set from the provider name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Whether this key should be considered revoked or not. If not present or false, the key is considered active.
  public var disabled: Bool {
    get {return _storage._disabled}
    set {_uniqueStorage()._disabled = newValue}
  }

  /// Symmetric key material, including the raw bytes of the underlying secret key.
  public var key: Opencannabis_Crypto_SymmetricKey {
    get {return _storage._key ?? Opencannabis_Crypto_SymmetricKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Timestamp specifying the time this key was last-used.
  public var generated: Opencannabis_Temporal_Instant {
    get {return _storage._generated ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._generated = newValue}
  }
  /// Returns true if `generated` has been explicitly set.
  public var hasGenerated: Bool {return _storage._generated != nil}
  /// Clears the value of `generated`. Subsequent reads from it will return its default value.
  public mutating func clearGenerated() {_uniqueStorage()._generated = nil}

  /// Timestamp specifying the time this key was revoked.
  public var revoked: Opencannabis_Temporal_Instant {
    get {return _storage._revoked ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._revoked = newValue}
  }
  /// Returns true if `revoked` has been explicitly set.
  public var hasRevoked: Bool {return _storage._revoked != nil}
  /// Clears the value of `revoked`. Subsequent reads from it will return its default value.
  public mutating func clearRevoked() {_uniqueStorage()._revoked = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a JSON Web Token (JWT) issued during the process of updating a *Bioprint*, to form an attestation of user
/// identity provenance and control. Tokens are issued by the user's own device and signed with their key.
public struct Bloombox_Identity_Bioprint_BioprintToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encoded token payload. Standard JSON Web Token.
  public var token: Bloombox_Security_AuthToken {
    get {return _storage._token ?? Bloombox_Security_AuthToken()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  /// Fingerprint for the underlying used to sign the enclosed token.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  /// Issuance timestamp for the enclosed token.
  public var issued: Opencannabis_Temporal_Instant {
    get {return _storage._issued ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._issued = newValue}
  }
  /// Returns true if `issued` has been explicitly set.
  public var hasIssued: Bool {return _storage._issued != nil}
  /// Clears the value of `issued`. Subsequent reads from it will return its default value.
  public mutating func clearIssued() {_uniqueStorage()._issued = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a payload that addresses an individual *Bioprint* payload. A Bioprint ID is allocated each time a Bioprint
/// is shared with a given provider (snapshotting that *Bioprint* in time for that moment), and created originally as an
/// anchor in the payload's history. It is composed from a hash algorithm defined in the *Bioprint Architecture* spec.
public struct Bloombox_Identity_Bioprint_BioprintID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID that originated the Bioprint addressed by this identifier.
  public var origin: String {
    get {return _storage._origin}
    set {_uniqueStorage()._origin = newValue}
  }

  /// Parent ID that created this Bioprint ID. When a Bioprint is updated with a provider, a new ID is generated. When
  /// this is the case, the old one is included here, and within the hash.
  public var ancestor: String {
    get {return _storage._ancestor}
    set {_uniqueStorage()._ancestor = newValue}
  }

  /// Timestamp indicating the moment of issuance for this Bioprint ID.
  public var issued: Opencannabis_Temporal_Instant {
    get {return _storage._issued ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._issued = newValue}
  }
  /// Returns true if `issued` has been explicitly set.
  public var hasIssued: Bool {return _storage._issued != nil}
  /// Clears the value of `issued`. Subsequent reads from it will return its default value.
  public mutating func clearIssued() {_uniqueStorage()._issued = nil}

  /// Signature from the user's key, authorizing this Bioprint ID to be allocated and potentially shared.
  public var signature: Opencannabis_Crypto_Signature {
    get {return _storage._signature ?? Opencannabis_Crypto_Signature()}
    set {_uniqueStorage()._signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return _storage._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {_uniqueStorage()._signature = nil}

  /// Specifies the partner for which this ID was allocated, if applicable. The root Bioprint ID specifies no provider
  /// partner or ancestor value.
  public var partner: Bloombox_Partner_PartnerKey {
    get {return _storage._partner ?? Bloombox_Partner_PartnerKey()}
    set {_uniqueStorage()._partner = newValue}
  }
  /// Returns true if `partner` has been explicitly set.
  public var hasPartner: Bool {return _storage._partner != nil}
  /// Clears the value of `partner`. Subsequent reads from it will return its default value.
  public mutating func clearPartner() {_uniqueStorage()._partner = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies private cryptographic material and access policies for a user's *Bioprint*. The user's master key is stored
/// here, along with each restoration key allocated from this copy of the payload.
public struct Bloombox_Identity_Bioprint_Keychain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Master key information and raw key material.
  public var master: [Bloombox_Identity_Bioprint_MasterKey] {
    get {return _storage._master}
    set {_uniqueStorage()._master = newValue}
  }

  /// Export keys, each with their information and raw key material.
  public var restoration: [Bloombox_Identity_Bioprint_RestorationKey] {
    get {return _storage._restoration}
    set {_uniqueStorage()._restoration = newValue}
  }

  /// Key rotation generation. Indicates the tip of master key history.
  public var generation: UInt32 {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  /// Timestamp indicating when keys were last rotated.
  public var lastRotated: Opencannabis_Temporal_Instant {
    get {return _storage._lastRotated ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._lastRotated = newValue}
  }
  /// Returns true if `lastRotated` has been explicitly set.
  public var hasLastRotated: Bool {return _storage._lastRotated != nil}
  /// Clears the value of `lastRotated`. Subsequent reads from it will return its default value.
  public mutating func clearLastRotated() {_uniqueStorage()._lastRotated = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describes the content of a user's *Bioprint*. This is considered the "inner" payload, and it contains references to
/// each of the major components, that, together, form the user's cannabis purchase and experience response history. Hash
/// calculations based on *Bioprint* content occur based on this record.
public struct Bloombox_Identity_Bioprint_BioprintPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Integer that indicates the generation ID of this Bioprint payload. Each time a Bioprint is regenerated, the value
  /// in this property is incremented, to give a rough idea of the "maturity" of the Bioprint relative to when it was
  /// first provisioned on behalf of the subject user.
  public var generation: UInt32 {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  /// Specifies affinities, calculated and otherwise, for each aspect-of-use, as they relate to the subject consumer that
  /// owns this Bioprint payload. Affinities are opaque occur individually or in groups, via categorization.
  public var affinity: [Bloombox_Identity_Bioprint_Affinity] {
    get {return _storage._affinity}
    set {_uniqueStorage()._affinity = newValue}
  }

  /// Specifies details regarding this consumer's declared use preferences. This includes their stated preferred mode of
  /// ingestion, their preferred product types, cannabinoid ratios, and more.
  public var preferences: Bloombox_Identity_ConsumerPreferences {
    get {return _storage._preferences ?? Bloombox_Identity_ConsumerPreferences()}
    set {_uniqueStorage()._preferences = newValue}
  }
  /// Returns true if `preferences` has been explicitly set.
  public var hasPreferences: Bool {return _storage._preferences != nil}
  /// Clears the value of `preferences`. Subsequent reads from it will return its default value.
  public mutating func clearPreferences() {_uniqueStorage()._preferences = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a substantive revision made to a *Bioprint* payload. "Substantive" is defined as, any data mutation that
/// might amount to a potential outcome change when querying the resulting *Bioprint*.
public struct Bloombox_Identity_Bioprint_BioprintRevision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID that resulted after computing and applying this revision.
  public var id: Bloombox_Identity_Bioprint_BioprintID {
    get {return _storage._id ?? Bloombox_Identity_Bioprint_BioprintID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Timestamp for the moment this revision was applied.
  public var applied: Opencannabis_Temporal_Instant {
    get {return _storage._applied ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._applied = newValue}
  }
  /// Returns true if `applied` has been explicitly set.
  public var hasApplied: Bool {return _storage._applied != nil}
  /// Clears the value of `applied`. Subsequent reads from it will return its default value.
  public mutating func clearApplied() {_uniqueStorage()._applied = nil}

  /// Archived copy of the profile, after this revision was applied.
  public var profile: Bloombox_Identity_Bioprint_BioprintPayload {
    get {return _storage._profile ?? Bloombox_Identity_Bioprint_BioprintPayload()}
    set {_uniqueStorage()._profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return _storage._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {_uniqueStorage()._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Describes the main Bioprint outer wrapping, which is encoded and placed in an encrypted container for storage. This
/// is the outermost payload in the Bioprint that is structurally defined. It is responsible for storing revision history
/// and cryptographic material, among other metadata.
public struct Bloombox_Identity_Bioprint_Bioprint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the current and active identifier that addresses this Bioprint. This value is considered globally unique.
  public var id: Bloombox_Identity_Bioprint_BioprintID {
    get {return _storage._id ?? Bloombox_Identity_Bioprint_BioprintID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Auth and crypto keychain, specifying master and recovery keys attached to this Bioprint.
  public var keychain: Bloombox_Identity_Bioprint_Keychain {
    get {return _storage._keychain ?? Bloombox_Identity_Bioprint_Keychain()}
    set {_uniqueStorage()._keychain = newValue}
  }
  /// Returns true if `keychain` has been explicitly set.
  public var hasKeychain: Bool {return _storage._keychain != nil}
  /// Clears the value of `keychain`. Subsequent reads from it will return its default value.
  public mutating func clearKeychain() {_uniqueStorage()._keychain = nil}

  /// Bioprint profile payload, which includes the actual content of the user's private and public Bioprint components.
  public var profile: Bloombox_Identity_Bioprint_BioprintPayload {
    get {return _storage._profile ?? Bloombox_Identity_Bioprint_BioprintPayload()}
    set {_uniqueStorage()._profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return _storage._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {_uniqueStorage()._profile = nil}

  /// Contains the user's verified government identification.
  public var identification: Bloombox_Identity_ID {
    get {return _storage._identification ?? Bloombox_Identity_ID()}
    set {_uniqueStorage()._identification = newValue}
  }
  /// Returns true if `identification` has been explicitly set.
  public var hasIdentification: Bool {return _storage._identification != nil}
  /// Clears the value of `identification`. Subsequent reads from it will return its default value.
  public mutating func clearIdentification() {_uniqueStorage()._identification = nil}

  /// Specifies the user's globally-unique profile key.
  public var user: Bloombox_Identity_UserKey {
    get {return _storage._user ?? Bloombox_Identity_UserKey()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Specifies consumer memberships stored for express check-in.
  public var memberships: Dictionary<String,Bloombox_Identity_ConsumerMembership> {
    get {return _storage._memberships}
    set {_uniqueStorage()._memberships = newValue}
  }

  /// Revision history for this Bioprint, including each ID and signature.
  public var revision: [Bloombox_Identity_Bioprint_BioprintRevision] {
    get {return _storage._revision}
    set {_uniqueStorage()._revision = newValue}
  }

  /// Indicates the precise moment this Bioprint was last mutated or updated.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  /// Indicates the precise moment this Bioprint was originally created.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.identity.bioprint"

extension Bloombox_Identity_Bioprint_MasterKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "sequence"),
    3: .same(proto: "disabled"),
    4: .same(proto: "superseded"),
    5: .same(proto: "key"),
    6: .same(proto: "used"),
    7: .same(proto: "generated"),
    8: .same(proto: "revoked"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _sequence: UInt32 = 0
    var _disabled: Bool = false
    var _superseded: Bool = false
    var _key: Opencannabis_Crypto_SymmetricKey? = nil
    var _used: Opencannabis_Temporal_Instant? = nil
    var _generated: Opencannabis_Temporal_Instant? = nil
    var _revoked: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _sequence = source._sequence
      _disabled = source._disabled
      _superseded = source._superseded
      _key = source._key
      _used = source._used
      _generated = source._generated
      _revoked = source._revoked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._sequence)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._disabled)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._superseded)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._used)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._generated)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._revoked)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sequence, fieldNumber: 2)
      }
      if _storage._disabled != false {
        try visitor.visitSingularBoolField(value: _storage._disabled, fieldNumber: 3)
      }
      if _storage._superseded != false {
        try visitor.visitSingularBoolField(value: _storage._superseded, fieldNumber: 4)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._used {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._generated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._revoked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_MasterKey, rhs: Bloombox_Identity_Bioprint_MasterKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._disabled != rhs_storage._disabled {return false}
        if _storage._superseded != rhs_storage._superseded {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._used != rhs_storage._used {return false}
        if _storage._generated != rhs_storage._generated {return false}
        if _storage._revoked != rhs_storage._revoked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_RestorationKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestorationKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "disabled"),
    3: .same(proto: "key"),
    4: .same(proto: "generated"),
    5: .same(proto: "revoked"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _disabled: Bool = false
    var _key: Opencannabis_Crypto_SymmetricKey? = nil
    var _generated: Opencannabis_Temporal_Instant? = nil
    var _revoked: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _disabled = source._disabled
      _key = source._key
      _generated = source._generated
      _revoked = source._revoked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._disabled)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._generated)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._revoked)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._disabled != false {
        try visitor.visitSingularBoolField(value: _storage._disabled, fieldNumber: 2)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._generated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._revoked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_RestorationKey, rhs: Bloombox_Identity_Bioprint_RestorationKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._disabled != rhs_storage._disabled {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._generated != rhs_storage._generated {return false}
        if _storage._revoked != rhs_storage._revoked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_StubKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StubKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "disabled"),
    4: .same(proto: "key"),
    5: .same(proto: "generated"),
    6: .same(proto: "revoked"),
  ]

  fileprivate class _StorageClass {
    var _id: Bloombox_Identity_Bioprint_BioprintID? = nil
    var _name: String = String()
    var _disabled: Bool = false
    var _key: Opencannabis_Crypto_SymmetricKey? = nil
    var _generated: Opencannabis_Temporal_Instant? = nil
    var _revoked: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _disabled = source._disabled
      _key = source._key
      _generated = source._generated
      _revoked = source._revoked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._disabled)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._generated)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._revoked)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._disabled != false {
        try visitor.visitSingularBoolField(value: _storage._disabled, fieldNumber: 3)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._generated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._revoked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_StubKey, rhs: Bloombox_Identity_Bioprint_StubKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._disabled != rhs_storage._disabled {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._generated != rhs_storage._generated {return false}
        if _storage._revoked != rhs_storage._revoked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_BioprintToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BioprintToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "fingerprint"),
    3: .same(proto: "issued"),
  ]

  fileprivate class _StorageClass {
    var _token: Bloombox_Security_AuthToken? = nil
    var _fingerprint: Opencannabis_Crypto_Hash? = nil
    var _issued: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _fingerprint = source._fingerprint
      _issued = source._issued
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._token)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._issued)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._issued {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_BioprintToken, rhs: Bloombox_Identity_Bioprint_BioprintToken) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._issued != rhs_storage._issued {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_BioprintID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BioprintID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "ancestor"),
    3: .same(proto: "issued"),
    4: .same(proto: "signature"),
    5: .same(proto: "partner"),
  ]

  fileprivate class _StorageClass {
    var _origin: String = String()
    var _ancestor: String = String()
    var _issued: Opencannabis_Temporal_Instant? = nil
    var _signature: Opencannabis_Crypto_Signature? = nil
    var _partner: Bloombox_Partner_PartnerKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _origin = source._origin
      _ancestor = source._ancestor
      _issued = source._issued
      _signature = source._signature
      _partner = source._partner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._origin)
        case 2: try decoder.decodeSingularStringField(value: &_storage._ancestor)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._issued)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._signature)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._partner)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._origin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._origin, fieldNumber: 1)
      }
      if !_storage._ancestor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ancestor, fieldNumber: 2)
      }
      if let v = _storage._issued {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._partner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_BioprintID, rhs: Bloombox_Identity_Bioprint_BioprintID) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._ancestor != rhs_storage._ancestor {return false}
        if _storage._issued != rhs_storage._issued {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._partner != rhs_storage._partner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Keychain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Keychain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "master"),
    2: .same(proto: "restoration"),
    3: .same(proto: "generation"),
    4: .standard(proto: "last_rotated"),
  ]

  fileprivate class _StorageClass {
    var _master: [Bloombox_Identity_Bioprint_MasterKey] = []
    var _restoration: [Bloombox_Identity_Bioprint_RestorationKey] = []
    var _generation: UInt32 = 0
    var _lastRotated: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _master = source._master
      _restoration = source._restoration
      _generation = source._generation
      _lastRotated = source._lastRotated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._master)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._restoration)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._generation)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._lastRotated)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._master.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._master, fieldNumber: 1)
      }
      if !_storage._restoration.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._restoration, fieldNumber: 2)
      }
      if _storage._generation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._generation, fieldNumber: 3)
      }
      if let v = _storage._lastRotated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Keychain, rhs: Bloombox_Identity_Bioprint_Keychain) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._master != rhs_storage._master {return false}
        if _storage._restoration != rhs_storage._restoration {return false}
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._lastRotated != rhs_storage._lastRotated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_BioprintPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BioprintPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "generation"),
    2: .same(proto: "affinity"),
    3: .same(proto: "preferences"),
  ]

  fileprivate class _StorageClass {
    var _generation: UInt32 = 0
    var _affinity: [Bloombox_Identity_Bioprint_Affinity] = []
    var _preferences: Bloombox_Identity_ConsumerPreferences? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _generation = source._generation
      _affinity = source._affinity
      _preferences = source._preferences
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._generation)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._affinity)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._preferences)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._generation != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._generation, fieldNumber: 1)
      }
      if !_storage._affinity.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._affinity, fieldNumber: 2)
      }
      if let v = _storage._preferences {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_BioprintPayload, rhs: Bloombox_Identity_Bioprint_BioprintPayload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._generation != rhs_storage._generation {return false}
        if _storage._affinity != rhs_storage._affinity {return false}
        if _storage._preferences != rhs_storage._preferences {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_BioprintRevision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BioprintRevision"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "applied"),
    3: .same(proto: "profile"),
  ]

  fileprivate class _StorageClass {
    var _id: Bloombox_Identity_Bioprint_BioprintID? = nil
    var _applied: Opencannabis_Temporal_Instant? = nil
    var _profile: Bloombox_Identity_Bioprint_BioprintPayload? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _applied = source._applied
      _profile = source._profile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._applied)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._profile)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._applied {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_BioprintRevision, rhs: Bloombox_Identity_Bioprint_BioprintRevision) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._applied != rhs_storage._applied {return false}
        if _storage._profile != rhs_storage._profile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Identity_Bioprint_Bioprint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bioprint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "keychain"),
    3: .same(proto: "profile"),
    4: .same(proto: "identification"),
    5: .same(proto: "user"),
    6: .same(proto: "memberships"),
    7: .same(proto: "revision"),
    8: .same(proto: "modified"),
    9: .same(proto: "created"),
  ]

  fileprivate class _StorageClass {
    var _id: Bloombox_Identity_Bioprint_BioprintID? = nil
    var _keychain: Bloombox_Identity_Bioprint_Keychain? = nil
    var _profile: Bloombox_Identity_Bioprint_BioprintPayload? = nil
    var _identification: Bloombox_Identity_ID? = nil
    var _user: Bloombox_Identity_UserKey? = nil
    var _memberships: Dictionary<String,Bloombox_Identity_ConsumerMembership> = [:]
    var _revision: [Bloombox_Identity_Bioprint_BioprintRevision] = []
    var _modified: Opencannabis_Temporal_Instant? = nil
    var _created: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _keychain = source._keychain
      _profile = source._profile
      _identification = source._identification
      _user = source._user
      _memberships = source._memberships
      _revision = source._revision
      _modified = source._modified
      _created = source._created
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._keychain)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._profile)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._identification)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._user)
        case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bloombox_Identity_ConsumerMembership>.self, value: &_storage._memberships)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._revision)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._modified)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._created)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._keychain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._identification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._memberships.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bloombox_Identity_ConsumerMembership>.self, value: _storage._memberships, fieldNumber: 6)
      }
      if !_storage._revision.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._revision, fieldNumber: 7)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Identity_Bioprint_Bioprint, rhs: Bloombox_Identity_Bioprint_Bioprint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._keychain != rhs_storage._keychain {return false}
        if _storage._profile != rhs_storage._profile {return false}
        if _storage._identification != rhs_storage._identification {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._memberships != rhs_storage._memberships {return false}
        if _storage._revision != rhs_storage._revision {return false}
        if _storage._modified != rhs_storage._modified {return false}
        if _storage._created != rhs_storage._created {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
