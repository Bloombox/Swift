// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: marketing/Campaign.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies channels which marketing campaigns may be associated with.
public enum Bloombox_Schema_Marketing_Channel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified, or default, channel type.
  case unspecified // = 0

  /// Email channel type.
  case email // = 1

  /// SMS, or text, channel type.
  case sms // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .email
    case 2: self = .sms
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .email: return 1
    case .sms: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Enumerates the statuses a campaign object may live in.
public enum Bloombox_Schema_Marketing_CampaignStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The campaign draft status is unspecified, or not-yet-written.
  case pending // = 0

  /// The campaign is a draft and has not yet been sent.
  case draft // = 1

  /// The campaign is queued for sending, but has not yet been sent.
  case queued // = 2

  /// The campaign is actively sending.
  case sending // = 3

  /// The campaign is finished.
  case done // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .pending
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .draft
    case 2: self = .queued
    case 3: self = .sending
    case 4: self = .done
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pending: return 0
    case .draft: return 1
    case .queued: return 2
    case .sending: return 3
    case .done: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Tags applied to a campaign to organize/group similar marketing efforts.
public struct Bloombox_Schema_Marketing_CampaignTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for this campaign tag.
  public var id: String = String()

  /// Label, or category, for a campaign.
  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Settings for a given channel.
public struct Bloombox_Schema_Marketing_ChannelSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Channel for which we are specifying settings.
  public var channel: Bloombox_Schema_Marketing_Channel {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  /// Whether this channel is active or not.
  public var active: Bool {
    get {return _storage._active}
    set {_uniqueStorage()._active = newValue}
  }

  /// Settings payload for the specified channel.
  public var settings: OneOf_Settings? {
    get {return _storage._settings}
    set {_uniqueStorage()._settings = newValue}
  }

  /// SMS settings.
  public var sms: Bloombox_Schema_Marketing_ChannelSettings.SMS {
    get {
      if case .sms(let v)? = _storage._settings {return v}
      return Bloombox_Schema_Marketing_ChannelSettings.SMS()
    }
    set {_uniqueStorage()._settings = .sms(newValue)}
  }

  /// Email settings.
  public var email: Bloombox_Schema_Marketing_ChannelSettings.Email {
    get {
      if case .email(let v)? = _storage._settings {return v}
      return Bloombox_Schema_Marketing_ChannelSettings.Email()
    }
    set {_uniqueStorage()._settings = .email(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Settings payload for the specified channel.
  public enum OneOf_Settings: Equatable {
    /// SMS settings.
    case sms(Bloombox_Schema_Marketing_ChannelSettings.SMS)
    /// Email settings.
    case email(Bloombox_Schema_Marketing_ChannelSettings.Email)

    public static func ==(lhs: Bloombox_Schema_Marketing_ChannelSettings.OneOf_Settings, rhs: Bloombox_Schema_Marketing_ChannelSettings.OneOf_Settings) -> Bool {
      switch (lhs, rhs) {
      case (.sms(let l), .sms(let r)): return l == r
      case (.email(let l), .email(let r)): return l == r
      default: return false
      }
    }
  }

  /// SMS-specific settings.
  public struct SMS {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Origin phone number to send the SMS from.
    public var sender: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Email-specific settings.
  public struct Email {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Origin email address to send the email from.
    public var sender: String = String()

    /// Reply-to email address, if different from sender.
    public var replyTo: String = String()

    /// Email addresses to include via CC.
    public var cc: [String] = []

    /// Email addresses to include via BCC.
    public var bcc: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies SMS content for a given ad group.
public struct Bloombox_Schema_Marketing_SMSContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional SMS subject line.
  public var subject: String {
    get {return _storage._subject}
    set {_uniqueStorage()._subject = newValue}
  }

  /// SMS content to send.
  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Attached media item, if applicable.
  public var media: Opencannabis_Media_MediaItem {
    get {return _storage._media ?? Opencannabis_Media_MediaItem()}
    set {_uniqueStorage()._media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {return _storage._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {_storage._media = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies email content for a given ad group.
public struct Bloombox_Schema_Marketing_EmailContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Email subject line.
  public var subject: String = String()

  /// Email content.
  public var content: [Opencannabis_Content_Content] = []

  /// Email attachments.
  public var attachment: [Opencannabis_Media_MediaItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies the actual content of a marketing campaign ad group.
public struct Bloombox_Schema_Marketing_Creative {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the content for a given type.
  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// SMS-specific content.
  public var sms: Bloombox_Schema_Marketing_SMSContent {
    get {
      if case .sms(let v)? = _storage._content {return v}
      return Bloombox_Schema_Marketing_SMSContent()
    }
    set {_uniqueStorage()._content = .sms(newValue)}
  }

  /// Email-specific content.
  public var email: Bloombox_Schema_Marketing_EmailContent {
    get {
      if case .email(let v)? = _storage._content {return v}
      return Bloombox_Schema_Marketing_EmailContent()
    }
    set {_uniqueStorage()._content = .email(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the content for a given type.
  public enum OneOf_Content: Equatable {
    /// SMS-specific content.
    case sms(Bloombox_Schema_Marketing_SMSContent)
    /// Email-specific content.
    case email(Bloombox_Schema_Marketing_EmailContent)

    public static func ==(lhs: Bloombox_Schema_Marketing_Creative.OneOf_Content, rhs: Bloombox_Schema_Marketing_Creative.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.sms(let l), .sms(let r)): return l == r
      case (.email(let l), .email(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies campaign settings for a given channel.
public struct Bloombox_Schema_Marketing_AdGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for this particular ad group.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Key for this ad group's owning campaign.
  public var campaign: Bloombox_Schema_Marketing_CampaignKey {
    get {return _storage._campaign ?? Bloombox_Schema_Marketing_CampaignKey()}
    set {_uniqueStorage()._campaign = newValue}
  }
  /// Returns true if `campaign` has been explicitly set.
  public var hasCampaign: Bool {return _storage._campaign != nil}
  /// Clears the value of `campaign`. Subsequent reads from it will return its default value.
  public mutating func clearCampaign() {_storage._campaign = nil}

  /// Channel for this specification.
  public var channel: Bloombox_Schema_Marketing_Channel {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  /// Attached content/creatives for this ad group.
  public var creative: [Bloombox_Schema_Marketing_Creative] {
    get {return _storage._creative}
    set {_uniqueStorage()._creative = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Marketing campaign targeting parameters/configuration.
public struct Bloombox_Schema_Marketing_CampaignTargeting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only target users matching filters.
  public var strict: Bool = false

  /// Targeting policy payload block.
  public var block: [Bloombox_Schema_Marketing_TargetingPolicy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies the structure of a marketing campaign's unique primary key.
public struct Bloombox_Schema_Marketing_CampaignKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID for the campaign.
  public var id: String = String()

  /// Partner ID for this campaign.
  public var partner: String = String()

  /// Location ID for this campaign.
  public var location: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a single marketing operation, involving outreach and potentially other forms of engagement building, in a
/// concentrated effort towards specific, defined conversion goals.
public struct Bloombox_Schema_Marketing_Campaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique key for this campaign.
  public var key: Bloombox_Schema_Marketing_CampaignKey {
    get {return _storage._key ?? Bloombox_Schema_Marketing_CampaignKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_storage._key = nil}

  /// Name/label for the campaign.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Description for the campaign.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Status of this campaign.
  public var status: Bloombox_Schema_Marketing_CampaignStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Visibility status of this campaign in a location/partner.
  public var live: Bool {
    get {return _storage._live}
    set {_uniqueStorage()._live = newValue}
  }

  /// Campaign audience targeting settings.
  public var targeting: Bloombox_Schema_Marketing_CampaignTargeting {
    get {return _storage._targeting ?? Bloombox_Schema_Marketing_CampaignTargeting()}
    set {_uniqueStorage()._targeting = newValue}
  }
  /// Returns true if `targeting` has been explicitly set.
  public var hasTargeting: Bool {return _storage._targeting != nil}
  /// Clears the value of `targeting`. Subsequent reads from it will return its default value.
  public mutating func clearTargeting() {_storage._targeting = nil}

  /// Distribution/channel settings for this campaign.
  public var channel: [Bloombox_Schema_Marketing_ChannelSettings] {
    get {return _storage._channel}
    set {_uniqueStorage()._channel = newValue}
  }

  /// Tags for this campaign.
  public var tag: [Bloombox_Schema_Marketing_CampaignTag] {
    get {return _storage._tag}
    set {_uniqueStorage()._tag = newValue}
  }

  /// Ad groups attached to this campaign.
  public var group: [Bloombox_Schema_Marketing_AdGroup] {
    get {return _storage._group}
    set {_uniqueStorage()._group = newValue}
  }

  /// Timestamp indicating when this campaign was created.
  public var published: Opencannabis_Temporal_Instant {
    get {return _storage._published ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._published = newValue}
  }
  /// Returns true if `published` has been explicitly set.
  public var hasPublished: Bool {return _storage._published != nil}
  /// Clears the value of `published`. Subsequent reads from it will return its default value.
  public mutating func clearPublished() {_storage._published = nil}

  /// Timestamp indicating when this campaign was created.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_storage._created = nil}

  /// When this campaign was last modified.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_storage._modified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.schema.marketing"

extension Bloombox_Schema_Marketing_Channel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "EMAIL"),
    2: .same(proto: "SMS"),
  ]
}

extension Bloombox_Schema_Marketing_CampaignStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "DRAFT"),
    2: .same(proto: "QUEUED"),
    3: .same(proto: "SENDING"),
    4: .same(proto: "DONE"),
  ]
}

extension Bloombox_Schema_Marketing_CampaignTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_CampaignTag) -> Bool {
    if self.id != other.id {return false}
    if self.label != other.label {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_ChannelSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "active"),
    20: .same(proto: "sms"),
    21: .same(proto: "email"),
  ]

  fileprivate class _StorageClass {
    var _channel: Bloombox_Schema_Marketing_Channel = .unspecified
    var _active: Bool = false
    var _settings: Bloombox_Schema_Marketing_ChannelSettings.OneOf_Settings?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _channel = source._channel
      _active = source._active
      _settings = source._settings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._channel)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._active)
        case 20:
          var v: Bloombox_Schema_Marketing_ChannelSettings.SMS?
          if let current = _storage._settings {
            try decoder.handleConflictingOneOf()
            if case .sms(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._settings = .sms(v)}
        case 21:
          var v: Bloombox_Schema_Marketing_ChannelSettings.Email?
          if let current = _storage._settings {
            try decoder.handleConflictingOneOf()
            if case .email(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._settings = .email(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channel != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._channel, fieldNumber: 1)
      }
      if _storage._active != false {
        try visitor.visitSingularBoolField(value: _storage._active, fieldNumber: 2)
      }
      switch _storage._settings {
      case .sms(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .email(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_ChannelSettings) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._channel != other_storage._channel {return false}
        if _storage._active != other_storage._active {return false}
        if _storage._settings != other_storage._settings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_ChannelSettings.SMS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Marketing_ChannelSettings.protoMessageName + ".SMS"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sender)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_ChannelSettings.SMS) -> Bool {
    if self.sender != other.sender {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_ChannelSettings.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Marketing_ChannelSettings.protoMessageName + ".Email"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "reply_to"),
    3: .same(proto: "cc"),
    4: .same(proto: "bcc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sender)
      case 2: try decoder.decodeSingularStringField(value: &self.replyTo)
      case 3: try decoder.decodeRepeatedStringField(value: &self.cc)
      case 4: try decoder.decodeRepeatedStringField(value: &self.bcc)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.replyTo.isEmpty {
      try visitor.visitSingularStringField(value: self.replyTo, fieldNumber: 2)
    }
    if !self.cc.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cc, fieldNumber: 3)
    }
    if !self.bcc.isEmpty {
      try visitor.visitRepeatedStringField(value: self.bcc, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_ChannelSettings.Email) -> Bool {
    if self.sender != other.sender {return false}
    if self.replyTo != other.replyTo {return false}
    if self.cc != other.cc {return false}
    if self.bcc != other.bcc {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_SMSContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SMSContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .same(proto: "content"),
    3: .same(proto: "media"),
  ]

  fileprivate class _StorageClass {
    var _subject: String = String()
    var _content: String = String()
    var _media: Opencannabis_Media_MediaItem? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _subject = source._subject
      _content = source._content
      _media = source._media
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._subject)
        case 2: try decoder.decodeSingularStringField(value: &_storage._content)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._media)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._subject.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subject, fieldNumber: 1)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 2)
      }
      if let v = _storage._media {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_SMSContent) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._subject != other_storage._subject {return false}
        if _storage._content != other_storage._content {return false}
        if _storage._media != other_storage._media {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_EmailContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .same(proto: "content"),
    3: .same(proto: "attachment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.subject)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.content)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.attachment)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.content, fieldNumber: 2)
    }
    if !self.attachment.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachment, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_EmailContent) -> Bool {
    if self.subject != other.subject {return false}
    if self.content != other.content {return false}
    if self.attachment != other.attachment {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_Creative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Creative"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "sms"),
    11: .same(proto: "email"),
  ]

  fileprivate class _StorageClass {
    var _content: Bloombox_Schema_Marketing_Creative.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 10:
          var v: Bloombox_Schema_Marketing_SMSContent?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .sms(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .sms(v)}
        case 11:
          var v: Bloombox_Schema_Marketing_EmailContent?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .email(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .email(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._content {
      case .sms(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .email(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_Creative) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._content != other_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_AdGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "campaign"),
    3: .same(proto: "channel"),
    4: .same(proto: "creative"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _campaign: Bloombox_Schema_Marketing_CampaignKey? = nil
    var _channel: Bloombox_Schema_Marketing_Channel = .unspecified
    var _creative: [Bloombox_Schema_Marketing_Creative] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _campaign = source._campaign
      _channel = source._channel
      _creative = source._creative
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._campaign)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._channel)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._creative)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._campaign {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._channel != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._channel, fieldNumber: 3)
      }
      if !_storage._creative.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._creative, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_AdGroup) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._campaign != other_storage._campaign {return false}
        if _storage._channel != other_storage._channel {return false}
        if _storage._creative != other_storage._creative {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_CampaignTargeting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignTargeting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strict"),
    2: .same(proto: "block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.strict)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.block)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.strict != false {
      try visitor.visitSingularBoolField(value: self.strict, fieldNumber: 1)
    }
    if !self.block.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.block, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_CampaignTargeting) -> Bool {
    if self.strict != other.strict {return false}
    if self.block != other.block {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_CampaignKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.partner)
      case 3: try decoder.decodeSingularStringField(value: &self.location)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.partner.isEmpty {
      try visitor.visitSingularStringField(value: self.partner, fieldNumber: 2)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_CampaignKey) -> Bool {
    if self.id != other.id {return false}
    if self.partner != other.partner {return false}
    if self.location != other.location {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Marketing_Campaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Campaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "status"),
    5: .same(proto: "live"),
    6: .same(proto: "targeting"),
    7: .same(proto: "channel"),
    8: .same(proto: "tag"),
    9: .same(proto: "group"),
    10: .same(proto: "published"),
    11: .same(proto: "created"),
    12: .same(proto: "modified"),
  ]

  fileprivate class _StorageClass {
    var _key: Bloombox_Schema_Marketing_CampaignKey? = nil
    var _name: String = String()
    var _description_p: String = String()
    var _status: Bloombox_Schema_Marketing_CampaignStatus = .pending
    var _live: Bool = false
    var _targeting: Bloombox_Schema_Marketing_CampaignTargeting? = nil
    var _channel: [Bloombox_Schema_Marketing_ChannelSettings] = []
    var _tag: [Bloombox_Schema_Marketing_CampaignTag] = []
    var _group: [Bloombox_Schema_Marketing_AdGroup] = []
    var _published: Opencannabis_Temporal_Instant? = nil
    var _created: Opencannabis_Temporal_Instant? = nil
    var _modified: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _name = source._name
      _description_p = source._description_p
      _status = source._status
      _live = source._live
      _targeting = source._targeting
      _channel = source._channel
      _tag = source._tag
      _group = source._group
      _published = source._published
      _created = source._created
      _modified = source._modified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._live)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._targeting)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._channel)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._tag)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._group)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._published)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._modified)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if _storage._live != false {
        try visitor.visitSingularBoolField(value: _storage._live, fieldNumber: 5)
      }
      if let v = _storage._targeting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._channel.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._channel, fieldNumber: 7)
      }
      if !_storage._tag.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tag, fieldNumber: 8)
      }
      if !_storage._group.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._group, fieldNumber: 9)
      }
      if let v = _storage._published {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Marketing_Campaign) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._key != other_storage._key {return false}
        if _storage._name != other_storage._name {return false}
        if _storage._description_p != other_storage._description_p {return false}
        if _storage._status != other_storage._status {return false}
        if _storage._live != other_storage._live {return false}
        if _storage._targeting != other_storage._targeting {return false}
        if _storage._channel != other_storage._channel {return false}
        if _storage._tag != other_storage._tag {return false}
        if _storage._group != other_storage._group {return false}
        if _storage._published != other_storage._published {return false}
        if _storage._created != other_storage._created {return false}
        if _storage._modified != other_storage._modified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
