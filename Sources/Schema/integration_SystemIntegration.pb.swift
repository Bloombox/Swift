// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: integration/SystemIntegration.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Provides models which facilitate storage of, or communicate structure or state or configuration of, integration
/// settings and operations. When an integration is triggered, it creates or uses records from this module.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes the specific method invoked for a given integration. This is expected to mean something within the scope of
/// a configurable integration. It is up to invoking code to make sure the selected vendor makes sense for these values.
public struct Bloombox_Integration_IntegrationMethod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// String name for this integration method.
  public var name: String = String()

  /// Enumerated code for this integration method. Vendor-specific.
  public var code: UInt32 = 0

  /// Narrative description of this method's function.
  public var description_p: String = String()

  /// Concrete, vendor-specific method that is being referenced.
  public var method: Bloombox_Integration_IntegrationMethod.OneOf_Method? = nil

  /// Specifies a specific LeafLogix operation that was performed or attempted.
  public var leafLogix: Bloombox_Partner_Integrations_Leaflogix_LeafLogixOperation {
    get {
      if case .leafLogix(let v)? = method {return v}
      return .unknownLeaflogixOperation
    }
    set {method = .leafLogix(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Concrete, vendor-specific method that is being referenced.
  public enum OneOf_Method: Equatable {
    /// Specifies a specific LeafLogix operation that was performed or attempted.
    case leafLogix(Bloombox_Partner_Integrations_Leaflogix_LeafLogixOperation)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Integration_IntegrationMethod.OneOf_Method, rhs: Bloombox_Integration_IntegrationMethod.OneOf_Method) -> Bool {
      switch (lhs, rhs) {
      case (.leafLogix(let l), .leafLogix(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}
}

/// Describes an operation that occurred, will occur, or is occurring, to integrate a system with Bloombox. Generically
/// describes the vendor and method associated with a given invocation of an integration.
public struct Bloombox_Integration_IntegrationOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Third-party partner which this integration is working with.
  public var vendor: Bloombox_Partner_Integrations_IntegrationPartner {
    get {return _storage._vendor}
    set {_uniqueStorage()._vendor = newValue}
  }

  /// Specifies information about the method that was invoked, will be invoked, or is being invoked.
  public var method: Bloombox_Integration_IntegrationMethod {
    get {return _storage._method ?? Bloombox_Integration_IntegrationMethod()}
    set {_uniqueStorage()._method = newValue}
  }
  /// Returns true if `method` has been explicitly set.
  public var hasMethod: Bool {return _storage._method != nil}
  /// Clears the value of `method`. Subsequent reads from it will return its default value.
  public mutating func clearMethod() {_uniqueStorage()._method = nil}

  /// Describes who invoked this method/operation.
  public var invokedBy: OneOf_InvokedBy? {
    get {return _storage._invokedBy}
    set {_uniqueStorage()._invokedBy = newValue}
  }

  /// The method was invoked by the system.
  public var system: Bool {
    get {
      if case .system(let v)? = _storage._invokedBy {return v}
      return false
    }
    set {_uniqueStorage()._invokedBy = .system(newValue)}
  }

  /// The method was invoked by a user at the following key.
  public var user: Bloombox_Identity_UserKey {
    get {
      if case .user(let v)? = _storage._invokedBy {return v}
      return Bloombox_Identity_UserKey()
    }
    set {_uniqueStorage()._invokedBy = .user(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes who invoked this method/operation.
  public enum OneOf_InvokedBy: Equatable {
    /// The method was invoked by the system.
    case system(Bool)
    /// The method was invoked by a user at the following key.
    case user(Bloombox_Identity_UserKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Integration_IntegrationOperation.OneOf_InvokedBy, rhs: Bloombox_Integration_IntegrationOperation.OneOf_InvokedBy) -> Bool {
      switch (lhs, rhs) {
      case (.system(let l), .system(let r)): return l == r
      case (.user(let l), .user(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies information about a particular run of a specific integration. The integration that was invoked, including
/// the providing vendor and specific method, are specified via `operation` / `IntegrationOperation`. As a run moves
/// through states, it should be updated with a transaction each time to reflect the current state of the run.
public struct Bloombox_Integration_IntegrationRun {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes the key for this run, which includes parent and generated ID.
  public var key: Bloombox_Integration_IntegrationRun.RunKey {
    get {return _storage._key ?? Bloombox_Integration_IntegrationRun.RunKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Type of run, which indicates invocation route.
  public var type: Bloombox_Integration_IntegrationRun.RunType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Current status of this integration run.
  public var status: Bloombox_Integration_IntegrationRun.RunStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Live progress for this integration run, as a fraction of 1. Any value over 1 is considered 1.
  public var progress: Double {
    get {return _storage._progress}
    set {_uniqueStorage()._progress = newValue}
  }

  /// Information about the operation being invoked.
  public var operation: Bloombox_Integration_IntegrationOperation {
    get {return _storage._operation ?? Bloombox_Integration_IntegrationOperation()}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  public var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  public mutating func clearOperation() {_uniqueStorage()._operation = nil}

  /// Notes from the run's operation, added by implementing logic.
  public var note: [Bloombox_Integration_IntegrationRun.RunNote] {
    get {return _storage._note}
    set {_uniqueStorage()._note = newValue}
  }

  /// Indicates the test/live disposition of the run.
  public var disposition: OneOf_Disposition? {
    get {return _storage._disposition}
    set {_uniqueStorage()._disposition = newValue}
  }

  /// Indicates that this run was/is a dry-run.
  public var dry: Bool {
    get {
      if case .dry(let v)? = _storage._disposition {return v}
      return false
    }
    set {_uniqueStorage()._disposition = .dry(newValue)}
  }

  /// Indicates that this run was/is a test-run.
  public var test: Bool {
    get {
      if case .test(let v)? = _storage._disposition {return v}
      return false
    }
    set {_uniqueStorage()._disposition = .test(newValue)}
  }

  /// Indicates that this run was/is a live-run.
  public var live: Bool {
    get {
      if case .live(let v)? = _storage._disposition {return v}
      return false
    }
    set {_uniqueStorage()._disposition = .live(newValue)}
  }

  /// Indicates a special integration run for an import or export job.
  public var bulkJob: OneOf_BulkJob? {
    get {return _storage._bulkJob}
    set {_uniqueStorage()._bulkJob = newValue}
  }

  /// Describes an import job attached to this integration run.
  public var `import`: Bloombox_Integration_ImportJob.Key {
    get {
      if case .import(let v)? = _storage._bulkJob {return v}
      return Bloombox_Integration_ImportJob.Key()
    }
    set {_uniqueStorage()._bulkJob = .import(newValue)}
  }

  /// Describes an export job attached to this integration run.
  public var export: Bloombox_Integration_ExportJob.Key {
    get {
      if case .export(let v)? = _storage._bulkJob {return v}
      return Bloombox_Integration_ExportJob.Key()
    }
    set {_uniqueStorage()._bulkJob = .export(newValue)}
  }

  /// Describes when this integration run was originally created.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// Describes when this integration run was scheduled to run, where applicable.
  public var scheduled: Opencannabis_Temporal_Instant {
    get {return _storage._scheduled ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._scheduled = newValue}
  }
  /// Returns true if `scheduled` has been explicitly set.
  public var hasScheduled: Bool {return _storage._scheduled != nil}
  /// Clears the value of `scheduled`. Subsequent reads from it will return its default value.
  public mutating func clearScheduled() {_uniqueStorage()._scheduled = nil}

  /// Describes when this integration was enqueued to run.
  public var enqueued: Opencannabis_Temporal_Instant {
    get {return _storage._enqueued ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._enqueued = newValue}
  }
  /// Returns true if `enqueued` has been explicitly set.
  public var hasEnqueued: Bool {return _storage._enqueued != nil}
  /// Clears the value of `enqueued`. Subsequent reads from it will return its default value.
  public mutating func clearEnqueued() {_uniqueStorage()._enqueued = nil}

  /// Describes when this integration started running.
  public var started: Opencannabis_Temporal_Instant {
    get {return _storage._started ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._started = newValue}
  }
  /// Returns true if `started` has been explicitly set.
  public var hasStarted: Bool {return _storage._started != nil}
  /// Clears the value of `started`. Subsequent reads from it will return its default value.
  public mutating func clearStarted() {_uniqueStorage()._started = nil}

  /// Describes the last time this integration record was updated.
  public var updated: Opencannabis_Temporal_Instant {
    get {return _storage._updated ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  public var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  public mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  /// Describes when this integration run was completed, or when it errored.
  public var completed: Opencannabis_Temporal_Instant {
    get {return _storage._completed ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._completed = newValue}
  }
  /// Returns true if `completed` has been explicitly set.
  public var hasCompleted: Bool {return _storage._completed != nil}
  /// Clears the value of `completed`. Subsequent reads from it will return its default value.
  public mutating func clearCompleted() {_uniqueStorage()._completed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the test/live disposition of the run.
  public enum OneOf_Disposition: Equatable {
    /// Indicates that this run was/is a dry-run.
    case dry(Bool)
    /// Indicates that this run was/is a test-run.
    case test(Bool)
    /// Indicates that this run was/is a live-run.
    case live(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Integration_IntegrationRun.OneOf_Disposition, rhs: Bloombox_Integration_IntegrationRun.OneOf_Disposition) -> Bool {
      switch (lhs, rhs) {
      case (.dry(let l), .dry(let r)): return l == r
      case (.test(let l), .test(let r)): return l == r
      case (.live(let l), .live(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Indicates a special integration run for an import or export job.
  public enum OneOf_BulkJob: Equatable {
    /// Describes an import job attached to this integration run.
    case `import`(Bloombox_Integration_ImportJob.Key)
    /// Describes an export job attached to this integration run.
    case export(Bloombox_Integration_ExportJob.Key)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Integration_IntegrationRun.OneOf_BulkJob, rhs: Bloombox_Integration_IntegrationRun.OneOf_BulkJob) -> Bool {
      switch (lhs, rhs) {
      case (.import(let l), .import(let r)): return l == r
      case (.export(let l), .export(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Enumerates the types of integration runs, which indicates how a given integration run was invoked.
  public enum RunType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Specifies an unknown or unrecognized run type.
    case unknownRunType // = 0

    /// The invocation was scheduled to occur at a regular time, according to settings.
    case scheduled // = 1

    /// The operation was directly invoked by a user via the *Dashboard API*.
    case direct // = 2

    /// The operation was triggered by other events in the system.
    case event // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownRunType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownRunType
      case 1: self = .scheduled
      case 2: self = .direct
      case 3: self = .event
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownRunType: return 0
      case .scheduled: return 1
      case .direct: return 2
      case .event: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Current status for a specific run of a given integration. Updated with a transaction as the run progresses between
  /// each state, the last two of which are considered terminal.
  public enum RunStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default state for an integration run. It has been stored but has not been queued.
    case pending // = 0

    /// The run is scheduled for execution soon.
    case enqueued // = 1

    /// The run has begun executing and will report results soon.
    case inProgress // = 2

    /// The run halted or could not finish because of some terminal error state.
    case error // = 3

    /// The run completed successfully. The integration run may still specify warnings or other occurrences of note.
    case success // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .pending
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .enqueued
      case 2: self = .inProgress
      case 3: self = .error
      case 4: self = .success
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .pending: return 0
      case .enqueued: return 1
      case .inProgress: return 2
      case .error: return 3
      case .success: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Describes a database key for an individual integration run. Integration runs are placed under the scope which they
  /// occur under. So, the parent of this key is either a location key, or a partner key.
  public struct RunKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Generated ID for this integration run.
    public var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    /// Describes the parent, and therefore the scope, of this individual integration run operation.
    public var parent: OneOf_Parent? {
      get {return _storage._parent}
      set {_uniqueStorage()._parent = newValue}
    }

    /// Partner-level scope, partner-level key reference.
    public var partner: Bloombox_Partner_PartnerKey {
      get {
        if case .partner(let v)? = _storage._parent {return v}
        return Bloombox_Partner_PartnerKey()
      }
      set {_uniqueStorage()._parent = .partner(newValue)}
    }

    /// Location-level scope, location-level key reference.
    public var location: Bloombox_Partner_LocationKey {
      get {
        if case .location(let v)? = _storage._parent {return v}
        return Bloombox_Partner_LocationKey()
      }
      set {_uniqueStorage()._parent = .location(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Describes the parent, and therefore the scope, of this individual integration run operation.
    public enum OneOf_Parent: Equatable {
      /// Partner-level scope, partner-level key reference.
      case partner(Bloombox_Partner_PartnerKey)
      /// Location-level scope, location-level key reference.
      case location(Bloombox_Partner_LocationKey)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Integration_IntegrationRun.RunKey.OneOf_Parent, rhs: Bloombox_Integration_IntegrationRun.RunKey.OneOf_Parent) -> Bool {
        switch (lhs, rhs) {
        case (.partner(let l), .partner(let r)): return l == r
        case (.location(let l), .location(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies a generic note included with a run of an integration. These are generally added after-the-fact or as the
  /// integration progresses, by the logic implementing the operation. They can communicate errors and warnings as well
  /// as informational messages.
  public struct RunNote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Order index of this run note.
    public var index: UInt32 = 0

    /// Severity level of this note.
    public var severity: Bloombox_Integration_IntegrationRun.RunNote.NoteSeverity = .info

    /// Vendor-specific error or note type.
    public var type: String = String()

    /// Vendor-specific error or note code.
    public var code: UInt32 = 0

    /// Message describing this note from implementing logic.
    public var message: String = String()

    /// If this is a message of type `ERROR`, indicates that this error killed the entire run.
    public var fatal: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies the severity levels of a given integration run note, attached by the underlying logic to describe some
    /// situation encountered while executing an integration.
    public enum NoteSeverity: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Informational note.
      case info // = 0

      /// Information that is important or may be concerning.
      case warning // = 1

      /// An error was encountered or some illegal or exceptional state.
      case error // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .info
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .info
        case 1: self = .warning
        case 2: self = .error
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .info: return 0
        case .warning: return 1
        case .error: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Bloombox_Integration_IntegrationRun.RunType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Integration_IntegrationRun.RunType] = [
    .unknownRunType,
    .scheduled,
    .direct,
    .event,
  ]
}

extension Bloombox_Integration_IntegrationRun.RunStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Integration_IntegrationRun.RunStatus] = [
    .pending,
    .enqueued,
    .inProgress,
    .error,
    .success,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.integration"

extension Bloombox_Integration_IntegrationMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationMethod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
    3: .same(proto: "description"),
    20: .standard(proto: "leaf_logix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.code)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 20:
        if self.method != nil {try decoder.handleConflictingOneOf()}
        var v: Bloombox_Partner_Integrations_Leaflogix_LeafLogixOperation?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.method = .leafLogix(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if case .leafLogix(let v)? = self.method {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Integration_IntegrationMethod, rhs: Bloombox_Integration_IntegrationMethod) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Integration_IntegrationOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vendor"),
    2: .same(proto: "method"),
    3: .same(proto: "system"),
    4: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _vendor: Bloombox_Partner_Integrations_IntegrationPartner = .internal
    var _method: Bloombox_Integration_IntegrationMethod? = nil
    var _invokedBy: Bloombox_Integration_IntegrationOperation.OneOf_InvokedBy?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _vendor = source._vendor
      _method = source._method
      _invokedBy = source._invokedBy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._vendor)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._method)
        case 3:
          if _storage._invokedBy != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._invokedBy = .system(v)}
        case 4:
          var v: Bloombox_Identity_UserKey?
          if let current = _storage._invokedBy {
            try decoder.handleConflictingOneOf()
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._invokedBy = .user(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._vendor != .internal {
        try visitor.visitSingularEnumField(value: _storage._vendor, fieldNumber: 1)
      }
      if let v = _storage._method {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._invokedBy {
      case .system(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      case .user(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Integration_IntegrationOperation, rhs: Bloombox_Integration_IntegrationOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._vendor != rhs_storage._vendor {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._invokedBy != rhs_storage._invokedBy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Integration_IntegrationRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationRun"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "type"),
    3: .same(proto: "status"),
    4: .same(proto: "progress"),
    5: .same(proto: "operation"),
    6: .same(proto: "note"),
    7: .same(proto: "dry"),
    8: .same(proto: "test"),
    9: .same(proto: "live"),
    10: .same(proto: "import"),
    11: .same(proto: "export"),
    20: .same(proto: "created"),
    21: .same(proto: "scheduled"),
    22: .same(proto: "enqueued"),
    23: .same(proto: "started"),
    24: .same(proto: "updated"),
    25: .same(proto: "completed"),
  ]

  fileprivate class _StorageClass {
    var _key: Bloombox_Integration_IntegrationRun.RunKey? = nil
    var _type: Bloombox_Integration_IntegrationRun.RunType = .unknownRunType
    var _status: Bloombox_Integration_IntegrationRun.RunStatus = .pending
    var _progress: Double = 0
    var _operation: Bloombox_Integration_IntegrationOperation? = nil
    var _note: [Bloombox_Integration_IntegrationRun.RunNote] = []
    var _disposition: Bloombox_Integration_IntegrationRun.OneOf_Disposition?
    var _bulkJob: Bloombox_Integration_IntegrationRun.OneOf_BulkJob?
    var _created: Opencannabis_Temporal_Instant? = nil
    var _scheduled: Opencannabis_Temporal_Instant? = nil
    var _enqueued: Opencannabis_Temporal_Instant? = nil
    var _started: Opencannabis_Temporal_Instant? = nil
    var _updated: Opencannabis_Temporal_Instant? = nil
    var _completed: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _type = source._type
      _status = source._status
      _progress = source._progress
      _operation = source._operation
      _note = source._note
      _disposition = source._disposition
      _bulkJob = source._bulkJob
      _created = source._created
      _scheduled = source._scheduled
      _enqueued = source._enqueued
      _started = source._started
      _updated = source._updated
      _completed = source._completed
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 4: try decoder.decodeSingularDoubleField(value: &_storage._progress)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._operation)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._note)
        case 7:
          if _storage._disposition != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._disposition = .dry(v)}
        case 8:
          if _storage._disposition != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._disposition = .test(v)}
        case 9:
          if _storage._disposition != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._disposition = .live(v)}
        case 10:
          var v: Bloombox_Integration_ImportJob.Key?
          if let current = _storage._bulkJob {
            try decoder.handleConflictingOneOf()
            if case .import(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._bulkJob = .import(v)}
        case 11:
          var v: Bloombox_Integration_ExportJob.Key?
          if let current = _storage._bulkJob {
            try decoder.handleConflictingOneOf()
            if case .export(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._bulkJob = .export(v)}
        case 20: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._scheduled)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._enqueued)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._started)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._updated)
        case 25: try decoder.decodeSingularMessageField(value: &_storage._completed)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .unknownRunType {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      if _storage._progress != 0 {
        try visitor.visitSingularDoubleField(value: _storage._progress, fieldNumber: 4)
      }
      if let v = _storage._operation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._note.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._note, fieldNumber: 6)
      }
      switch _storage._disposition {
      case .dry(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      case .test(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      case .live(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      case nil: break
      }
      switch _storage._bulkJob {
      case .import(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .export(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._scheduled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._enqueued {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._started {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._completed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Integration_IntegrationRun, rhs: Bloombox_Integration_IntegrationRun) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._note != rhs_storage._note {return false}
        if _storage._disposition != rhs_storage._disposition {return false}
        if _storage._bulkJob != rhs_storage._bulkJob {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._scheduled != rhs_storage._scheduled {return false}
        if _storage._enqueued != rhs_storage._enqueued {return false}
        if _storage._started != rhs_storage._started {return false}
        if _storage._updated != rhs_storage._updated {return false}
        if _storage._completed != rhs_storage._completed {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Integration_IntegrationRun.RunType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RUN_TYPE"),
    1: .same(proto: "SCHEDULED"),
    2: .same(proto: "DIRECT"),
    3: .same(proto: "EVENT"),
  ]
}

extension Bloombox_Integration_IntegrationRun.RunStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "ENQUEUED"),
    2: .same(proto: "IN_PROGRESS"),
    3: .same(proto: "ERROR"),
    4: .same(proto: "SUCCESS"),
  ]
}

extension Bloombox_Integration_IntegrationRun.RunKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Integration_IntegrationRun.protoMessageName + ".RunKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "partner"),
    3: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _parent: Bloombox_Integration_IntegrationRun.RunKey.OneOf_Parent?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _parent = source._parent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2:
          var v: Bloombox_Partner_PartnerKey?
          if let current = _storage._parent {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parent = .partner(v)}
        case 3:
          var v: Bloombox_Partner_LocationKey?
          if let current = _storage._parent {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parent = .location(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      switch _storage._parent {
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Integration_IntegrationRun.RunKey, rhs: Bloombox_Integration_IntegrationRun.RunKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._parent != rhs_storage._parent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Integration_IntegrationRun.RunNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Integration_IntegrationRun.protoMessageName + ".RunNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "severity"),
    3: .same(proto: "type"),
    4: .same(proto: "code"),
    5: .same(proto: "message"),
    6: .same(proto: "fatal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.index)
      case 2: try decoder.decodeSingularEnumField(value: &self.severity)
      case 3: try decoder.decodeSingularStringField(value: &self.type)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.code)
      case 5: try decoder.decodeSingularStringField(value: &self.message)
      case 6: try decoder.decodeSingularBoolField(value: &self.fatal)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.severity != .info {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 4)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 5)
    }
    if self.fatal != false {
      try visitor.visitSingularBoolField(value: self.fatal, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Integration_IntegrationRun.RunNote, rhs: Bloombox_Integration_IntegrationRun.RunNote) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.type != rhs.type {return false}
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.fatal != rhs.fatal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Integration_IntegrationRun.RunNote.NoteSeverity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO"),
    1: .same(proto: "WARNING"),
    2: .same(proto: "ERROR"),
  ]
}
