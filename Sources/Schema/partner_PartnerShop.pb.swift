// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: partner/PartnerShop.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Defines shared records that add detail for retail objects.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates available known hours spans, to which a set of hours boundaries and shop status may apply.
public enum Bloombox_Partner_Settings_HoursSpan: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Every day of the week.
  case everyday // = 0

  /// Weekdays only.
  case weekdays // = 1

  /// Weekends only.
  case weekends // = 2

  /// Mondays only.
  case monday // = 3

  /// Tuesdays only.
  case tuesday // = 4

  /// Wednesdays only.
  case wednesday // = 5

  /// Thursdays only.
  case thursday // = 6

  /// Fridays only.
  case friday // = 7

  /// Saturdays only.
  case saturday // = 8

  /// Sundays only.
  case sunday // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .everyday
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .everyday
    case 1: self = .weekdays
    case 2: self = .weekends
    case 3: self = .monday
    case 4: self = .tuesday
    case 5: self = .wednesday
    case 6: self = .thursday
    case 7: self = .friday
    case 8: self = .saturday
    case 9: self = .sunday
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .everyday: return 0
    case .weekdays: return 1
    case .weekends: return 2
    case .monday: return 3
    case .tuesday: return 4
    case .wednesday: return 5
    case .thursday: return 6
    case .friday: return 7
    case .saturday: return 8
    case .sunday: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Partner_Settings_HoursSpan: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Partner_Settings_HoursSpan] = [
    .everyday,
    .weekdays,
    .weekends,
    .monday,
    .tuesday,
    .wednesday,
    .thursday,
    .friday,
    .saturday,
    .sunday,
  ]
}

#endif  // swift(>=4.2)

/// Specifies statuses that an online shop itself may take, where it is either open/closed or only open for pickup or
/// delivery.
public enum Bloombox_Partner_Settings_ShopStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The shop is currently open for business, for both delivery and pickup.
  case `open` // = 0

  /// The shop is currently closed.
  case closed // = 1

  /// The shop is open, but for delivery only.
  case deliveryOnly // = 2

  /// The shop is open, but for pickup only.
  case pickupOnly // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .open
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .closed
    case 2: self = .deliveryOnly
    case 3: self = .pickupOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .open: return 0
    case .closed: return 1
    case .deliveryOnly: return 2
    case .pickupOnly: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Partner_Settings_ShopStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Partner_Settings_ShopStatus] = [
    .open,
    .closed,
    .deliveryOnly,
    .pickupOnly,
  ]
}

#endif  // swift(>=4.2)

/// Specifies an hours point as part of an hours boundary.
public struct Bloombox_Partner_Settings_HoursSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hour of the day, in 24h format.
  public var hour: UInt32 = 0

  /// Minute of the hour. Optional.
  public var minute: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies an hours boundary as part of an hours settings payload.
public struct Bloombox_Partner_Settings_HoursBoundary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Beginning of the hours boundary.
  public var begin: Bloombox_Partner_Settings_HoursSpec {
    get {return _storage._begin ?? Bloombox_Partner_Settings_HoursSpec()}
    set {_uniqueStorage()._begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  public var hasBegin: Bool {return _storage._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  public mutating func clearBegin() {_uniqueStorage()._begin = nil}

  /// End of the hours boundary.
  public var end: Bloombox_Partner_Settings_HoursSpec {
    get {return _storage._end ?? Bloombox_Partner_Settings_HoursSpec()}
    set {_uniqueStorage()._end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return _storage._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {_uniqueStorage()._end = nil}

  /// How this boundary applies - the span of days for this boundary.
  public var span: Bloombox_Partner_Settings_HoursSpan {
    get {return _storage._span}
    set {_uniqueStorage()._span = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies 'regular' hours, that apply when no 'special' hours apply.
public struct Bloombox_Partner_Settings_RegularHoursSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Boundary of this set of hours settings.
  public var bounds: Bloombox_Partner_Settings_HoursBoundary {
    get {return _storage._bounds ?? Bloombox_Partner_Settings_HoursBoundary()}
    set {_uniqueStorage()._bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  public var hasBounds: Bool {return _storage._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  public mutating func clearBounds() {_uniqueStorage()._bounds = nil}

  /// Specifies the policy that should apply during the specified bounds, with regard to the shop's open/closed status.
  public var mode: Bloombox_Partner_Settings_ShopStatus {
    get {return _storage._mode}
    set {_uniqueStorage()._mode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies 'special' hours, such as holidays or one-off days.
public struct Bloombox_Partner_Settings_SpecialHoursSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Boundary of this set of hours settings.
  public var bounds: Bloombox_Partner_Settings_HoursBoundary {
    get {return _storage._bounds ?? Bloombox_Partner_Settings_HoursBoundary()}
    set {_uniqueStorage()._bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  public var hasBounds: Bool {return _storage._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  public mutating func clearBounds() {_uniqueStorage()._bounds = nil}

  /// Specifies the policy that should apply during the specified bounds, with regard to the shop's open/closed status.
  public var mode: Bloombox_Partner_Settings_ShopStatus {
    get {return _storage._mode}
    set {_uniqueStorage()._mode = newValue}
  }

  /// Specifies the date upon which these special hours apply.
  public var date: Opencannabis_Temporal_Date {
    get {return _storage._date ?? Opencannabis_Temporal_Date()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies shop hours that tie together the physical and digital storefront.
public struct Bloombox_Partner_Settings_ShopHoursSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies payloads of regular hours settings for this shop location.
  public var regular: [Bloombox_Partner_Settings_RegularHoursSettings] = []

  /// Specifies payloads of special hours settings for this shop location, mapped to the day they apply.
  public var special: Dictionary<String,Bloombox_Partner_Settings_SpecialHoursSettings> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Flags that indicate the services offered through a particular shop.
public struct Bloombox_Partner_Settings_ShopServiceSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies whether this location supports delivery.
  public var delivery: Bool = false

  /// Specifies whether this location supports express ordering, where a pickup order gets to skip the line.
  public var express: Bool = false

  /// Specifies whether this location supports pickup ordering at all.
  public var pickup: Bool = false

  /// Specifies whether there is a physical storefront for this location.
  public var storefront: Bool = false

  /// Specifies whether this operator supports medical sales.
  public var medical: Bool = false

  /// Specifies whether this operator supports adult-use, or recreational, sales.
  public var adultUse: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.partner.settings"

extension Bloombox_Partner_Settings_HoursSpan: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVERYDAY"),
    1: .same(proto: "WEEKDAYS"),
    2: .same(proto: "WEEKENDS"),
    3: .same(proto: "MONDAY"),
    4: .same(proto: "TUESDAY"),
    5: .same(proto: "WEDNESDAY"),
    6: .same(proto: "THURSDAY"),
    7: .same(proto: "FRIDAY"),
    8: .same(proto: "SATURDAY"),
    9: .same(proto: "SUNDAY"),
  ]
}

extension Bloombox_Partner_Settings_ShopStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN"),
    1: .same(proto: "CLOSED"),
    2: .same(proto: "DELIVERY_ONLY"),
    3: .same(proto: "PICKUP_ONLY"),
  ]
}

extension Bloombox_Partner_Settings_HoursSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoursSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
    2: .same(proto: "minute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.hour)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.minute)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 1)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Partner_Settings_HoursSpec, rhs: Bloombox_Partner_Settings_HoursSpec) -> Bool {
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Partner_Settings_HoursBoundary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoursBoundary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
    2: .same(proto: "end"),
    3: .same(proto: "span"),
  ]

  fileprivate class _StorageClass {
    var _begin: Bloombox_Partner_Settings_HoursSpec? = nil
    var _end: Bloombox_Partner_Settings_HoursSpec? = nil
    var _span: Bloombox_Partner_Settings_HoursSpan = .everyday

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _begin = source._begin
      _end = source._end
      _span = source._span
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._begin)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._end)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._span)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._begin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._end {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._span != .everyday {
        try visitor.visitSingularEnumField(value: _storage._span, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Partner_Settings_HoursBoundary, rhs: Bloombox_Partner_Settings_HoursBoundary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._begin != rhs_storage._begin {return false}
        if _storage._end != rhs_storage._end {return false}
        if _storage._span != rhs_storage._span {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Partner_Settings_RegularHoursSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegularHoursSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bounds"),
    2: .same(proto: "mode"),
  ]

  fileprivate class _StorageClass {
    var _bounds: Bloombox_Partner_Settings_HoursBoundary? = nil
    var _mode: Bloombox_Partner_Settings_ShopStatus = .open

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bounds = source._bounds
      _mode = source._mode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._bounds)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._mode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._bounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._mode != .open {
        try visitor.visitSingularEnumField(value: _storage._mode, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Partner_Settings_RegularHoursSettings, rhs: Bloombox_Partner_Settings_RegularHoursSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bounds != rhs_storage._bounds {return false}
        if _storage._mode != rhs_storage._mode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Partner_Settings_SpecialHoursSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpecialHoursSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bounds"),
    2: .same(proto: "mode"),
    3: .same(proto: "date"),
  ]

  fileprivate class _StorageClass {
    var _bounds: Bloombox_Partner_Settings_HoursBoundary? = nil
    var _mode: Bloombox_Partner_Settings_ShopStatus = .open
    var _date: Opencannabis_Temporal_Date? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bounds = source._bounds
      _mode = source._mode
      _date = source._date
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._bounds)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._mode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._date)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._bounds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._mode != .open {
        try visitor.visitSingularEnumField(value: _storage._mode, fieldNumber: 2)
      }
      if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Partner_Settings_SpecialHoursSettings, rhs: Bloombox_Partner_Settings_SpecialHoursSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bounds != rhs_storage._bounds {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._date != rhs_storage._date {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Partner_Settings_ShopHoursSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShopHoursSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regular"),
    2: .same(proto: "special"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.regular)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bloombox_Partner_Settings_SpecialHoursSettings>.self, value: &self.special)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regular.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regular, fieldNumber: 1)
    }
    if !self.special.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Bloombox_Partner_Settings_SpecialHoursSettings>.self, value: self.special, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Partner_Settings_ShopHoursSettings, rhs: Bloombox_Partner_Settings_ShopHoursSettings) -> Bool {
    if lhs.regular != rhs.regular {return false}
    if lhs.special != rhs.special {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Partner_Settings_ShopServiceSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShopServiceSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delivery"),
    2: .same(proto: "express"),
    3: .same(proto: "pickup"),
    4: .same(proto: "storefront"),
    5: .same(proto: "medical"),
    6: .standard(proto: "adult_use"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.delivery)
      case 2: try decoder.decodeSingularBoolField(value: &self.express)
      case 3: try decoder.decodeSingularBoolField(value: &self.pickup)
      case 4: try decoder.decodeSingularBoolField(value: &self.storefront)
      case 5: try decoder.decodeSingularBoolField(value: &self.medical)
      case 6: try decoder.decodeSingularBoolField(value: &self.adultUse)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.delivery != false {
      try visitor.visitSingularBoolField(value: self.delivery, fieldNumber: 1)
    }
    if self.express != false {
      try visitor.visitSingularBoolField(value: self.express, fieldNumber: 2)
    }
    if self.pickup != false {
      try visitor.visitSingularBoolField(value: self.pickup, fieldNumber: 3)
    }
    if self.storefront != false {
      try visitor.visitSingularBoolField(value: self.storefront, fieldNumber: 4)
    }
    if self.medical != false {
      try visitor.visitSingularBoolField(value: self.medical, fieldNumber: 5)
    }
    if self.adultUse != false {
      try visitor.visitSingularBoolField(value: self.adultUse, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Partner_Settings_ShopServiceSettings, rhs: Bloombox_Partner_Settings_ShopServiceSettings) -> Bool {
    if lhs.delivery != rhs.delivery {return false}
    if lhs.express != rhs.express {return false}
    if lhs.pickup != rhs.pickup {return false}
    if lhs.storefront != rhs.storefront {return false}
    if lhs.medical != rhs.medical {return false}
    if lhs.adultUse != rhs.adultUse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
