// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ledger/Account.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Ledger accounting is defined by the public and private key identity generated by an individual actor. Organizations
/// and persons who transact upon the ledger generate these keys themselves, and so, their identity can be represented
/// by their public key (or, more precisely, the hash of their public key, in most cases).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates special actors on the ledger. These entries are considered system-level accounts, for various purposes,
/// with access in limited capacities.
public enum Bloombox_Ledger_SpecialActor: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Built-in system account.
  case system // = 0

  /// Sandbox system account.
  case sandbox // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .system
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .system
    case 1: self = .sandbox
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .system: return 0
    case .sandbox: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Ledger_SpecialActor: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Ledger_SpecialActor] = [
    .system,
    .sandbox,
  ]
}

#endif  // swift(>=4.2)

/// Certificate data accompanying an actor key. This is a certificate bound to the ECDSA keypair issued in parallel to
/// the actor's ledger key, and certified by the ledger actor CA.
public struct Bloombox_Ledger_ActorCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the certificate.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Serial number of the certificate.
  public var serial: String {
    get {return _storage._serial}
    set {_uniqueStorage()._serial = newValue}
  }

  /// Cryptographic fingerprint of the transmitted certificate data.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  /// Certificate common name.
  public var commonName: String {
    get {return _storage._commonName}
    set {_uniqueStorage()._commonName = newValue}
  }

  /// Certificate issuer name.
  public var issuerName: String {
    get {return _storage._issuerName}
    set {_uniqueStorage()._issuerName = newValue}
  }

  /// Certificate data payload.
  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  /// Raw certificate information, in X509 format.
  public var data: Data {
    get {
      if case .data(let v)? = _storage._payload {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._payload = .data(newValue)}
  }

  /// Base64-encoded certificate data.
  public var encoded: String {
    get {
      if case .encoded(let v)? = _storage._payload {return v}
      return String()
    }
    set {_uniqueStorage()._payload = .encoded(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Certificate data payload.
  public enum OneOf_Payload: Equatable {
    /// Raw certificate information, in X509 format.
    case data(Data)
    /// Base64-encoded certificate data.
    case encoded(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Ledger_ActorCertificate.OneOf_Payload, rhs: Bloombox_Ledger_ActorCertificate.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.data(let l), .data(let r)): return l == r
      case (.encoded(let l), .encoded(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the concept of a ledger "actor," which unifies individuals and organizations under one referential
/// structure, such that either may easily be the basis for a ledger transaction.
public struct Bloombox_Ledger_ActorKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actor: OneOf_Actor? {
    get {return _storage._actor}
    set {_uniqueStorage()._actor = newValue}
  }

  /// Specifies a system account, such as reconciliation or sandbox access.
  public var known: Bloombox_Ledger_SpecialActor {
    get {
      if case .known(let v)? = _storage._actor {return v}
      return .system
    }
    set {_uniqueStorage()._actor = .known(newValue)}
  }

  /// Specifies a user as the identity behind a particular ledger account.
  public var user: Bloombox_Identity_UserKey {
    get {
      if case .user(let v)? = _storage._actor {return v}
      return Bloombox_Identity_UserKey()
    }
    set {_uniqueStorage()._actor = .user(newValue)}
  }

  /// Specifies a partner organization as the identity behind a particular ledger account.
  public var partner: Bloombox_Partner_PartnerKey {
    get {
      if case .partner(let v)? = _storage._actor {return v}
      return Bloombox_Partner_PartnerKey()
    }
    set {_uniqueStorage()._actor = .partner(newValue)}
  }

  /// Specifies a partner location as the identity behind a particular ledger account.
  public var location: Bloombox_Partner_LocationKey {
    get {
      if case .location(let v)? = _storage._actor {return v}
      return Bloombox_Partner_LocationKey()
    }
    set {_uniqueStorage()._actor = .location(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Actor: Equatable {
    /// Specifies a system account, such as reconciliation or sandbox access.
    case known(Bloombox_Ledger_SpecialActor)
    /// Specifies a user as the identity behind a particular ledger account.
    case user(Bloombox_Identity_UserKey)
    /// Specifies a partner organization as the identity behind a particular ledger account.
    case partner(Bloombox_Partner_PartnerKey)
    /// Specifies a partner location as the identity behind a particular ledger account.
    case location(Bloombox_Partner_LocationKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Ledger_ActorKey.OneOf_Actor, rhs: Bloombox_Ledger_ActorKey.OneOf_Actor) -> Bool {
      switch (lhs, rhs) {
      case (.known(let l), .known(let r)): return l == r
      case (.user(let l), .user(let r)): return l == r
      case (.partner(let l), .partner(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the structure of a distributed ledger account, which is usually defined by its public/private keypair. In
/// particular, the computation of UPPER(SHA3-B58(public_key)) is used to identify an account uniquely in public.
/// Separately, a user account may be associated with a concrete identity via the `identity` property.
public struct Bloombox_Ledger_AccountKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account key ID is the computed result of UPPER(SHA3-B58(public_key)).
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Reference to the public/private keypair for this ledger account. In rare cases, the private key may be included
  /// here (the structure supports it), but usually, it's used for the onboard cryptographic hash of the public key.
  public var pair: Opencannabis_Crypto_Keypair {
    get {return _storage._pair ?? Opencannabis_Crypto_Keypair()}
    set {_uniqueStorage()._pair = newValue}
  }
  /// Returns true if `pair` has been explicitly set.
  public var hasPair: Bool {return _storage._pair != nil}
  /// Clears the value of `pair`. Subsequent reads from it will return its default value.
  public mutating func clearPair() {_uniqueStorage()._pair = nil}

  /// Reference to the identity public/private keypair for this actor. Ledger "actors" represent the real-world identity
  /// behind organizations or individuals who execute transactions on the ledger.
  public var identity: Opencannabis_Crypto_Keypair {
    get {return _storage._identity ?? Opencannabis_Crypto_Keypair()}
    set {_uniqueStorage()._identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  public var hasIdentity: Bool {return _storage._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  public mutating func clearIdentity() {_uniqueStorage()._identity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the notion of a concrete identity on the ledger. This is essentially the intersection of two items: 1) key
/// material generated by the actor themselves, and 2) associated identity stored somewhere else, or stored with us.
public struct Bloombox_Ledger_LedgerIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the key material behind this identity. In rare cases, this may include the private key (the structure
  /// supports such behavior), but in most cases only a cryptographic fingerprint of the public key is available.
  public var key: Bloombox_Ledger_AccountKey {
    get {return _storage._key ?? Bloombox_Ledger_AccountKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// The actor key links this particular account key to/from a known actor in the system, be it an organization or an
  /// individual. Actor keys keys may be encrypted.
  public var actor: Bloombox_Ledger_ActorKey {
    get {return _storage._actor ?? Bloombox_Ledger_ActorKey()}
    set {_uniqueStorage()._actor = newValue}
  }
  /// Returns true if `actor` has been explicitly set.
  public var hasActor: Bool {return _storage._actor != nil}
  /// Clears the value of `actor`. Subsequent reads from it will return its default value.
  public mutating func clearActor() {_uniqueStorage()._actor = nil}

  /// Specifies actual backing certificate information, issued by the central ledger PKI CA.
  public var certificate: Bloombox_Ledger_ActorCertificate {
    get {return _storage._certificate ?? Bloombox_Ledger_ActorCertificate()}
    set {_uniqueStorage()._certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return _storage._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {_uniqueStorage()._certificate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a structure that stamps a structure with server-side approval, indicating the subject payload was inspected
/// and cryptographically verified.
public struct Bloombox_Ledger_AssertionTicket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cryptographic fingerprint of the transmitted certificate data.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  /// Timestamp for when this assertion ticket was deemed valid.
  public var issued: Opencannabis_Temporal_Instant {
    get {return _storage._issued ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._issued = newValue}
  }
  /// Returns true if `issued` has been explicitly set.
  public var hasIssued: Bool {return _storage._issued != nil}
  /// Clears the value of `issued`. Subsequent reads from it will return its default value.
  public mutating func clearIssued() {_uniqueStorage()._issued = nil}

  /// Signature from a node key assuring the ticket, encoded in hex.
  public var signature: String {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  /// Key ID of the assuring system node (regular identity reference, i.e. public key hash).
  public var assurer: String {
    get {return _storage._assurer}
    set {_uniqueStorage()._assurer = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Stored record specifying an asserted and certified identity claim on the ledger. Actors are required to register
/// their identity before transacting, by generating a keypair, obtaining a certificate, and binding their key hashes
/// and certificate hash to their object identifier, which is the digest of their ledger public key.
public struct Bloombox_Ledger_IdentityClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account ID is the computed result of UPPER(SHA3-256-B58(public_ledger_key)).
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Specifies the computed result of UPPER(SHA3-256-B58(public_ec_key)).
  public var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// Serial number for the attached actor certificate.
  public var serial: String {
    get {return _storage._serial}
    set {_uniqueStorage()._serial = newValue}
  }

  /// Specifies the computed result of UPPER(SHA3-256-B58(certificate)).
  public var fingerprint: String {
    get {return _storage._fingerprint}
    set {_uniqueStorage()._fingerprint = newValue}
  }

  /// Specifies actual backing certificate information, issued by the central ledger PKI CA.
  public var certificate: Bloombox_Ledger_ActorCertificate {
    get {return _storage._certificate ?? Bloombox_Ledger_ActorCertificate()}
    set {_uniqueStorage()._certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  public var hasCertificate: Bool {return _storage._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  public mutating func clearCertificate() {_uniqueStorage()._certificate = nil}

  /// The actor key links this particular account key to/from a known actor in the system, be it an organization or an
  /// individual. Actor keys keys may be encrypted.
  public var actor: Bloombox_Ledger_ActorKey {
    get {return _storage._actor ?? Bloombox_Ledger_ActorKey()}
    set {_uniqueStorage()._actor = newValue}
  }
  /// Returns true if `actor` has been explicitly set.
  public var hasActor: Bool {return _storage._actor != nil}
  /// Clears the value of `actor`. Subsequent reads from it will return its default value.
  public mutating func clearActor() {_uniqueStorage()._actor = nil}

  /// Assertion ticket, verifying that this was indeed verified by the server upon submission.
  public var assertion: Bloombox_Ledger_AssertionTicket {
    get {return _storage._assertion ?? Bloombox_Ledger_AssertionTicket()}
    set {_uniqueStorage()._assertion = newValue}
  }
  /// Returns true if `assertion` has been explicitly set.
  public var hasAssertion: Bool {return _storage._assertion != nil}
  /// Clears the value of `assertion`. Subsequent reads from it will return its default value.
  public mutating func clearAssertion() {_uniqueStorage()._assertion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.ledger"

extension Bloombox_Ledger_SpecialActor: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYSTEM"),
    1: .same(proto: "SANDBOX"),
  ]
}

extension Bloombox_Ledger_ActorCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActorCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "serial"),
    3: .same(proto: "fingerprint"),
    4: .standard(proto: "common_name"),
    5: .standard(proto: "issuer_name"),
    10: .same(proto: "data"),
    11: .same(proto: "encoded"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _serial: String = String()
    var _fingerprint: Opencannabis_Crypto_Hash? = nil
    var _commonName: String = String()
    var _issuerName: String = String()
    var _payload: Bloombox_Ledger_ActorCertificate.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _serial = source._serial
      _fingerprint = source._fingerprint
      _commonName = source._commonName
      _issuerName = source._issuerName
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._serial)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        case 4: try decoder.decodeSingularStringField(value: &_storage._commonName)
        case 5: try decoder.decodeSingularStringField(value: &_storage._issuerName)
        case 10:
          if _storage._payload != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._payload = .data(v)}
        case 11:
          if _storage._payload != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._payload = .encoded(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._serial.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serial, fieldNumber: 2)
      }
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._commonName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._commonName, fieldNumber: 4)
      }
      if !_storage._issuerName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issuerName, fieldNumber: 5)
      }
      switch _storage._payload {
      case .data(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      case .encoded(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Ledger_ActorCertificate, rhs: Bloombox_Ledger_ActorCertificate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._serial != rhs_storage._serial {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._commonName != rhs_storage._commonName {return false}
        if _storage._issuerName != rhs_storage._issuerName {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Ledger_ActorKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActorKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "known"),
    10: .same(proto: "user"),
    20: .same(proto: "partner"),
    30: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _actor: Bloombox_Ledger_ActorKey.OneOf_Actor?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actor = source._actor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._actor != nil {try decoder.handleConflictingOneOf()}
          var v: Bloombox_Ledger_SpecialActor?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._actor = .known(v)}
        case 10:
          var v: Bloombox_Identity_UserKey?
          if let current = _storage._actor {
            try decoder.handleConflictingOneOf()
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._actor = .user(v)}
        case 20:
          var v: Bloombox_Partner_PartnerKey?
          if let current = _storage._actor {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._actor = .partner(v)}
        case 30:
          var v: Bloombox_Partner_LocationKey?
          if let current = _storage._actor {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._actor = .location(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._actor {
      case .known(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      case .user(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Ledger_ActorKey, rhs: Bloombox_Ledger_ActorKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actor != rhs_storage._actor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Ledger_AccountKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "pair"),
    3: .same(proto: "identity"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _pair: Opencannabis_Crypto_Keypair? = nil
    var _identity: Opencannabis_Crypto_Keypair? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _pair = source._pair
      _identity = source._identity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pair)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._identity)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._pair {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._identity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Ledger_AccountKey, rhs: Bloombox_Ledger_AccountKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._pair != rhs_storage._pair {return false}
        if _storage._identity != rhs_storage._identity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Ledger_LedgerIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LedgerIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "actor"),
    3: .same(proto: "certificate"),
  ]

  fileprivate class _StorageClass {
    var _key: Bloombox_Ledger_AccountKey? = nil
    var _actor: Bloombox_Ledger_ActorKey? = nil
    var _certificate: Bloombox_Ledger_ActorCertificate? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _actor = source._actor
      _certificate = source._certificate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._actor)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._certificate)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._actor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._certificate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Ledger_LedgerIdentity, rhs: Bloombox_Ledger_LedgerIdentity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._actor != rhs_storage._actor {return false}
        if _storage._certificate != rhs_storage._certificate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Ledger_AssertionTicket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssertionTicket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fingerprint"),
    2: .same(proto: "issued"),
    3: .same(proto: "signature"),
    4: .same(proto: "assurer"),
  ]

  fileprivate class _StorageClass {
    var _fingerprint: Opencannabis_Crypto_Hash? = nil
    var _issued: Opencannabis_Temporal_Instant? = nil
    var _signature: String = String()
    var _assurer: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fingerprint = source._fingerprint
      _issued = source._issued
      _signature = source._signature
      _assurer = source._assurer
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._issued)
        case 3: try decoder.decodeSingularStringField(value: &_storage._signature)
        case 4: try decoder.decodeSingularStringField(value: &_storage._assurer)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._issued {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signature, fieldNumber: 3)
      }
      if !_storage._assurer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assurer, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Ledger_AssertionTicket, rhs: Bloombox_Ledger_AssertionTicket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._issued != rhs_storage._issued {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._assurer != rhs_storage._assurer {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Ledger_IdentityClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityClaim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "serial"),
    4: .same(proto: "fingerprint"),
    5: .same(proto: "certificate"),
    6: .same(proto: "actor"),
    7: .same(proto: "assertion"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _key: String = String()
    var _serial: String = String()
    var _fingerprint: String = String()
    var _certificate: Bloombox_Ledger_ActorCertificate? = nil
    var _actor: Bloombox_Ledger_ActorKey? = nil
    var _assertion: Bloombox_Ledger_AssertionTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _key = source._key
      _serial = source._serial
      _fingerprint = source._fingerprint
      _certificate = source._certificate
      _actor = source._actor
      _assertion = source._assertion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._key)
        case 3: try decoder.decodeSingularStringField(value: &_storage._serial)
        case 4: try decoder.decodeSingularStringField(value: &_storage._fingerprint)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._certificate)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._actor)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._assertion)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 2)
      }
      if !_storage._serial.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serial, fieldNumber: 3)
      }
      if !_storage._fingerprint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fingerprint, fieldNumber: 4)
      }
      if let v = _storage._certificate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._actor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._assertion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Ledger_IdentityClaim, rhs: Bloombox_Ledger_IdentityClaim) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._serial != rhs_storage._serial {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._certificate != rhs_storage._certificate {return false}
        if _storage._actor != rhs_storage._actor {return false}
        if _storage._assertion != rhs_storage._assertion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
