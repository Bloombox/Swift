// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloudprint/Common.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Common structures used across retail structures.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates names of printer types in a search request.
public enum Google_Cloudprint_PrinterType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No printer type filter. This is a default backstop value.
  case noPrinterTypeFilter // = 0

  /// Return only printers connected via Google's infrastructure.
  case google // = 1

  /// Return only printers manufactured by HP.
  case hp // = 2

  /// Return only virtual printers that print to Google Drive.
  case drive // = 3

  /// Return only Fedex-integrated Google Cloud Print devices.
  case fedex // = 4

  /// Undocumented.
  case androidChromeSnapshot // = 5

  /// Undocumented.
  case iosChromeSnapshot // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .noPrinterTypeFilter
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPrinterTypeFilter
    case 1: self = .google
    case 2: self = .hp
    case 3: self = .drive
    case 4: self = .fedex
    case 5: self = .androidChromeSnapshot
    case 6: self = .iosChromeSnapshot
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noPrinterTypeFilter: return 0
    case .google: return 1
    case .hp: return 2
    case .drive: return 3
    case .fedex: return 4
    case .androidChromeSnapshot: return 5
    case .iosChromeSnapshot: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloudprint_PrinterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_PrinterType] = [
    .noPrinterTypeFilter,
    .google,
    .hp,
    .drive,
    .fedex,
    .androidChromeSnapshot,
    .iosChromeSnapshot,
  ]
}

#endif  // swift(>=4.2)

/// Enumerates known notification channel types for Google Cloud Print devices.
public enum Google_Cloudprint_NotificationChannel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Backstop default value for an unrecognized notification channel type.
  case unrecognizedChannel // = 0

  /// Notification channel over XMPP.
  case xmppChannel // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unrecognizedChannel
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unrecognizedChannel
    case 1: self = .xmppChannel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unrecognizedChannel: return 0
    case .xmppChannel: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloudprint_NotificationChannel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_NotificationChannel] = [
    .unrecognizedChannel,
    .xmppChannel,
  ]
}

#endif  // swift(>=4.2)

/// Physical model of a printer marker.
public struct Google_Cloudprint_Marker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vendor-provided ID of the marker (required).
  public var vendorID: String {
    get {return _storage._vendorID}
    set {_uniqueStorage()._vendorID = newValue}
  }

  /// Type of marker (required).
  public var type: Google_Cloudprint_Marker.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Color of the marker. Only needed if marker type is INK or TONER.
  public var color: Google_Cloudprint_Marker.Color {
    get {return _storage._color ?? Google_Cloudprint_Marker.Color()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {_uniqueStorage()._color = nil}

  /// Non-localized custom display name of the marker. New CDDs should use custom_display_name_localized instead. It is
  /// required that either custom_display_name or custom_display_name_localized is set if the marker's type is CUSTOM.
  public var customDisplayName: String {
    get {return _storage._customDisplayName}
    set {_uniqueStorage()._customDisplayName = newValue}
  }

  /// Translations of custom display name of the marker.
  /// If not empty, must contain an entry with locale == EN.
  public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] {
    get {return _storage._customDisplayNameLocalized}
    set {_uniqueStorage()._customDisplayNameLocalized = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of types of printer markers.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0
    case toner // = 1
    case ink // = 2
    case staples // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .toner
      case 2: self = .ink
      case 3: self = .staples
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .toner: return 1
      case .ink: return 2
      case .staples: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Message that describes the color of a marker.
  public struct Color {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required.
    public var type: Google_Cloudprint_Marker.Color.TypeEnum = .custom

    /// Non-localized custom display name of the color. New CDDs should use custom_display_name_localized instead. It is
    /// required that either custom_display_name or custom_display_name_localized is set if the color's type is CUSTOM.
    public var customDisplayName: String = String()

    /// Translations of custom display name of the color. If not empty, must contain an entry with locale == EN.
    public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Enumeration of color types of the printer marker.
    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case custom // = 0
      case black // = 1
      case color // = 2
      case cyan // = 3
      case magenta // = 4
      case yellow // = 5
      case lightCyan // = 6
      case lightMagenta // = 7
      case gray // = 8
      case lightGray // = 9
      case pigmentBlack // = 10
      case matteBlack // = 11
      case photoCyan // = 12
      case photoMagenta // = 13
      case photoYellow // = 14
      case photoGray // = 15
      case red // = 16
      case green // = 17
      case blue // = 18
      case UNRECOGNIZED(Int)

      public init() {
        self = .custom
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .custom
        case 1: self = .black
        case 2: self = .color
        case 3: self = .cyan
        case 4: self = .magenta
        case 5: self = .yellow
        case 6: self = .lightCyan
        case 7: self = .lightMagenta
        case 8: self = .gray
        case 9: self = .lightGray
        case 10: self = .pigmentBlack
        case 11: self = .matteBlack
        case 12: self = .photoCyan
        case 13: self = .photoMagenta
        case 14: self = .photoYellow
        case 15: self = .photoGray
        case 16: self = .red
        case 17: self = .green
        case 18: self = .blue
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .custom: return 0
        case .black: return 1
        case .color: return 2
        case .cyan: return 3
        case .magenta: return 4
        case .yellow: return 5
        case .lightCyan: return 6
        case .lightMagenta: return 7
        case .gray: return 8
        case .lightGray: return 9
        case .pigmentBlack: return 10
        case .matteBlack: return 11
        case .photoCyan: return 12
        case .photoMagenta: return 13
        case .photoYellow: return 14
        case .photoGray: return 15
        case .red: return 16
        case .green: return 17
        case .blue: return 18
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloudprint_Marker.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_Marker.TypeEnum] = [
    .custom,
    .toner,
    .ink,
    .staples,
  ]
}

#endif  // swift(>=4.2)

/// Physical model of a printer cover.
public struct Google_Cloudprint_Cover {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vendor-provided ID of the cover (required).
  public var vendorID: String = String()

  /// Type of the cover (required).
  public var type: Google_Cloudprint_Cover.TypeEnum = .custom

  /// Index of the cover.
  public var index: Int64 = 0

  /// Non-localized custom display name of the cover. New CDDs should use custom_display_name_localized instead. It is
  /// required that either custom_display_name or custom_display_name_localized is set if the cover's type is CUSTOM.
  public var customDisplayName: String = String()

  /// Translations of custom display name of the cover. If not empty, must contain an entry with locale == EN.
  public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of cover types.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0
    case door // = 1
    case cover // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .door
      case 2: self = .cover
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .door: return 1
      case .cover: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_Cover.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_Cover.TypeEnum] = [
    .custom,
    .door,
    .cover,
  ]
}

#endif  // swift(>=4.2)

/// Physical model of a media path of a printer. Media paths are the paths through which print media flows.
public struct Google_Cloudprint_MediaPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vendor-provided ID of a media path (required).
  public var vendorID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Flexible capability that can represent range-based, selection-based, or typed-value-based capabilities.
public struct Google_Cloudprint_VendorCapability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the capability. Used in CJT to associate a ticket item with this capability (required).
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Non-localized user-friendly string to represent this capability. New CDDs should use display_name_localized
  /// instead. It is required that either display_name or display_name_localized is set.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Type of this capability (required).
  public var type: Google_Cloudprint_VendorCapability.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Range-based capability definition.
  public var rangeCap: Google_Cloudprint_RangeCapability {
    get {return _storage._rangeCap ?? Google_Cloudprint_RangeCapability()}
    set {_uniqueStorage()._rangeCap = newValue}
  }
  /// Returns true if `rangeCap` has been explicitly set.
  public var hasRangeCap: Bool {return _storage._rangeCap != nil}
  /// Clears the value of `rangeCap`. Subsequent reads from it will return its default value.
  public mutating func clearRangeCap() {_uniqueStorage()._rangeCap = nil}

  /// Selection-based capability definition.
  public var selectCap: Google_Cloudprint_SelectCapability {
    get {return _storage._selectCap ?? Google_Cloudprint_SelectCapability()}
    set {_uniqueStorage()._selectCap = newValue}
  }
  /// Returns true if `selectCap` has been explicitly set.
  public var hasSelectCap: Bool {return _storage._selectCap != nil}
  /// Clears the value of `selectCap`. Subsequent reads from it will return its default value.
  public mutating func clearSelectCap() {_uniqueStorage()._selectCap = nil}

  /// Typed-value-based capability definition.
  public var typedValueCap: Google_Cloudprint_TypedValueCapability {
    get {return _storage._typedValueCap ?? Google_Cloudprint_TypedValueCapability()}
    set {_uniqueStorage()._typedValueCap = newValue}
  }
  /// Returns true if `typedValueCap` has been explicitly set.
  public var hasTypedValueCap: Bool {return _storage._typedValueCap != nil}
  /// Clears the value of `typedValueCap`. Subsequent reads from it will return its default value.
  public mutating func clearTypedValueCap() {_uniqueStorage()._typedValueCap = nil}

  /// Translations of display name of this capability. If not empty, must contain an entry with locale == EN.
  public var displayNameLocalized: [Google_Cloudprint_LocalizedString] {
    get {return _storage._displayNameLocalized}
    set {_uniqueStorage()._displayNameLocalized = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case range // = 0
    case select // = 1
    case dValue // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .range
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .range
      case 1: self = .select
      case 2: self = .dValue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .range: return 0
      case .select: return 1
      case .dValue: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloudprint_VendorCapability.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_VendorCapability.TypeEnum] = [
    .range,
    .select,
    .dValue,
  ]
}

#endif  // swift(>=4.2)

/// Message that stores capability information specific to range-based capabilities.
public struct Google_Cloudprint_RangeCapability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data type of the value of the range capability (required).
  public var valueType: Google_Cloudprint_RangeCapability.ValueType = .float

  public var `default`: String = String()

  public var min: String = String()

  public var max: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ValueType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case float // = 0
    case integer // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .float
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .float
      case 1: self = .integer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .float: return 0
      case .integer: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_RangeCapability.ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_RangeCapability.ValueType] = [
    .float,
    .integer,
  ]
}

#endif  // swift(>=4.2)

/// Selection-based device capability. Allows the user to select one or many of a set of options.
public struct Google_Cloudprint_SelectCapability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of options available for this capability.
  public var option: [Google_Cloudprint_SelectCapability.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A user-selectable option of the vendor capability.
  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A single string that represents the value of this option. This value will be used in the VendorTicketItem.value
    /// field (required).
    public var value: String = String()

    /// Non-localized user-friendly string to represent this option. New CDDs should use display_name_localized instead.
    /// It is required that either display_name or display_name_localized is set.
    public var displayName: String = String()

    /// Whether this option is the default option. Only one option should be
    /// marked as default.
    public var isDefault: Bool = false

    /// Translations of display name of the option. If not empty, must contain an entry with locale == EN.
    public var displayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Message that stores capability information specific to typed-value-based capabilities.
public struct Google_Cloudprint_TypedValueCapability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of data of the typed-value capability (required).
  public var valueType: Google_Cloudprint_TypedValueCapability.ValueType = .boolean

  /// Default value of the typed-value capability.
  public var `default`: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ValueType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case boolean // = 0
    case float // = 1
    case integer // = 2
    case string // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .boolean
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .boolean
      case 1: self = .float
      case 2: self = .integer
      case 3: self = .string
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .boolean: return 0
      case .float: return 1
      case .integer: return 2
      case .string: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_TypedValueCapability.ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_TypedValueCapability.ValueType] = [
    .boolean,
    .float,
    .integer,
    .string,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines the color options available on a device.
public struct Google_Cloudprint_Color {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_Color.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case standardColor // = 0
    case standardMonochrome // = 1
    case customColor // = 2
    case customMonochrome // = 3
    case auto // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .standardColor
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .standardColor
      case 1: self = .standardMonochrome
      case 2: self = .customColor
      case 3: self = .customMonochrome
      case 4: self = .auto
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .standardColor: return 0
      case .standardMonochrome: return 1
      case .customColor: return 2
      case .customMonochrome: return 3
      case .auto: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID to help vendor identify the color option (required for options of type CUSTOM_COLOR and CUSTOM_MONOCHROME).
    public var vendorID: String = String()

    /// Type of color option used in UIs to differentiate color and non-color options (required). Note that there can be
    /// any number of options of type CUSTOM_COLOR and CUSTOM_MONOCHROME, but there should be at most one option of each
    /// of the other types.
    public var type: Google_Cloudprint_Color.TypeEnum = .standardColor

    /// Non-localized user-friendly string that represents this option. New CDDs should use custom_display_name_localized
    /// instead. It is required that either custom_display_name or custom_display_name_localized is set for options of
    /// type CUSTOM_COLOR and CUSTOM_MONOCHROME. Options of each of the other types will have their display name
    /// localized by the server.
    public var customDisplayName: String = String()

    /// Whether this option should be selected by default. Only one option should be set as default.
    public var isDefault: Bool = false

    /// Translations of custom display name of the option. If not empty, must contain an entry with locale == EN.
    public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_Color.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_Color.TypeEnum] = [
    .standardColor,
    .standardMonochrome,
    .customColor,
    .customMonochrome,
    .auto,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines the duplexing options available on a device.
public struct Google_Cloudprint_Duplex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_Duplex.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case noDuplex // = 0
    case longEdge // = 1
    case shortEdge // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .noDuplex
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noDuplex
      case 1: self = .longEdge
      case 2: self = .shortEdge
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noDuplex: return 0
      case .longEdge: return 1
      case .shortEdge: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Google_Cloudprint_Duplex.TypeEnum = .noDuplex

    public var isDefault: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_Duplex.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_Duplex.TypeEnum] = [
    .noDuplex,
    .longEdge,
    .shortEdge,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines the page orientation options available on a device.
public struct Google_Cloudprint_PageOrientation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_PageOrientation.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case portrait // = 0
    case landscape // = 1
    case auto // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .portrait
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .portrait
      case 1: self = .landscape
      case 2: self = .auto
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .portrait: return 0
      case .landscape: return 1
      case .auto: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of page orientation (required).
    public var type: Google_Cloudprint_PageOrientation.TypeEnum = .portrait

    public var isDefault: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_PageOrientation.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_PageOrientation.TypeEnum] = [
    .portrait,
    .landscape,
    .auto,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines a default and maximum value for multiple copies on a device.
public struct Google_Cloudprint_Copies {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `default`: Int32 = 0

  public var max: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Capability that defines the margins available on a device (including a custom one). Margins are measured in microns.
public struct Google_Cloudprint_Margins {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_Margins.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumerates the set of predefined types of margins. Devices should use these types to semantically describe the
  /// margins option. This type will be used for UI purposes only.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case borderless // = 0
    case standard // = 1
    case custom // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .borderless
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .borderless
      case 1: self = .standard
      case 2: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .borderless: return 0
      case .standard: return 1
      case .custom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of margin option (required).
    public var type: Google_Cloudprint_Margins.TypeEnum = .borderless

    /// Top margin of the page (required).
    public var topMicrons: Int32 = 0

    /// Right margin of the page (required).
    public var rightMicrons: Int32 = 0

    /// Bottom margin of the page (required).
    public var bottomMicrons: Int32 = 0

    /// Left margin of the page (required).
    public var leftMicrons: Int32 = 0

    public var isDefault: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_Margins.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_Margins.TypeEnum] = [
    .borderless,
    .standard,
    .custom,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines the 2D image quality levels available on a device.
public struct Google_Cloudprint_Dpi {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_Dpi.Option] = []

  public var minHorizontalDpi: Int32 = 0

  public var maxHorizontalDpi: Int32 = 0

  public var minVerticalDpi: Int32 = 0

  public var maxVerticalDpi: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Horizontal DPI (required).
    public var horizontalDpi: Int32 = 0

    /// Vertical DPI (required).
    public var verticalDpi: Int32 = 0

    public var isDefault: Bool = false

    /// Non-localized custom display name to override the default display name which consists of
    /// "{$horizontal_dpi}x{$vertical_dpi} dpi". New CDDs should use custom_display_name_localized instead.
    public var customDisplayName: String = String()

    /// Vendor-provided ID for the dpi option. Used to disambiguate dpi options that may have the same horizontal and
    /// vertical dpi but a different effect on the printer.
    public var vendorID: String = String()

    /// Translations of custom display name of the option, if empty, "{$horizontal_dpi}x{$vertical_dpi} dpi" will be
    /// used. If not empty, must contain an entry with locale == EN.
    public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Capability that defines the page fitting options available on a device.
public struct Google_Cloudprint_FitToPage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_FitToPage.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of page fitting algorithms. The "page" is defined as the media size minus any given margins.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case noFitting // = 0
    case fitToPage // = 1
    case growToPage // = 2
    case shrinkToPage // = 3
    case fillPage // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .noFitting
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noFitting
      case 1: self = .fitToPage
      case 2: self = .growToPage
      case 3: self = .shrinkToPage
      case 4: self = .fillPage
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noFitting: return 0
      case .fitToPage: return 1
      case .growToPage: return 2
      case .shrinkToPage: return 3
      case .fillPage: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Type of fitting algorithm (required).
    public var type: Google_Cloudprint_FitToPage.TypeEnum = .noFitting

    public var isDefault: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_FitToPage.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_FitToPage.TypeEnum] = [
    .noFitting,
    .fitToPage,
    .growToPage,
    .shrinkToPage,
    .fillPage,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines a default page-range selection on a device.
public struct Google_Cloudprint_PageRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `default`: [Google_Cloudprint_PageRange.Interval] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Interval of pages in the document to print.
  public struct Interval {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Beginning of the interval (inclusive) (required).
    public var start: Int32 = 0

    /// End of the interval (inclusive). If not set, then the interval will include all available pages after start.
    public var end: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Capability that defines the media sizes available on a device.
public struct Google_Cloudprint_MediaSize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var option: [Google_Cloudprint_MediaSize.Option] = []

  public var maxWidthMicrons: Int32 = 0

  public var maxHeightMicrons: Int32 = 0

  public var minWidthMicrons: Int32 = 0

  public var minHeightMicrons: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of media size names. This is used for UI purposes.
  public enum Name: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0

    /// North American standard sheet media names.
    case naIndex3X5 // = 100
    case naPersonal // = 101
    case naMonarch // = 102
    case naNumber9 // = 103
    case naIndex4X6 // = 104
    case naNumber10 // = 105
    case naA2 // = 106
    case naNumber11 // = 107
    case naNumber12 // = 108
    case na5X7 // = 109
    case naIndex5X8 // = 110
    case naNumber14 // = 111
    case naInvoice // = 112
    case naIndex4X6Ext // = 113
    case na6X9 // = 114
    case naC5 // = 115
    case na7X9 // = 116
    case naExecutive // = 117
    case naGovtLetter // = 118
    case naGovtLegal // = 119
    case naQuarto // = 120
    case naLetter // = 121
    case naFanfoldEur // = 122
    case naLetterPlus // = 123
    case naFoolscap // = 124
    case naLegal // = 125
    case naSuperA // = 126
    case na9X11 // = 127
    case naArchA // = 128
    case naLetterExtra // = 129
    case naLegalExtra // = 130
    case na10X11 // = 131
    case na10X13 // = 132
    case na10X14 // = 133
    case na10X15 // = 134
    case na11X12 // = 135
    case naEdp // = 136
    case naFanfoldUs // = 137
    case na11X15 // = 138
    case naLedger // = 139
    case naEurEdp // = 140
    case naArchB // = 141
    case na12X19 // = 142
    case naBPlus // = 143
    case naSuperB // = 144
    case naC // = 145
    case naArchC // = 146
    case naD // = 147
    case naArchD // = 148
    case naAsmeF // = 149
    case naWideFormat // = 150
    case naE // = 151
    case naArchE // = 152
    case naF // = 153

    /// Chinese standard sheet media size names.
    case roc16K // = 200
    case roc8K // = 201
    case prc32K // = 202
    case prc1 // = 203
    case prc2 // = 204
    case prc4 // = 205
    case prc5 // = 206
    case prc8 // = 207
    case prc6 // = 208
    case prc3 // = 209
    case prc16K // = 210
    case prc7 // = 211
    case omJuuroKuKai // = 212
    case omPaKai // = 213
    case omDaiPaKai // = 214
    case prc10 // = 215

    /// ISO standard sheet media size names.
    case isoA10 // = 301
    case isoA9 // = 302
    case isoA8 // = 303
    case isoA7 // = 304
    case isoA6 // = 305
    case isoA5 // = 306
    case isoA5Extra // = 307
    case isoA4 // = 308
    case isoA4Tab // = 309
    case isoA4Extra // = 310
    case isoA3 // = 311
    case isoA4X3 // = 312
    case isoA4X4 // = 313
    case isoA4X5 // = 314
    case isoA4X6 // = 315
    case isoA4X7 // = 316
    case isoA4X8 // = 317
    case isoA4X9 // = 318
    case isoA3Extra // = 319
    case isoA2 // = 320
    case isoA3X3 // = 321
    case isoA3X4 // = 322
    case isoA3X5 // = 323
    case isoA3X6 // = 324
    case isoA3X7 // = 325
    case isoA1 // = 326
    case isoA2X3 // = 327
    case isoA2X4 // = 328
    case isoA2X5 // = 329
    case isoA0 // = 330
    case isoA1X3 // = 331
    case isoA1X4 // = 332
    case iso2A0 // = 333
    case isoA0X3 // = 334
    case isoB10 // = 335
    case isoB9 // = 336
    case isoB8 // = 337
    case isoB7 // = 338
    case isoB6 // = 339
    case isoB6C4 // = 340
    case isoB5 // = 341
    case isoB5Extra // = 342
    case isoB4 // = 343
    case isoB3 // = 344
    case isoB2 // = 345
    case isoB1 // = 346
    case isoB0 // = 347
    case isoC10 // = 348
    case isoC9 // = 349
    case isoC8 // = 350
    case isoC7 // = 351
    case isoC7C6 // = 352
    case isoC6 // = 353
    case isoC6C5 // = 354
    case isoC5 // = 355
    case isoC4 // = 356
    case isoC3 // = 357
    case isoC2 // = 358
    case isoC1 // = 359
    case isoC0 // = 360
    case isoDl // = 361
    case isoRa2 // = 362
    case isoSra2 // = 363
    case isoRa1 // = 364
    case isoSra1 // = 365
    case isoRa0 // = 366
    case isoSra0 // = 367

    /// Japanese standard sheet media size names.
    case jisB10 // = 400
    case jisB9 // = 401
    case jisB8 // = 402
    case jisB7 // = 403
    case jisB6 // = 404
    case jisB5 // = 405
    case jisB4 // = 406
    case jisB3 // = 407
    case jisB2 // = 408
    case jisB1 // = 409
    case jisB0 // = 410
    case jisExec // = 411
    case jpnChou4 // = 412
    case jpnHagaki // = 413
    case jpnYou4 // = 414
    case jpnChou2 // = 415
    case jpnChou3 // = 416
    case jpnOufuku // = 417
    case jpnKahu // = 418
    case jpnKaku2 // = 419

    /// Other metric standard sheet media size names.
    case omSmallPhoto // = 500
    case omItalian // = 501
    case omPostfix // = 502
    case omLargePhoto // = 503
    case omFolio // = 504
    case omFolioSp // = 505
    case omInvite // = 506
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 100: self = .naIndex3X5
      case 101: self = .naPersonal
      case 102: self = .naMonarch
      case 103: self = .naNumber9
      case 104: self = .naIndex4X6
      case 105: self = .naNumber10
      case 106: self = .naA2
      case 107: self = .naNumber11
      case 108: self = .naNumber12
      case 109: self = .na5X7
      case 110: self = .naIndex5X8
      case 111: self = .naNumber14
      case 112: self = .naInvoice
      case 113: self = .naIndex4X6Ext
      case 114: self = .na6X9
      case 115: self = .naC5
      case 116: self = .na7X9
      case 117: self = .naExecutive
      case 118: self = .naGovtLetter
      case 119: self = .naGovtLegal
      case 120: self = .naQuarto
      case 121: self = .naLetter
      case 122: self = .naFanfoldEur
      case 123: self = .naLetterPlus
      case 124: self = .naFoolscap
      case 125: self = .naLegal
      case 126: self = .naSuperA
      case 127: self = .na9X11
      case 128: self = .naArchA
      case 129: self = .naLetterExtra
      case 130: self = .naLegalExtra
      case 131: self = .na10X11
      case 132: self = .na10X13
      case 133: self = .na10X14
      case 134: self = .na10X15
      case 135: self = .na11X12
      case 136: self = .naEdp
      case 137: self = .naFanfoldUs
      case 138: self = .na11X15
      case 139: self = .naLedger
      case 140: self = .naEurEdp
      case 141: self = .naArchB
      case 142: self = .na12X19
      case 143: self = .naBPlus
      case 144: self = .naSuperB
      case 145: self = .naC
      case 146: self = .naArchC
      case 147: self = .naD
      case 148: self = .naArchD
      case 149: self = .naAsmeF
      case 150: self = .naWideFormat
      case 151: self = .naE
      case 152: self = .naArchE
      case 153: self = .naF
      case 200: self = .roc16K
      case 201: self = .roc8K
      case 202: self = .prc32K
      case 203: self = .prc1
      case 204: self = .prc2
      case 205: self = .prc4
      case 206: self = .prc5
      case 207: self = .prc8
      case 208: self = .prc6
      case 209: self = .prc3
      case 210: self = .prc16K
      case 211: self = .prc7
      case 212: self = .omJuuroKuKai
      case 213: self = .omPaKai
      case 214: self = .omDaiPaKai
      case 215: self = .prc10
      case 301: self = .isoA10
      case 302: self = .isoA9
      case 303: self = .isoA8
      case 304: self = .isoA7
      case 305: self = .isoA6
      case 306: self = .isoA5
      case 307: self = .isoA5Extra
      case 308: self = .isoA4
      case 309: self = .isoA4Tab
      case 310: self = .isoA4Extra
      case 311: self = .isoA3
      case 312: self = .isoA4X3
      case 313: self = .isoA4X4
      case 314: self = .isoA4X5
      case 315: self = .isoA4X6
      case 316: self = .isoA4X7
      case 317: self = .isoA4X8
      case 318: self = .isoA4X9
      case 319: self = .isoA3Extra
      case 320: self = .isoA2
      case 321: self = .isoA3X3
      case 322: self = .isoA3X4
      case 323: self = .isoA3X5
      case 324: self = .isoA3X6
      case 325: self = .isoA3X7
      case 326: self = .isoA1
      case 327: self = .isoA2X3
      case 328: self = .isoA2X4
      case 329: self = .isoA2X5
      case 330: self = .isoA0
      case 331: self = .isoA1X3
      case 332: self = .isoA1X4
      case 333: self = .iso2A0
      case 334: self = .isoA0X3
      case 335: self = .isoB10
      case 336: self = .isoB9
      case 337: self = .isoB8
      case 338: self = .isoB7
      case 339: self = .isoB6
      case 340: self = .isoB6C4
      case 341: self = .isoB5
      case 342: self = .isoB5Extra
      case 343: self = .isoB4
      case 344: self = .isoB3
      case 345: self = .isoB2
      case 346: self = .isoB1
      case 347: self = .isoB0
      case 348: self = .isoC10
      case 349: self = .isoC9
      case 350: self = .isoC8
      case 351: self = .isoC7
      case 352: self = .isoC7C6
      case 353: self = .isoC6
      case 354: self = .isoC6C5
      case 355: self = .isoC5
      case 356: self = .isoC4
      case 357: self = .isoC3
      case 358: self = .isoC2
      case 359: self = .isoC1
      case 360: self = .isoC0
      case 361: self = .isoDl
      case 362: self = .isoRa2
      case 363: self = .isoSra2
      case 364: self = .isoRa1
      case 365: self = .isoSra1
      case 366: self = .isoRa0
      case 367: self = .isoSra0
      case 400: self = .jisB10
      case 401: self = .jisB9
      case 402: self = .jisB8
      case 403: self = .jisB7
      case 404: self = .jisB6
      case 405: self = .jisB5
      case 406: self = .jisB4
      case 407: self = .jisB3
      case 408: self = .jisB2
      case 409: self = .jisB1
      case 410: self = .jisB0
      case 411: self = .jisExec
      case 412: self = .jpnChou4
      case 413: self = .jpnHagaki
      case 414: self = .jpnYou4
      case 415: self = .jpnChou2
      case 416: self = .jpnChou3
      case 417: self = .jpnOufuku
      case 418: self = .jpnKahu
      case 419: self = .jpnKaku2
      case 500: self = .omSmallPhoto
      case 501: self = .omItalian
      case 502: self = .omPostfix
      case 503: self = .omLargePhoto
      case 504: self = .omFolio
      case 505: self = .omFolioSp
      case 506: self = .omInvite
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .naIndex3X5: return 100
      case .naPersonal: return 101
      case .naMonarch: return 102
      case .naNumber9: return 103
      case .naIndex4X6: return 104
      case .naNumber10: return 105
      case .naA2: return 106
      case .naNumber11: return 107
      case .naNumber12: return 108
      case .na5X7: return 109
      case .naIndex5X8: return 110
      case .naNumber14: return 111
      case .naInvoice: return 112
      case .naIndex4X6Ext: return 113
      case .na6X9: return 114
      case .naC5: return 115
      case .na7X9: return 116
      case .naExecutive: return 117
      case .naGovtLetter: return 118
      case .naGovtLegal: return 119
      case .naQuarto: return 120
      case .naLetter: return 121
      case .naFanfoldEur: return 122
      case .naLetterPlus: return 123
      case .naFoolscap: return 124
      case .naLegal: return 125
      case .naSuperA: return 126
      case .na9X11: return 127
      case .naArchA: return 128
      case .naLetterExtra: return 129
      case .naLegalExtra: return 130
      case .na10X11: return 131
      case .na10X13: return 132
      case .na10X14: return 133
      case .na10X15: return 134
      case .na11X12: return 135
      case .naEdp: return 136
      case .naFanfoldUs: return 137
      case .na11X15: return 138
      case .naLedger: return 139
      case .naEurEdp: return 140
      case .naArchB: return 141
      case .na12X19: return 142
      case .naBPlus: return 143
      case .naSuperB: return 144
      case .naC: return 145
      case .naArchC: return 146
      case .naD: return 147
      case .naArchD: return 148
      case .naAsmeF: return 149
      case .naWideFormat: return 150
      case .naE: return 151
      case .naArchE: return 152
      case .naF: return 153
      case .roc16K: return 200
      case .roc8K: return 201
      case .prc32K: return 202
      case .prc1: return 203
      case .prc2: return 204
      case .prc4: return 205
      case .prc5: return 206
      case .prc8: return 207
      case .prc6: return 208
      case .prc3: return 209
      case .prc16K: return 210
      case .prc7: return 211
      case .omJuuroKuKai: return 212
      case .omPaKai: return 213
      case .omDaiPaKai: return 214
      case .prc10: return 215
      case .isoA10: return 301
      case .isoA9: return 302
      case .isoA8: return 303
      case .isoA7: return 304
      case .isoA6: return 305
      case .isoA5: return 306
      case .isoA5Extra: return 307
      case .isoA4: return 308
      case .isoA4Tab: return 309
      case .isoA4Extra: return 310
      case .isoA3: return 311
      case .isoA4X3: return 312
      case .isoA4X4: return 313
      case .isoA4X5: return 314
      case .isoA4X6: return 315
      case .isoA4X7: return 316
      case .isoA4X8: return 317
      case .isoA4X9: return 318
      case .isoA3Extra: return 319
      case .isoA2: return 320
      case .isoA3X3: return 321
      case .isoA3X4: return 322
      case .isoA3X5: return 323
      case .isoA3X6: return 324
      case .isoA3X7: return 325
      case .isoA1: return 326
      case .isoA2X3: return 327
      case .isoA2X4: return 328
      case .isoA2X5: return 329
      case .isoA0: return 330
      case .isoA1X3: return 331
      case .isoA1X4: return 332
      case .iso2A0: return 333
      case .isoA0X3: return 334
      case .isoB10: return 335
      case .isoB9: return 336
      case .isoB8: return 337
      case .isoB7: return 338
      case .isoB6: return 339
      case .isoB6C4: return 340
      case .isoB5: return 341
      case .isoB5Extra: return 342
      case .isoB4: return 343
      case .isoB3: return 344
      case .isoB2: return 345
      case .isoB1: return 346
      case .isoB0: return 347
      case .isoC10: return 348
      case .isoC9: return 349
      case .isoC8: return 350
      case .isoC7: return 351
      case .isoC7C6: return 352
      case .isoC6: return 353
      case .isoC6C5: return 354
      case .isoC5: return 355
      case .isoC4: return 356
      case .isoC3: return 357
      case .isoC2: return 358
      case .isoC1: return 359
      case .isoC0: return 360
      case .isoDl: return 361
      case .isoRa2: return 362
      case .isoSra2: return 363
      case .isoRa1: return 364
      case .isoSra1: return 365
      case .isoRa0: return 366
      case .isoSra0: return 367
      case .jisB10: return 400
      case .jisB9: return 401
      case .jisB8: return 402
      case .jisB7: return 403
      case .jisB6: return 404
      case .jisB5: return 405
      case .jisB4: return 406
      case .jisB3: return 407
      case .jisB2: return 408
      case .jisB1: return 409
      case .jisB0: return 410
      case .jisExec: return 411
      case .jpnChou4: return 412
      case .jpnHagaki: return 413
      case .jpnYou4: return 414
      case .jpnChou2: return 415
      case .jpnChou3: return 416
      case .jpnOufuku: return 417
      case .jpnKahu: return 418
      case .jpnKaku2: return 419
      case .omSmallPhoto: return 500
      case .omItalian: return 501
      case .omPostfix: return 502
      case .omLargePhoto: return 503
      case .omFolio: return 504
      case .omFolioSp: return 505
      case .omInvite: return 506
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: Google_Cloudprint_MediaSize.Name = .custom

    /// Both of the fields ("width_microns" and "height_microns") are required if "is_continuous_feed" is set to false.
    /// If "is_continuous_feed" is set to true only one of these fields is required.
    public var widthMicrons: Int32 = 0

    public var heightMicrons: Int32 = 0

    public var isContinuousFeed: Bool = false

    public var isDefault: Bool = false

    /// Non-localized user-friendly string that represents this option. New CDDs should use custom_display_name_localized
    /// instead. It is required that either custom_display_name or custom_display_name_localized is set for options whose
    /// "name" field is CUSTOM.
    public var customDisplayName: String = String()

    /// Vendor-provided ID for the media size option. Used to disambiguate media sizes that may have the same width and
    /// height but a different effect on the printer.
    public var vendorID: String = String()

    /// Translations of custom display name of the option. If not empty, must contain an entry with locale == EN.
    public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_MediaSize.Name: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_MediaSize.Name] = [
    .custom,
    .naIndex3X5,
    .naPersonal,
    .naMonarch,
    .naNumber9,
    .naIndex4X6,
    .naNumber10,
    .naA2,
    .naNumber11,
    .naNumber12,
    .na5X7,
    .naIndex5X8,
    .naNumber14,
    .naInvoice,
    .naIndex4X6Ext,
    .na6X9,
    .naC5,
    .na7X9,
    .naExecutive,
    .naGovtLetter,
    .naGovtLegal,
    .naQuarto,
    .naLetter,
    .naFanfoldEur,
    .naLetterPlus,
    .naFoolscap,
    .naLegal,
    .naSuperA,
    .na9X11,
    .naArchA,
    .naLetterExtra,
    .naLegalExtra,
    .na10X11,
    .na10X13,
    .na10X14,
    .na10X15,
    .na11X12,
    .naEdp,
    .naFanfoldUs,
    .na11X15,
    .naLedger,
    .naEurEdp,
    .naArchB,
    .na12X19,
    .naBPlus,
    .naSuperB,
    .naC,
    .naArchC,
    .naD,
    .naArchD,
    .naAsmeF,
    .naWideFormat,
    .naE,
    .naArchE,
    .naF,
    .roc16K,
    .roc8K,
    .prc32K,
    .prc1,
    .prc2,
    .prc4,
    .prc5,
    .prc8,
    .prc6,
    .prc3,
    .prc16K,
    .prc7,
    .omJuuroKuKai,
    .omPaKai,
    .omDaiPaKai,
    .prc10,
    .isoA10,
    .isoA9,
    .isoA8,
    .isoA7,
    .isoA6,
    .isoA5,
    .isoA5Extra,
    .isoA4,
    .isoA4Tab,
    .isoA4Extra,
    .isoA3,
    .isoA4X3,
    .isoA4X4,
    .isoA4X5,
    .isoA4X6,
    .isoA4X7,
    .isoA4X8,
    .isoA4X9,
    .isoA3Extra,
    .isoA2,
    .isoA3X3,
    .isoA3X4,
    .isoA3X5,
    .isoA3X6,
    .isoA3X7,
    .isoA1,
    .isoA2X3,
    .isoA2X4,
    .isoA2X5,
    .isoA0,
    .isoA1X3,
    .isoA1X4,
    .iso2A0,
    .isoA0X3,
    .isoB10,
    .isoB9,
    .isoB8,
    .isoB7,
    .isoB6,
    .isoB6C4,
    .isoB5,
    .isoB5Extra,
    .isoB4,
    .isoB3,
    .isoB2,
    .isoB1,
    .isoB0,
    .isoC10,
    .isoC9,
    .isoC8,
    .isoC7,
    .isoC7C6,
    .isoC6,
    .isoC6C5,
    .isoC5,
    .isoC4,
    .isoC3,
    .isoC2,
    .isoC1,
    .isoC0,
    .isoDl,
    .isoRa2,
    .isoSra2,
    .isoRa1,
    .isoSra1,
    .isoRa0,
    .isoSra0,
    .jisB10,
    .jisB9,
    .jisB8,
    .jisB7,
    .jisB6,
    .jisB5,
    .jisB4,
    .jisB3,
    .jisB2,
    .jisB1,
    .jisB0,
    .jisExec,
    .jpnChou4,
    .jpnHagaki,
    .jpnYou4,
    .jpnChou2,
    .jpnChou3,
    .jpnOufuku,
    .jpnKahu,
    .jpnKaku2,
    .omSmallPhoto,
    .omItalian,
    .omPostfix,
    .omLargePhoto,
    .omFolio,
    .omFolioSp,
    .omInvite,
  ]
}

#endif  // swift(>=4.2)

/// Capability that defines the default collation setting on a device.
public struct Google_Cloudprint_Collate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `default`: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Capability that defines the default reverse-printing-order setting on a device.
public struct Google_Cloudprint_ReverseOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `default`: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A localized human-readable string translated to a specific locale. It is recommended to include translations of
/// custom strings only for locales for which significant use of the device can be expected. If the translation of a
/// custom string for a user's language and country (e.g. ZH_TW) is not present, GCP will display the translation for the
/// base language (e.g. ZH). If neither translation is present, the translation for EN (which is required in every list
/// of localized strings) will be displayed.
public struct Google_Cloudprint_LocalizedString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Locale that the string is translated to (required).
  public var locale: Google_Cloudprint_LocalizedString.Locale = .af

  /// Translated content of the string (required).
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Locale: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case af // = 0
    case am // = 1
    case ar // = 2
    case arXb // = 3
    case bg // = 4
    case bn // = 5
    case ca // = 6
    case cs // = 7
    case cy // = 8
    case da // = 9
    case de // = 10
    case deAt // = 11
    case deCh // = 12
    case el // = 13
    case en // = 14
    case enGb // = 15
    case enIe // = 16
    case enIn // = 17
    case enSg // = 18
    case enXa // = 19
    case enXc // = 20
    case enZa // = 21
    case es // = 22
    case es419 // = 23
    case esAr // = 24
    case esBo // = 25
    case esCl // = 26
    case esCo // = 27
    case esCr // = 28
    case esDo // = 29
    case esEc // = 30
    case esGt // = 31
    case esHn // = 32
    case esMx // = 33
    case esNi // = 34
    case esPa // = 35
    case esPe // = 36
    case esPr // = 37
    case esPy // = 38
    case esSv // = 39
    case esUs // = 40
    case esUy // = 41
    case esVe // = 42
    case et // = 43
    case eu // = 44
    case fa // = 45
    case fi // = 46
    case fr // = 47
    case frCa // = 48
    case frCh // = 49
    case gl // = 50
    case gu // = 51
    case he // = 52
    case hi // = 53
    case hr // = 54
    case hu // = 55
    case hy // = 56
    case id // = 57
    case `in` // = 58
    case it // = 59
    case ja // = 60
    case ka // = 61
    case km // = 62
    case kn // = 63
    case ko // = 64
    case ln // = 65
    case lo // = 66
    case lt // = 67
    case lv // = 68
    case ml // = 69
    case mo // = 70
    case mr // = 71
    case ms // = 72
    case nb // = 73
    case ne // = 74
    case nl // = 75
    case no // = 76
    case pl // = 77
    case pt // = 78
    case ptBr // = 79
    case ptPt // = 80
    case rm // = 81
    case ro // = 82
    case ru // = 83
    case sk // = 84
    case sl // = 85
    case sr // = 86
    case srLatn // = 87
    case sv // = 88
    case sw // = 89
    case ta // = 90
    case te // = 91
    case th // = 92
    case tl // = 93
    case tr // = 94
    case uk // = 95
    case ur // = 96
    case vi // = 97
    case zh // = 98
    case zhCn // = 99
    case zhHk // = 100
    case zhTw // = 101
    case zu // = 102
    case UNRECOGNIZED(Int)

    public init() {
      self = .af
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .af
      case 1: self = .am
      case 2: self = .ar
      case 3: self = .arXb
      case 4: self = .bg
      case 5: self = .bn
      case 6: self = .ca
      case 7: self = .cs
      case 8: self = .cy
      case 9: self = .da
      case 10: self = .de
      case 11: self = .deAt
      case 12: self = .deCh
      case 13: self = .el
      case 14: self = .en
      case 15: self = .enGb
      case 16: self = .enIe
      case 17: self = .enIn
      case 18: self = .enSg
      case 19: self = .enXa
      case 20: self = .enXc
      case 21: self = .enZa
      case 22: self = .es
      case 23: self = .es419
      case 24: self = .esAr
      case 25: self = .esBo
      case 26: self = .esCl
      case 27: self = .esCo
      case 28: self = .esCr
      case 29: self = .esDo
      case 30: self = .esEc
      case 31: self = .esGt
      case 32: self = .esHn
      case 33: self = .esMx
      case 34: self = .esNi
      case 35: self = .esPa
      case 36: self = .esPe
      case 37: self = .esPr
      case 38: self = .esPy
      case 39: self = .esSv
      case 40: self = .esUs
      case 41: self = .esUy
      case 42: self = .esVe
      case 43: self = .et
      case 44: self = .eu
      case 45: self = .fa
      case 46: self = .fi
      case 47: self = .fr
      case 48: self = .frCa
      case 49: self = .frCh
      case 50: self = .gl
      case 51: self = .gu
      case 52: self = .he
      case 53: self = .hi
      case 54: self = .hr
      case 55: self = .hu
      case 56: self = .hy
      case 57: self = .id
      case 58: self = .in
      case 59: self = .it
      case 60: self = .ja
      case 61: self = .ka
      case 62: self = .km
      case 63: self = .kn
      case 64: self = .ko
      case 65: self = .ln
      case 66: self = .lo
      case 67: self = .lt
      case 68: self = .lv
      case 69: self = .ml
      case 70: self = .mo
      case 71: self = .mr
      case 72: self = .ms
      case 73: self = .nb
      case 74: self = .ne
      case 75: self = .nl
      case 76: self = .no
      case 77: self = .pl
      case 78: self = .pt
      case 79: self = .ptBr
      case 80: self = .ptPt
      case 81: self = .rm
      case 82: self = .ro
      case 83: self = .ru
      case 84: self = .sk
      case 85: self = .sl
      case 86: self = .sr
      case 87: self = .srLatn
      case 88: self = .sv
      case 89: self = .sw
      case 90: self = .ta
      case 91: self = .te
      case 92: self = .th
      case 93: self = .tl
      case 94: self = .tr
      case 95: self = .uk
      case 96: self = .ur
      case 97: self = .vi
      case 98: self = .zh
      case 99: self = .zhCn
      case 100: self = .zhHk
      case 101: self = .zhTw
      case 102: self = .zu
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .af: return 0
      case .am: return 1
      case .ar: return 2
      case .arXb: return 3
      case .bg: return 4
      case .bn: return 5
      case .ca: return 6
      case .cs: return 7
      case .cy: return 8
      case .da: return 9
      case .de: return 10
      case .deAt: return 11
      case .deCh: return 12
      case .el: return 13
      case .en: return 14
      case .enGb: return 15
      case .enIe: return 16
      case .enIn: return 17
      case .enSg: return 18
      case .enXa: return 19
      case .enXc: return 20
      case .enZa: return 21
      case .es: return 22
      case .es419: return 23
      case .esAr: return 24
      case .esBo: return 25
      case .esCl: return 26
      case .esCo: return 27
      case .esCr: return 28
      case .esDo: return 29
      case .esEc: return 30
      case .esGt: return 31
      case .esHn: return 32
      case .esMx: return 33
      case .esNi: return 34
      case .esPa: return 35
      case .esPe: return 36
      case .esPr: return 37
      case .esPy: return 38
      case .esSv: return 39
      case .esUs: return 40
      case .esUy: return 41
      case .esVe: return 42
      case .et: return 43
      case .eu: return 44
      case .fa: return 45
      case .fi: return 46
      case .fr: return 47
      case .frCa: return 48
      case .frCh: return 49
      case .gl: return 50
      case .gu: return 51
      case .he: return 52
      case .hi: return 53
      case .hr: return 54
      case .hu: return 55
      case .hy: return 56
      case .id: return 57
      case .in: return 58
      case .it: return 59
      case .ja: return 60
      case .ka: return 61
      case .km: return 62
      case .kn: return 63
      case .ko: return 64
      case .ln: return 65
      case .lo: return 66
      case .lt: return 67
      case .lv: return 68
      case .ml: return 69
      case .mo: return 70
      case .mr: return 71
      case .ms: return 72
      case .nb: return 73
      case .ne: return 74
      case .nl: return 75
      case .no: return 76
      case .pl: return 77
      case .pt: return 78
      case .ptBr: return 79
      case .ptPt: return 80
      case .rm: return 81
      case .ro: return 82
      case .ru: return 83
      case .sk: return 84
      case .sl: return 85
      case .sr: return 86
      case .srLatn: return 87
      case .sv: return 88
      case .sw: return 89
      case .ta: return 90
      case .te: return 91
      case .th: return 92
      case .tl: return 93
      case .tr: return 94
      case .uk: return 95
      case .ur: return 96
      case .vi: return 97
      case .zh: return 98
      case .zhCn: return 99
      case .zhHk: return 100
      case .zhTw: return 101
      case .zu: return 102
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_LocalizedString.Locale: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_LocalizedString.Locale] = [
    .af,
    .am,
    .ar,
    .arXb,
    .bg,
    .bn,
    .ca,
    .cs,
    .cy,
    .da,
    .de,
    .deAt,
    .deCh,
    .el,
    .en,
    .enGb,
    .enIe,
    .enIn,
    .enSg,
    .enXa,
    .enXc,
    .enZa,
    .es,
    .es419,
    .esAr,
    .esBo,
    .esCl,
    .esCo,
    .esCr,
    .esDo,
    .esEc,
    .esGt,
    .esHn,
    .esMx,
    .esNi,
    .esPa,
    .esPe,
    .esPr,
    .esPy,
    .esSv,
    .esUs,
    .esUy,
    .esVe,
    .et,
    .eu,
    .fa,
    .fi,
    .fr,
    .frCa,
    .frCh,
    .gl,
    .gu,
    .he,
    .hi,
    .hr,
    .hu,
    .hy,
    .id,
    .in,
    .it,
    .ja,
    .ka,
    .km,
    .kn,
    .ko,
    .ln,
    .lo,
    .lt,
    .lv,
    .ml,
    .mo,
    .mr,
    .ms,
    .nb,
    .ne,
    .nl,
    .no,
    .pl,
    .pt,
    .ptBr,
    .ptPt,
    .rm,
    .ro,
    .ru,
    .sk,
    .sl,
    .sr,
    .srLatn,
    .sv,
    .sw,
    .ta,
    .te,
    .th,
    .tl,
    .tr,
    .uk,
    .ur,
    .vi,
    .zh,
    .zhCn,
    .zhHk,
    .zhTw,
    .zu,
  ]
}

#endif  // swift(>=4.2)

/// Property that defines what content types the printer can print natively.
public struct Google_Cloudprint_SupportedContentType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Content type (e.g. "image/png" or "application/pdf"). Use */* if your printer supports all formats (required).
  public var contentType: String = String()

  /// Minimum supported version of the content type if applicable (e.g. "1.5").
  public var minVersion: String = String()

  /// Maximum supported version of the content type if applicable (e.g. "1.5").
  public var maxVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Property that defines what speeds (in pages per minute) the printer can operate at.
public struct Google_Cloudprint_PrintingSpeed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Speeds that the printer can operate at.
  public var option: [Google_Cloudprint_PrintingSpeed.Option] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Available speed of the printer.
  ///
  /// Specify settings that are associated with the given speed. If a setting is left unset, then it will be assumed that
  /// the speed is independent of that setting. For example, the following Option:
  ///
  ///   {
  ///     "speed_ppm": 5.5,
  ///     "color_type": ["STANDARD_MONOCHROME"],
  ///     "media_size_name": ["NA_LETTER", "ISO_A4"]
  ///   }
  ///
  /// indicates that the printer prints at 5.5 pages per minute when printing in STANDARD_MONOCHROME in either NA_LETTER
  /// or ISO_A4 paper sizes.
  public struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Speed measured in pages per minute (required).
    public var speedPpm: Float = 0

    /// Types of color settings that operate at this speed.
    public var colorType: [Google_Cloudprint_Color.TypeEnum] = []

    /// Names of media sizes that operate at this speed.
    public var mediaSizeName: [Google_Cloudprint_MediaSize.Name] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Configuration of how printer should receive PWG raster images.
public struct Google_Cloudprint_PwgRasterConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resolutions (in DPI) of the pages that the printer supports in PWG-raster format. The resolution MUST be supported
  /// for every page media supported by the printer. (Same as PwgRasterDocumentResolutionSupported PWG-raster semantic
  /// model element.) This field is strongly recommended, as it helps GCP to decide which resolutions are supported by
  /// the printer for PWG-raster documents if it has to downscale the document to a lower resolution.
  ///
  /// This list can be a subset of the full set of resolutions supported by the printer (in formats different from
  /// PWG-raster, e.g. PDF), but it MUST include an NxN DPI resolution where N <= 360 and N evenly divides all
  /// resolutions supported by the printer. A resolution NxN where N >= 600 (possibly 600 or 720) is also strongly
  /// recommended.
  ///
  /// GCP will generate PWG-raster pages not necessarily at the resolution reported in the ticket, but the actual DPIs of
  /// the page (horizontal and vertical) will always perfectly divide the corresponding values reported in the ticket.
  public var documentResolutionSupported: [Google_Cloudprint_PwgRasterConfig.Resolution] = []

  /// List of PWG-raster document types (in terms of color space and bits per color) supported by the printer. Color
  /// printers MUST support SRGB_8 and possibly SGRAY_8. Monochrome printers must support either SRGB_8 or SGRAY_8.
  /// However, any printer that doesn't support SGRAY_8 must be able to perform conversion from RGB to grayscale if it
  /// receives a PWG-raster document in SRGB, and the print job ticket specifies monochrome printing.
  ///
  /// This field is strongly recommended, and we recommend including all types supported by the printer, as GCP may
  /// start serving more document types in the future.
  public var documentTypeSupported: [Google_Cloudprint_PwgRasterConfig.PwgDocumentTypeSupported] = []

  /// Same as PwgRasterDocumentSheetBack PWG-raster semantic model element. Default value is ROTATED.
  public var documentSheetBack: Google_Cloudprint_PwgRasterConfig.DocumentSheetBack = .normal

  /// Instructs GCP that the printer wants to print pages from the last to the first. In that case GCP will stream
  /// PWG-raster pages in that order.
  public var reverseOrderStreaming: Bool = false

  /// Instructs GCP that the printer prefers receiving pages rotated 180 degrees. This rotation is in addition to
  /// possible additional rotations of even pages based on document_sheet_back in case of duplexing.
  public var rotateAllPages: Bool = false

  /// [Deprecated and only partially supported. Please use the other fields of PwgRasterConfig. Out of all possible
  /// transformations GCP will only support rotating all pages, but for that we strongly recommend using the
  /// rotate_all_pages boolean field instead.] What transformations to apply to pages in the print job.
  public var transformation: [Google_Cloudprint_PwgRasterConfig.Transformation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes which transformation needs to be applied to back pages duplexing in order to have them printed properly.
  /// The value mainly depends on how duplexing works on the printer, and the actual effect depends on which duplexing is
  /// specified in the ticket.
  public enum DocumentSheetBack: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No special treatment for back pages (same as front page).
    case normal // = 0

    /// Back pages are rotated 180 degrees if the document is portrait (TwoSidedLongEdge duplexing).
    case rotated // = 1

    /// Back pages are rotated 180 degrees if the document is landscape (TwoSidedShortEdge duplexing, opposite of
    /// ROTATED).
    case manualTumble // = 2

    /// Page is flipped upside-down if portrait (TwoSidedLongEdge duplexing), left-right if landscape (TwoSidedShortEdge
    /// duplexing).
    case flipped // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .rotated
      case 2: self = .manualTumble
      case 3: self = .flipped
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .rotated: return 1
      case .manualTumble: return 2
      case .flipped: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// PWG-raster document types (in terms of color space and bits per color). This list is based on the PWG-raster specs
  /// of March 14, 2012, and it will be extended without notice if new types are added to newer versions of the specs. If
  /// a new type is not accepted by GCP capability parser please inform the GCP team. (This doesn't mean that GCP will
  /// start sending documents of the new kind.)
  ///
  /// The string names are identical to the keyword attribute values in PWG-raster documentation, except they are
  /// uppercase, and dashes are replaced by underscores.
  public enum PwgDocumentTypeSupported: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecifiedPwgDocumentType // = 0
    case black1 // = 1
    case sgray1 // = 2
    case adobeRgb8 // = 3
    case black8 // = 4
    case cmyk8 // = 5
    case device18 // = 6
    case device28 // = 7
    case device38 // = 8
    case device48 // = 9
    case device58 // = 10
    case device68 // = 11
    case device78 // = 12
    case device88 // = 13
    case device98 // = 14
    case device108 // = 15
    case device118 // = 16
    case device128 // = 17
    case device138 // = 18
    case device148 // = 19
    case device158 // = 20
    case rgb8 // = 21
    case sgray8 // = 22
    case srgb8 // = 23
    case adobeRgb16 // = 24
    case black16 // = 25
    case cmyk16 // = 26
    case device116 // = 27
    case device216 // = 28
    case device316 // = 29
    case device416 // = 30
    case device516 // = 31
    case device616 // = 32
    case device716 // = 33
    case device816 // = 34
    case device916 // = 35
    case device1016 // = 36
    case device1116 // = 37
    case device1216 // = 38
    case device1316 // = 39
    case device1416 // = 40
    case device1516 // = 41
    case rgb16 // = 42
    case sgray16 // = 43
    case srgb16 // = 44
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecifiedPwgDocumentType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedPwgDocumentType
      case 1: self = .black1
      case 2: self = .sgray1
      case 3: self = .adobeRgb8
      case 4: self = .black8
      case 5: self = .cmyk8
      case 6: self = .device18
      case 7: self = .device28
      case 8: self = .device38
      case 9: self = .device48
      case 10: self = .device58
      case 11: self = .device68
      case 12: self = .device78
      case 13: self = .device88
      case 14: self = .device98
      case 15: self = .device108
      case 16: self = .device118
      case 17: self = .device128
      case 18: self = .device138
      case 19: self = .device148
      case 20: self = .device158
      case 21: self = .rgb8
      case 22: self = .sgray8
      case 23: self = .srgb8
      case 24: self = .adobeRgb16
      case 25: self = .black16
      case 26: self = .cmyk16
      case 27: self = .device116
      case 28: self = .device216
      case 29: self = .device316
      case 30: self = .device416
      case 31: self = .device516
      case 32: self = .device616
      case 33: self = .device716
      case 34: self = .device816
      case 35: self = .device916
      case 36: self = .device1016
      case 37: self = .device1116
      case 38: self = .device1216
      case 39: self = .device1316
      case 40: self = .device1416
      case 41: self = .device1516
      case 42: self = .rgb16
      case 43: self = .sgray16
      case 44: self = .srgb16
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecifiedPwgDocumentType: return 0
      case .black1: return 1
      case .sgray1: return 2
      case .adobeRgb8: return 3
      case .black8: return 4
      case .cmyk8: return 5
      case .device18: return 6
      case .device28: return 7
      case .device38: return 8
      case .device48: return 9
      case .device58: return 10
      case .device68: return 11
      case .device78: return 12
      case .device88: return 13
      case .device98: return 14
      case .device108: return 15
      case .device118: return 16
      case .device128: return 17
      case .device138: return 18
      case .device148: return 19
      case .device158: return 20
      case .rgb8: return 21
      case .sgray8: return 22
      case .srgb8: return 23
      case .adobeRgb16: return 24
      case .black16: return 25
      case .cmyk16: return 26
      case .device116: return 27
      case .device216: return 28
      case .device316: return 29
      case .device416: return 30
      case .device516: return 31
      case .device616: return 32
      case .device716: return 33
      case .device816: return 34
      case .device916: return 35
      case .device1016: return 36
      case .device1116: return 37
      case .device1216: return 38
      case .device1316: return 39
      case .device1416: return 40
      case .device1516: return 41
      case .rgb16: return 42
      case .sgray16: return 43
      case .srgb16: return 44
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Resolution {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Horizontal resolution in DPI.
    public var crossFeedDir: Int32 = 0

    /// Vertical resolution in DPI.
    public var feedDir: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// [Deprecated: Please use the other fields of PwgRasterConfig.] Transformation to apply to pages during PWG
  /// rasterization.
  public struct Transformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required.
    public var operation: Google_Cloudprint_PwgRasterConfig.Transformation.Operation = .rotate180

    /// Required.
    public var operand: Google_Cloudprint_PwgRasterConfig.Transformation.Operand = .allPages

    /// Duplex types that the transformation applies to. Leave empty if the transformation is applicable to all duplex
    /// types.
    public var duplexType: [Google_Cloudprint_Duplex.TypeEnum] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Types of transformation operations to apply.
    public enum Operation: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Rotate pages 180 degrees.
      case rotate180 // = 0

      /// Flip pages along the long edge of the paper.
      case flipOnLongEdge // = 1

      /// Flip pages along the short edge of the paper.
      case flipOnShortEdge // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .rotate180
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .rotate180
        case 1: self = .flipOnLongEdge
        case 2: self = .flipOnShortEdge
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .rotate180: return 0
        case .flipOnLongEdge: return 1
        case .flipOnShortEdge: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Selectors of which pages to apply the transformation to.
    public enum Operand: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Apply transformation to all pages.
      case allPages // = 0

      /// Apply transformation to even pages only when duplexing (deprecated, instead use EVEN_PAGES and specify
      /// appropriate duplex types).
      case onlyDuplexedEvenPages // = 1

      /// Apply transformation to odd pages only when duplexing (deprecated, instead use ODD_PAGES and specify
      /// appropriate duplex types).
      case onlyDuplexedOddPages // = 2

      /// Apply transformation to even pages.
      case evenPages // = 3

      /// Apply transformation to odd pages.
      case oddPages // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .allPages
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .allPages
        case 1: self = .onlyDuplexedEvenPages
        case 2: self = .onlyDuplexedOddPages
        case 3: self = .evenPages
        case 4: self = .oddPages
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .allPages: return 0
        case .onlyDuplexedEvenPages: return 1
        case .onlyDuplexedOddPages: return 2
        case .evenPages: return 3
        case .oddPages: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_PwgRasterConfig.DocumentSheetBack: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_PwgRasterConfig.DocumentSheetBack] = [
    .normal,
    .rotated,
    .manualTumble,
    .flipped,
  ]
}

extension Google_Cloudprint_PwgRasterConfig.PwgDocumentTypeSupported: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_PwgRasterConfig.PwgDocumentTypeSupported] = [
    .unspecifiedPwgDocumentType,
    .black1,
    .sgray1,
    .adobeRgb8,
    .black8,
    .cmyk8,
    .device18,
    .device28,
    .device38,
    .device48,
    .device58,
    .device68,
    .device78,
    .device88,
    .device98,
    .device108,
    .device118,
    .device128,
    .device138,
    .device148,
    .device158,
    .rgb8,
    .sgray8,
    .srgb8,
    .adobeRgb16,
    .black16,
    .cmyk16,
    .device116,
    .device216,
    .device316,
    .device416,
    .device516,
    .device616,
    .device716,
    .device816,
    .device916,
    .device1016,
    .device1116,
    .device1216,
    .device1316,
    .device1416,
    .device1516,
    .rgb16,
    .sgray16,
    .srgb16,
  ]
}

#endif  // swift(>=4.2)

/// Physical model of a printer input tray.
public struct Google_Cloudprint_InputTrayUnit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vendor-provided ID of the input tray (required).
  public var vendorID: String = String()

  /// Type of input tray (required).
  public var type: Google_Cloudprint_InputTrayUnit.TypeEnum = .custom

  /// Index of the input tray.
  public var index: Int64 = 0

  /// Non-localized custom display name of the input tray. New CDDs should use custom_display_name_localized instead. It
  /// is required that either custom_display_name or custom_display_name_localized is set if the tray's type is CUSTOM.
  public var customDisplayName: String = String()

  /// Translations of custom display name of the input tray. If not empty, must contain an entry with locale == EN.
  public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of input tray types.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0
    case inputTray // = 1
    case bypassTray // = 2
    case manualFeedTray // = 3

    /// Large capacity tray.
    case lct // = 4
    case envelopeTray // = 5
    case roll // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .inputTray
      case 2: self = .bypassTray
      case 3: self = .manualFeedTray
      case 4: self = .lct
      case 5: self = .envelopeTray
      case 6: self = .roll
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .inputTray: return 1
      case .bypassTray: return 2
      case .manualFeedTray: return 3
      case .lct: return 4
      case .envelopeTray: return 5
      case .roll: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_InputTrayUnit.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_InputTrayUnit.TypeEnum] = [
    .custom,
    .inputTray,
    .bypassTray,
    .manualFeedTray,
    .lct,
    .envelopeTray,
    .roll,
  ]
}

#endif  // swift(>=4.2)

/// Physical model of a printer output bin.
public struct Google_Cloudprint_OutputBinUnit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vendor-provided ID of the output bin (required).
  public var vendorID: String = String()

  /// Type of output bin (required).
  public var type: Google_Cloudprint_OutputBinUnit.TypeEnum = .custom

  /// Index of the output bin.
  public var index: Int64 = 0

  /// Non-localized custom display name of the output bin. New CDDs should use custom_display_name_localized instead. It
  /// is required that either custom_display_name or custom_display_name_localized is set if the bin's type is CUSTOM.
  public var customDisplayName: String = String()

  /// Translations of custom display name of the output bin. If not empty, must contain an entry with locale == EN.
  public var customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of output bin types.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case custom // = 0
    case outputBin // = 1
    case mailbox // = 2
    case stacker // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .custom
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .custom
      case 1: self = .outputBin
      case 2: self = .mailbox
      case 3: self = .stacker
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .custom: return 0
      case .outputBin: return 1
      case .mailbox: return 2
      case .stacker: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloudprint_OutputBinUnit.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloudprint_OutputBinUnit.TypeEnum] = [
    .custom,
    .outputBin,
    .mailbox,
    .stacker,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloudprint"

extension Google_Cloudprint_PrinterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PRINTER_TYPE_FILTER"),
    1: .same(proto: "GOOGLE"),
    2: .same(proto: "HP"),
    3: .same(proto: "DRIVE"),
    4: .same(proto: "FEDEX"),
    5: .same(proto: "ANDROID_CHROME_SNAPSHOT"),
    6: .same(proto: "IOS_CHROME_SNAPSHOT"),
  ]
}

extension Google_Cloudprint_NotificationChannel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNRECOGNIZED_CHANNEL"),
    1: .same(proto: "XMPP_CHANNEL"),
  ]
}

extension Google_Cloudprint_Marker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Marker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_id"),
    2: .same(proto: "type"),
    3: .same(proto: "color"),
    4: .standard(proto: "custom_display_name"),
    5: .standard(proto: "custom_display_name_localized"),
  ]

  fileprivate class _StorageClass {
    var _vendorID: String = String()
    var _type: Google_Cloudprint_Marker.TypeEnum = .custom
    var _color: Google_Cloudprint_Marker.Color? = nil
    var _customDisplayName: String = String()
    var _customDisplayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _vendorID = source._vendorID
      _type = source._type
      _color = source._color
      _customDisplayName = source._customDisplayName
      _customDisplayNameLocalized = source._customDisplayNameLocalized
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._vendorID)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._color)
        case 4: try decoder.decodeSingularStringField(value: &_storage._customDisplayName)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._customDisplayNameLocalized)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._vendorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vendorID, fieldNumber: 1)
      }
      if _storage._type != .custom {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._customDisplayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customDisplayName, fieldNumber: 4)
      }
      if !_storage._customDisplayNameLocalized.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customDisplayNameLocalized, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Marker, rhs: Google_Cloudprint_Marker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._vendorID != rhs_storage._vendorID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._customDisplayName != rhs_storage._customDisplayName {return false}
        if _storage._customDisplayNameLocalized != rhs_storage._customDisplayNameLocalized {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Marker.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "TONER"),
    2: .same(proto: "INK"),
    3: .same(proto: "STAPLES"),
  ]
}

extension Google_Cloudprint_Marker.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_Marker.protoMessageName + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "custom_display_name"),
    3: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .custom {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 2)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Marker.Color, rhs: Google_Cloudprint_Marker.Color) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Marker.Color.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "BLACK"),
    2: .same(proto: "COLOR"),
    3: .same(proto: "CYAN"),
    4: .same(proto: "MAGENTA"),
    5: .same(proto: "YELLOW"),
    6: .same(proto: "LIGHT_CYAN"),
    7: .same(proto: "LIGHT_MAGENTA"),
    8: .same(proto: "GRAY"),
    9: .same(proto: "LIGHT_GRAY"),
    10: .same(proto: "PIGMENT_BLACK"),
    11: .same(proto: "MATTE_BLACK"),
    12: .same(proto: "PHOTO_CYAN"),
    13: .same(proto: "PHOTO_MAGENTA"),
    14: .same(proto: "PHOTO_YELLOW"),
    15: .same(proto: "PHOTO_GRAY"),
    16: .same(proto: "RED"),
    17: .same(proto: "GREEN"),
    18: .same(proto: "BLUE"),
  ]
}

extension Google_Cloudprint_Cover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cover"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_id"),
    2: .same(proto: "type"),
    3: .same(proto: "index"),
    4: .standard(proto: "custom_display_name"),
    5: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.vendorID)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.index)
      case 4: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 1)
    }
    if self.type != .custom {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 3)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 4)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Cover, rhs: Google_Cloudprint_Cover) -> Bool {
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Cover.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "DOOR"),
    2: .same(proto: "COVER"),
  ]
}

extension Google_Cloudprint_MediaPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.vendorID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_MediaPath, rhs: Google_Cloudprint_MediaPath) -> Bool {
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_VendorCapability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VendorCapability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "type"),
    4: .standard(proto: "range_cap"),
    5: .standard(proto: "select_cap"),
    6: .standard(proto: "typed_value_cap"),
    7: .standard(proto: "display_name_localized"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _displayName: String = String()
    var _type: Google_Cloudprint_VendorCapability.TypeEnum = .range
    var _rangeCap: Google_Cloudprint_RangeCapability? = nil
    var _selectCap: Google_Cloudprint_SelectCapability? = nil
    var _typedValueCap: Google_Cloudprint_TypedValueCapability? = nil
    var _displayNameLocalized: [Google_Cloudprint_LocalizedString] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _displayName = source._displayName
      _type = source._type
      _rangeCap = source._rangeCap
      _selectCap = source._selectCap
      _typedValueCap = source._typedValueCap
      _displayNameLocalized = source._displayNameLocalized
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._displayName)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._rangeCap)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._selectCap)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._typedValueCap)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._displayNameLocalized)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if _storage._type != .range {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 3)
      }
      if let v = _storage._rangeCap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._selectCap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._typedValueCap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._displayNameLocalized.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._displayNameLocalized, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_VendorCapability, rhs: Google_Cloudprint_VendorCapability) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._rangeCap != rhs_storage._rangeCap {return false}
        if _storage._selectCap != rhs_storage._selectCap {return false}
        if _storage._typedValueCap != rhs_storage._typedValueCap {return false}
        if _storage._displayNameLocalized != rhs_storage._displayNameLocalized {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_VendorCapability.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RANGE"),
    1: .same(proto: "SELECT"),
    2: .same(proto: "TYPED_VALUE"),
  ]
}

extension Google_Cloudprint_RangeCapability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RangeCapability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "value_type"),
    2: .same(proto: "default"),
    3: .same(proto: "min"),
    4: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.valueType)
      case 2: try decoder.decodeSingularStringField(value: &self.`default`)
      case 3: try decoder.decodeSingularStringField(value: &self.min)
      case 4: try decoder.decodeSingularStringField(value: &self.max)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valueType != .float {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 1)
    }
    if !self.`default`.isEmpty {
      try visitor.visitSingularStringField(value: self.`default`, fieldNumber: 2)
    }
    if !self.min.isEmpty {
      try visitor.visitSingularStringField(value: self.min, fieldNumber: 3)
    }
    if !self.max.isEmpty {
      try visitor.visitSingularStringField(value: self.max, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_RangeCapability, rhs: Google_Cloudprint_RangeCapability) -> Bool {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.`default` != rhs.`default` {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_RangeCapability.ValueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FLOAT"),
    1: .same(proto: "INTEGER"),
  ]
}

extension Google_Cloudprint_SelectCapability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectCapability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_SelectCapability, rhs: Google_Cloudprint_SelectCapability) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_SelectCapability.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_SelectCapability.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "is_default"),
    4: .standard(proto: "display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.value)
      case 2: try decoder.decodeSingularStringField(value: &self.displayName)
      case 3: try decoder.decodeSingularBoolField(value: &self.isDefault)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.displayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 3)
    }
    if !self.displayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.displayNameLocalized, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_SelectCapability.Option, rhs: Google_Cloudprint_SelectCapability.Option) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.displayNameLocalized != rhs.displayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_TypedValueCapability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypedValueCapability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "value_type"),
    2: .same(proto: "default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.valueType)
      case 2: try decoder.decodeSingularStringField(value: &self.`default`)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valueType != .boolean {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 1)
    }
    if !self.`default`.isEmpty {
      try visitor.visitSingularStringField(value: self.`default`, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_TypedValueCapability, rhs: Google_Cloudprint_TypedValueCapability) -> Bool {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.`default` != rhs.`default` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_TypedValueCapability.ValueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BOOLEAN"),
    1: .same(proto: "FLOAT"),
    2: .same(proto: "INTEGER"),
    3: .same(proto: "STRING"),
  ]
}

extension Google_Cloudprint_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Color, rhs: Google_Cloudprint_Color) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Color.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STANDARD_COLOR"),
    1: .same(proto: "STANDARD_MONOCHROME"),
    2: .same(proto: "CUSTOM_COLOR"),
    3: .same(proto: "CUSTOM_MONOCHROME"),
    4: .same(proto: "AUTO"),
  ]
}

extension Google_Cloudprint_Color.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_Color.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_id"),
    2: .same(proto: "type"),
    3: .standard(proto: "custom_display_name"),
    4: .standard(proto: "is_default"),
    5: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.vendorID)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 4: try decoder.decodeSingularBoolField(value: &self.isDefault)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 1)
    }
    if self.type != .standardColor {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 3)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 4)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Color.Option, rhs: Google_Cloudprint_Color.Option) -> Bool {
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Duplex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Duplex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Duplex, rhs: Google_Cloudprint_Duplex) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Duplex.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_DUPLEX"),
    1: .same(proto: "LONG_EDGE"),
    2: .same(proto: "SHORT_EDGE"),
  ]
}

extension Google_Cloudprint_Duplex.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_Duplex.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "is_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularBoolField(value: &self.isDefault)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .noDuplex {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Duplex.Option, rhs: Google_Cloudprint_Duplex.Option) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PageOrientation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageOrientation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PageOrientation, rhs: Google_Cloudprint_PageOrientation) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PageOrientation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PORTRAIT"),
    1: .same(proto: "LANDSCAPE"),
    2: .same(proto: "AUTO"),
  ]
}

extension Google_Cloudprint_PageOrientation.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_PageOrientation.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "is_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularBoolField(value: &self.isDefault)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .portrait {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PageOrientation.Option, rhs: Google_Cloudprint_PageOrientation.Option) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Copies: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Copies"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.`default`)
      case 2: try decoder.decodeSingularInt32Field(value: &self.max)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`default` != 0 {
      try visitor.visitSingularInt32Field(value: self.`default`, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularInt32Field(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Copies, rhs: Google_Cloudprint_Copies) -> Bool {
    if lhs.`default` != rhs.`default` {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Margins: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Margins"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Margins, rhs: Google_Cloudprint_Margins) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Margins.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BORDERLESS"),
    1: .same(proto: "STANDARD"),
    2: .same(proto: "CUSTOM"),
  ]
}

extension Google_Cloudprint_Margins.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_Margins.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "top_microns"),
    3: .standard(proto: "right_microns"),
    4: .standard(proto: "bottom_microns"),
    5: .standard(proto: "left_microns"),
    6: .standard(proto: "is_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularInt32Field(value: &self.topMicrons)
      case 3: try decoder.decodeSingularInt32Field(value: &self.rightMicrons)
      case 4: try decoder.decodeSingularInt32Field(value: &self.bottomMicrons)
      case 5: try decoder.decodeSingularInt32Field(value: &self.leftMicrons)
      case 6: try decoder.decodeSingularBoolField(value: &self.isDefault)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .borderless {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.topMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.topMicrons, fieldNumber: 2)
    }
    if self.rightMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.rightMicrons, fieldNumber: 3)
    }
    if self.bottomMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.bottomMicrons, fieldNumber: 4)
    }
    if self.leftMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.leftMicrons, fieldNumber: 5)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Margins.Option, rhs: Google_Cloudprint_Margins.Option) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.topMicrons != rhs.topMicrons {return false}
    if lhs.rightMicrons != rhs.rightMicrons {return false}
    if lhs.bottomMicrons != rhs.bottomMicrons {return false}
    if lhs.leftMicrons != rhs.leftMicrons {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Dpi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dpi"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
    2: .standard(proto: "min_horizontal_dpi"),
    3: .standard(proto: "max_horizontal_dpi"),
    4: .standard(proto: "min_vertical_dpi"),
    5: .standard(proto: "max_vertical_dpi"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      case 2: try decoder.decodeSingularInt32Field(value: &self.minHorizontalDpi)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maxHorizontalDpi)
      case 4: try decoder.decodeSingularInt32Field(value: &self.minVerticalDpi)
      case 5: try decoder.decodeSingularInt32Field(value: &self.maxVerticalDpi)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    if self.minHorizontalDpi != 0 {
      try visitor.visitSingularInt32Field(value: self.minHorizontalDpi, fieldNumber: 2)
    }
    if self.maxHorizontalDpi != 0 {
      try visitor.visitSingularInt32Field(value: self.maxHorizontalDpi, fieldNumber: 3)
    }
    if self.minVerticalDpi != 0 {
      try visitor.visitSingularInt32Field(value: self.minVerticalDpi, fieldNumber: 4)
    }
    if self.maxVerticalDpi != 0 {
      try visitor.visitSingularInt32Field(value: self.maxVerticalDpi, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Dpi, rhs: Google_Cloudprint_Dpi) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.minHorizontalDpi != rhs.minHorizontalDpi {return false}
    if lhs.maxHorizontalDpi != rhs.maxHorizontalDpi {return false}
    if lhs.minVerticalDpi != rhs.minVerticalDpi {return false}
    if lhs.maxVerticalDpi != rhs.maxVerticalDpi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Dpi.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_Dpi.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "horizontal_dpi"),
    2: .standard(proto: "vertical_dpi"),
    3: .standard(proto: "is_default"),
    4: .standard(proto: "custom_display_name"),
    5: .standard(proto: "vendor_id"),
    6: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.horizontalDpi)
      case 2: try decoder.decodeSingularInt32Field(value: &self.verticalDpi)
      case 3: try decoder.decodeSingularBoolField(value: &self.isDefault)
      case 4: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 5: try decoder.decodeSingularStringField(value: &self.vendorID)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.horizontalDpi != 0 {
      try visitor.visitSingularInt32Field(value: self.horizontalDpi, fieldNumber: 1)
    }
    if self.verticalDpi != 0 {
      try visitor.visitSingularInt32Field(value: self.verticalDpi, fieldNumber: 2)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 3)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 4)
    }
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 5)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Dpi.Option, rhs: Google_Cloudprint_Dpi.Option) -> Bool {
    if lhs.horizontalDpi != rhs.horizontalDpi {return false}
    if lhs.verticalDpi != rhs.verticalDpi {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_FitToPage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FitToPage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_FitToPage, rhs: Google_Cloudprint_FitToPage) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_FitToPage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_FITTING"),
    1: .same(proto: "FIT_TO_PAGE"),
    2: .same(proto: "GROW_TO_PAGE"),
    3: .same(proto: "SHRINK_TO_PAGE"),
    4: .same(proto: "FILL_PAGE"),
  ]
}

extension Google_Cloudprint_FitToPage.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_FitToPage.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "is_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularBoolField(value: &self.isDefault)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .noFitting {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_FitToPage.Option, rhs: Google_Cloudprint_FitToPage.Option) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PageRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.`default`)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`default`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`default`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PageRange, rhs: Google_Cloudprint_PageRange) -> Bool {
    if lhs.`default` != rhs.`default` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PageRange.Interval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_PageRange.protoMessageName + ".Interval"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.start)
      case 2: try decoder.decodeSingularInt32Field(value: &self.end)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PageRange.Interval, rhs: Google_Cloudprint_PageRange.Interval) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_MediaSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaSize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
    2: .standard(proto: "max_width_microns"),
    3: .standard(proto: "max_height_microns"),
    4: .standard(proto: "min_width_microns"),
    5: .standard(proto: "min_height_microns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      case 2: try decoder.decodeSingularInt32Field(value: &self.maxWidthMicrons)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maxHeightMicrons)
      case 4: try decoder.decodeSingularInt32Field(value: &self.minWidthMicrons)
      case 5: try decoder.decodeSingularInt32Field(value: &self.minHeightMicrons)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    if self.maxWidthMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.maxWidthMicrons, fieldNumber: 2)
    }
    if self.maxHeightMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.maxHeightMicrons, fieldNumber: 3)
    }
    if self.minWidthMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.minWidthMicrons, fieldNumber: 4)
    }
    if self.minHeightMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.minHeightMicrons, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_MediaSize, rhs: Google_Cloudprint_MediaSize) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.maxWidthMicrons != rhs.maxWidthMicrons {return false}
    if lhs.maxHeightMicrons != rhs.maxHeightMicrons {return false}
    if lhs.minWidthMicrons != rhs.minWidthMicrons {return false}
    if lhs.minHeightMicrons != rhs.minHeightMicrons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_MediaSize.Name: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    100: .same(proto: "NA_INDEX_3X5"),
    101: .same(proto: "NA_PERSONAL"),
    102: .same(proto: "NA_MONARCH"),
    103: .same(proto: "NA_NUMBER_9"),
    104: .same(proto: "NA_INDEX_4X6"),
    105: .same(proto: "NA_NUMBER_10"),
    106: .same(proto: "NA_A2"),
    107: .same(proto: "NA_NUMBER_11"),
    108: .same(proto: "NA_NUMBER_12"),
    109: .same(proto: "NA_5X7"),
    110: .same(proto: "NA_INDEX_5X8"),
    111: .same(proto: "NA_NUMBER_14"),
    112: .same(proto: "NA_INVOICE"),
    113: .same(proto: "NA_INDEX_4X6_EXT"),
    114: .same(proto: "NA_6X9"),
    115: .same(proto: "NA_C5"),
    116: .same(proto: "NA_7X9"),
    117: .same(proto: "NA_EXECUTIVE"),
    118: .same(proto: "NA_GOVT_LETTER"),
    119: .same(proto: "NA_GOVT_LEGAL"),
    120: .same(proto: "NA_QUARTO"),
    121: .same(proto: "NA_LETTER"),
    122: .same(proto: "NA_FANFOLD_EUR"),
    123: .same(proto: "NA_LETTER_PLUS"),
    124: .same(proto: "NA_FOOLSCAP"),
    125: .same(proto: "NA_LEGAL"),
    126: .same(proto: "NA_SUPER_A"),
    127: .same(proto: "NA_9X11"),
    128: .same(proto: "NA_ARCH_A"),
    129: .same(proto: "NA_LETTER_EXTRA"),
    130: .same(proto: "NA_LEGAL_EXTRA"),
    131: .same(proto: "NA_10X11"),
    132: .same(proto: "NA_10X13"),
    133: .same(proto: "NA_10X14"),
    134: .same(proto: "NA_10X15"),
    135: .same(proto: "NA_11X12"),
    136: .same(proto: "NA_EDP"),
    137: .same(proto: "NA_FANFOLD_US"),
    138: .same(proto: "NA_11X15"),
    139: .same(proto: "NA_LEDGER"),
    140: .same(proto: "NA_EUR_EDP"),
    141: .same(proto: "NA_ARCH_B"),
    142: .same(proto: "NA_12X19"),
    143: .same(proto: "NA_B_PLUS"),
    144: .same(proto: "NA_SUPER_B"),
    145: .same(proto: "NA_C"),
    146: .same(proto: "NA_ARCH_C"),
    147: .same(proto: "NA_D"),
    148: .same(proto: "NA_ARCH_D"),
    149: .same(proto: "NA_ASME_F"),
    150: .same(proto: "NA_WIDE_FORMAT"),
    151: .same(proto: "NA_E"),
    152: .same(proto: "NA_ARCH_E"),
    153: .same(proto: "NA_F"),
    200: .same(proto: "ROC_16K"),
    201: .same(proto: "ROC_8K"),
    202: .same(proto: "PRC_32K"),
    203: .same(proto: "PRC_1"),
    204: .same(proto: "PRC_2"),
    205: .same(proto: "PRC_4"),
    206: .same(proto: "PRC_5"),
    207: .same(proto: "PRC_8"),
    208: .same(proto: "PRC_6"),
    209: .same(proto: "PRC_3"),
    210: .same(proto: "PRC_16K"),
    211: .same(proto: "PRC_7"),
    212: .same(proto: "OM_JUURO_KU_KAI"),
    213: .same(proto: "OM_PA_KAI"),
    214: .same(proto: "OM_DAI_PA_KAI"),
    215: .same(proto: "PRC_10"),
    301: .same(proto: "ISO_A10"),
    302: .same(proto: "ISO_A9"),
    303: .same(proto: "ISO_A8"),
    304: .same(proto: "ISO_A7"),
    305: .same(proto: "ISO_A6"),
    306: .same(proto: "ISO_A5"),
    307: .same(proto: "ISO_A5_EXTRA"),
    308: .same(proto: "ISO_A4"),
    309: .same(proto: "ISO_A4_TAB"),
    310: .same(proto: "ISO_A4_EXTRA"),
    311: .same(proto: "ISO_A3"),
    312: .same(proto: "ISO_A4X3"),
    313: .same(proto: "ISO_A4X4"),
    314: .same(proto: "ISO_A4X5"),
    315: .same(proto: "ISO_A4X6"),
    316: .same(proto: "ISO_A4X7"),
    317: .same(proto: "ISO_A4X8"),
    318: .same(proto: "ISO_A4X9"),
    319: .same(proto: "ISO_A3_EXTRA"),
    320: .same(proto: "ISO_A2"),
    321: .same(proto: "ISO_A3X3"),
    322: .same(proto: "ISO_A3X4"),
    323: .same(proto: "ISO_A3X5"),
    324: .same(proto: "ISO_A3X6"),
    325: .same(proto: "ISO_A3X7"),
    326: .same(proto: "ISO_A1"),
    327: .same(proto: "ISO_A2X3"),
    328: .same(proto: "ISO_A2X4"),
    329: .same(proto: "ISO_A2X5"),
    330: .same(proto: "ISO_A0"),
    331: .same(proto: "ISO_A1X3"),
    332: .same(proto: "ISO_A1X4"),
    333: .same(proto: "ISO_2A0"),
    334: .same(proto: "ISO_A0X3"),
    335: .same(proto: "ISO_B10"),
    336: .same(proto: "ISO_B9"),
    337: .same(proto: "ISO_B8"),
    338: .same(proto: "ISO_B7"),
    339: .same(proto: "ISO_B6"),
    340: .same(proto: "ISO_B6C4"),
    341: .same(proto: "ISO_B5"),
    342: .same(proto: "ISO_B5_EXTRA"),
    343: .same(proto: "ISO_B4"),
    344: .same(proto: "ISO_B3"),
    345: .same(proto: "ISO_B2"),
    346: .same(proto: "ISO_B1"),
    347: .same(proto: "ISO_B0"),
    348: .same(proto: "ISO_C10"),
    349: .same(proto: "ISO_C9"),
    350: .same(proto: "ISO_C8"),
    351: .same(proto: "ISO_C7"),
    352: .same(proto: "ISO_C7C6"),
    353: .same(proto: "ISO_C6"),
    354: .same(proto: "ISO_C6C5"),
    355: .same(proto: "ISO_C5"),
    356: .same(proto: "ISO_C4"),
    357: .same(proto: "ISO_C3"),
    358: .same(proto: "ISO_C2"),
    359: .same(proto: "ISO_C1"),
    360: .same(proto: "ISO_C0"),
    361: .same(proto: "ISO_DL"),
    362: .same(proto: "ISO_RA2"),
    363: .same(proto: "ISO_SRA2"),
    364: .same(proto: "ISO_RA1"),
    365: .same(proto: "ISO_SRA1"),
    366: .same(proto: "ISO_RA0"),
    367: .same(proto: "ISO_SRA0"),
    400: .same(proto: "JIS_B10"),
    401: .same(proto: "JIS_B9"),
    402: .same(proto: "JIS_B8"),
    403: .same(proto: "JIS_B7"),
    404: .same(proto: "JIS_B6"),
    405: .same(proto: "JIS_B5"),
    406: .same(proto: "JIS_B4"),
    407: .same(proto: "JIS_B3"),
    408: .same(proto: "JIS_B2"),
    409: .same(proto: "JIS_B1"),
    410: .same(proto: "JIS_B0"),
    411: .same(proto: "JIS_EXEC"),
    412: .same(proto: "JPN_CHOU4"),
    413: .same(proto: "JPN_HAGAKI"),
    414: .same(proto: "JPN_YOU4"),
    415: .same(proto: "JPN_CHOU2"),
    416: .same(proto: "JPN_CHOU3"),
    417: .same(proto: "JPN_OUFUKU"),
    418: .same(proto: "JPN_KAHU"),
    419: .same(proto: "JPN_KAKU2"),
    500: .same(proto: "OM_SMALL_PHOTO"),
    501: .same(proto: "OM_ITALIAN"),
    502: .same(proto: "OM_POSTFIX"),
    503: .same(proto: "OM_LARGE_PHOTO"),
    504: .same(proto: "OM_FOLIO"),
    505: .same(proto: "OM_FOLIO_SP"),
    506: .same(proto: "OM_INVITE"),
  ]
}

extension Google_Cloudprint_MediaSize.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_MediaSize.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "width_microns"),
    3: .standard(proto: "height_microns"),
    4: .standard(proto: "is_continuous_feed"),
    5: .standard(proto: "is_default"),
    6: .standard(proto: "custom_display_name"),
    7: .standard(proto: "vendor_id"),
    8: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.name)
      case 2: try decoder.decodeSingularInt32Field(value: &self.widthMicrons)
      case 3: try decoder.decodeSingularInt32Field(value: &self.heightMicrons)
      case 4: try decoder.decodeSingularBoolField(value: &self.isContinuousFeed)
      case 5: try decoder.decodeSingularBoolField(value: &self.isDefault)
      case 6: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 7: try decoder.decodeSingularStringField(value: &self.vendorID)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.name != .custom {
      try visitor.visitSingularEnumField(value: self.name, fieldNumber: 1)
    }
    if self.widthMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.widthMicrons, fieldNumber: 2)
    }
    if self.heightMicrons != 0 {
      try visitor.visitSingularInt32Field(value: self.heightMicrons, fieldNumber: 3)
    }
    if self.isContinuousFeed != false {
      try visitor.visitSingularBoolField(value: self.isContinuousFeed, fieldNumber: 4)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 5)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 6)
    }
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 7)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_MediaSize.Option, rhs: Google_Cloudprint_MediaSize.Option) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.widthMicrons != rhs.widthMicrons {return false}
    if lhs.heightMicrons != rhs.heightMicrons {return false}
    if lhs.isContinuousFeed != rhs.isContinuousFeed {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_Collate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Collate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.`default`)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`default` != false {
      try visitor.visitSingularBoolField(value: self.`default`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_Collate, rhs: Google_Cloudprint_Collate) -> Bool {
    if lhs.`default` != rhs.`default` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_ReverseOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReverseOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.`default`)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`default` != false {
      try visitor.visitSingularBoolField(value: self.`default`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_ReverseOrder, rhs: Google_Cloudprint_ReverseOrder) -> Bool {
    if lhs.`default` != rhs.`default` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_LocalizedString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalizedString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locale"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.locale)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.locale != .af {
      try visitor.visitSingularEnumField(value: self.locale, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_LocalizedString, rhs: Google_Cloudprint_LocalizedString) -> Bool {
    if lhs.locale != rhs.locale {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_LocalizedString.Locale: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AF"),
    1: .same(proto: "AM"),
    2: .same(proto: "AR"),
    3: .same(proto: "AR_XB"),
    4: .same(proto: "BG"),
    5: .same(proto: "BN"),
    6: .same(proto: "CA"),
    7: .same(proto: "CS"),
    8: .same(proto: "CY"),
    9: .same(proto: "DA"),
    10: .same(proto: "DE"),
    11: .same(proto: "DE_AT"),
    12: .same(proto: "DE_CH"),
    13: .same(proto: "EL"),
    14: .same(proto: "EN"),
    15: .same(proto: "EN_GB"),
    16: .same(proto: "EN_IE"),
    17: .same(proto: "EN_IN"),
    18: .same(proto: "EN_SG"),
    19: .same(proto: "EN_XA"),
    20: .same(proto: "EN_XC"),
    21: .same(proto: "EN_ZA"),
    22: .same(proto: "ES"),
    23: .same(proto: "ES_419"),
    24: .same(proto: "ES_AR"),
    25: .same(proto: "ES_BO"),
    26: .same(proto: "ES_CL"),
    27: .same(proto: "ES_CO"),
    28: .same(proto: "ES_CR"),
    29: .same(proto: "ES_DO"),
    30: .same(proto: "ES_EC"),
    31: .same(proto: "ES_GT"),
    32: .same(proto: "ES_HN"),
    33: .same(proto: "ES_MX"),
    34: .same(proto: "ES_NI"),
    35: .same(proto: "ES_PA"),
    36: .same(proto: "ES_PE"),
    37: .same(proto: "ES_PR"),
    38: .same(proto: "ES_PY"),
    39: .same(proto: "ES_SV"),
    40: .same(proto: "ES_US"),
    41: .same(proto: "ES_UY"),
    42: .same(proto: "ES_VE"),
    43: .same(proto: "ET"),
    44: .same(proto: "EU"),
    45: .same(proto: "FA"),
    46: .same(proto: "FI"),
    47: .same(proto: "FR"),
    48: .same(proto: "FR_CA"),
    49: .same(proto: "FR_CH"),
    50: .same(proto: "GL"),
    51: .same(proto: "GU"),
    52: .same(proto: "HE"),
    53: .same(proto: "HI"),
    54: .same(proto: "HR"),
    55: .same(proto: "HU"),
    56: .same(proto: "HY"),
    57: .same(proto: "ID"),
    58: .same(proto: "IN"),
    59: .same(proto: "IT"),
    60: .same(proto: "JA"),
    61: .same(proto: "KA"),
    62: .same(proto: "KM"),
    63: .same(proto: "KN"),
    64: .same(proto: "KO"),
    65: .same(proto: "LN"),
    66: .same(proto: "LO"),
    67: .same(proto: "LT"),
    68: .same(proto: "LV"),
    69: .same(proto: "ML"),
    70: .same(proto: "MO"),
    71: .same(proto: "MR"),
    72: .same(proto: "MS"),
    73: .same(proto: "NB"),
    74: .same(proto: "NE"),
    75: .same(proto: "NL"),
    76: .same(proto: "NO"),
    77: .same(proto: "PL"),
    78: .same(proto: "PT"),
    79: .same(proto: "PT_BR"),
    80: .same(proto: "PT_PT"),
    81: .same(proto: "RM"),
    82: .same(proto: "RO"),
    83: .same(proto: "RU"),
    84: .same(proto: "SK"),
    85: .same(proto: "SL"),
    86: .same(proto: "SR"),
    87: .same(proto: "SR_LATN"),
    88: .same(proto: "SV"),
    89: .same(proto: "SW"),
    90: .same(proto: "TA"),
    91: .same(proto: "TE"),
    92: .same(proto: "TH"),
    93: .same(proto: "TL"),
    94: .same(proto: "TR"),
    95: .same(proto: "UK"),
    96: .same(proto: "UR"),
    97: .same(proto: "VI"),
    98: .same(proto: "ZH"),
    99: .same(proto: "ZH_CN"),
    100: .same(proto: "ZH_HK"),
    101: .same(proto: "ZH_TW"),
    102: .same(proto: "ZU"),
  ]
}

extension Google_Cloudprint_SupportedContentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SupportedContentType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_type"),
    2: .standard(proto: "min_version"),
    3: .standard(proto: "max_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.contentType)
      case 2: try decoder.decodeSingularStringField(value: &self.minVersion)
      case 3: try decoder.decodeSingularStringField(value: &self.maxVersion)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentType.isEmpty {
      try visitor.visitSingularStringField(value: self.contentType, fieldNumber: 1)
    }
    if !self.minVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minVersion, fieldNumber: 2)
    }
    if !self.maxVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.maxVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_SupportedContentType, rhs: Google_Cloudprint_SupportedContentType) -> Bool {
    if lhs.contentType != rhs.contentType {return false}
    if lhs.minVersion != rhs.minVersion {return false}
    if lhs.maxVersion != rhs.maxVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PrintingSpeed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrintingSpeed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.option)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.option.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.option, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PrintingSpeed, rhs: Google_Cloudprint_PrintingSpeed) -> Bool {
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PrintingSpeed.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_PrintingSpeed.protoMessageName + ".Option"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "speed_ppm"),
    2: .standard(proto: "color_type"),
    3: .standard(proto: "media_size_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.speedPpm)
      case 2: try decoder.decodeRepeatedEnumField(value: &self.colorType)
      case 3: try decoder.decodeRepeatedEnumField(value: &self.mediaSizeName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speedPpm != 0 {
      try visitor.visitSingularFloatField(value: self.speedPpm, fieldNumber: 1)
    }
    if !self.colorType.isEmpty {
      try visitor.visitPackedEnumField(value: self.colorType, fieldNumber: 2)
    }
    if !self.mediaSizeName.isEmpty {
      try visitor.visitPackedEnumField(value: self.mediaSizeName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PrintingSpeed.Option, rhs: Google_Cloudprint_PrintingSpeed.Option) -> Bool {
    if lhs.speedPpm != rhs.speedPpm {return false}
    if lhs.colorType != rhs.colorType {return false}
    if lhs.mediaSizeName != rhs.mediaSizeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PwgRasterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PwgRasterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "document_resolution_supported"),
    3: .standard(proto: "document_type_supported"),
    4: .standard(proto: "document_sheet_back"),
    5: .standard(proto: "reverse_order_streaming"),
    6: .standard(proto: "rotate_all_pages"),
    1: .same(proto: "transformation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transformation)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.documentResolutionSupported)
      case 3: try decoder.decodeRepeatedEnumField(value: &self.documentTypeSupported)
      case 4: try decoder.decodeSingularEnumField(value: &self.documentSheetBack)
      case 5: try decoder.decodeSingularBoolField(value: &self.reverseOrderStreaming)
      case 6: try decoder.decodeSingularBoolField(value: &self.rotateAllPages)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transformation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transformation, fieldNumber: 1)
    }
    if !self.documentResolutionSupported.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.documentResolutionSupported, fieldNumber: 2)
    }
    if !self.documentTypeSupported.isEmpty {
      try visitor.visitPackedEnumField(value: self.documentTypeSupported, fieldNumber: 3)
    }
    if self.documentSheetBack != .normal {
      try visitor.visitSingularEnumField(value: self.documentSheetBack, fieldNumber: 4)
    }
    if self.reverseOrderStreaming != false {
      try visitor.visitSingularBoolField(value: self.reverseOrderStreaming, fieldNumber: 5)
    }
    if self.rotateAllPages != false {
      try visitor.visitSingularBoolField(value: self.rotateAllPages, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PwgRasterConfig, rhs: Google_Cloudprint_PwgRasterConfig) -> Bool {
    if lhs.documentResolutionSupported != rhs.documentResolutionSupported {return false}
    if lhs.documentTypeSupported != rhs.documentTypeSupported {return false}
    if lhs.documentSheetBack != rhs.documentSheetBack {return false}
    if lhs.reverseOrderStreaming != rhs.reverseOrderStreaming {return false}
    if lhs.rotateAllPages != rhs.rotateAllPages {return false}
    if lhs.transformation != rhs.transformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PwgRasterConfig.DocumentSheetBack: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ROTATED"),
    2: .same(proto: "MANUAL_TUMBLE"),
    3: .same(proto: "FLIPPED"),
  ]
}

extension Google_Cloudprint_PwgRasterConfig.PwgDocumentTypeSupported: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_PWG_DOCUMENT_TYPE"),
    1: .same(proto: "BLACK_1"),
    2: .same(proto: "SGRAY_1"),
    3: .same(proto: "ADOBE_RGB_8"),
    4: .same(proto: "BLACK_8"),
    5: .same(proto: "CMYK_8"),
    6: .same(proto: "DEVICE1_8"),
    7: .same(proto: "DEVICE2_8"),
    8: .same(proto: "DEVICE3_8"),
    9: .same(proto: "DEVICE4_8"),
    10: .same(proto: "DEVICE5_8"),
    11: .same(proto: "DEVICE6_8"),
    12: .same(proto: "DEVICE7_8"),
    13: .same(proto: "DEVICE8_8"),
    14: .same(proto: "DEVICE9_8"),
    15: .same(proto: "DEVICE10_8"),
    16: .same(proto: "DEVICE11_8"),
    17: .same(proto: "DEVICE12_8"),
    18: .same(proto: "DEVICE13_8"),
    19: .same(proto: "DEVICE14_8"),
    20: .same(proto: "DEVICE15_8"),
    21: .same(proto: "RGB_8"),
    22: .same(proto: "SGRAY_8"),
    23: .same(proto: "SRGB_8"),
    24: .same(proto: "ADOBE_RGB_16"),
    25: .same(proto: "BLACK_16"),
    26: .same(proto: "CMYK_16"),
    27: .same(proto: "DEVICE1_16"),
    28: .same(proto: "DEVICE2_16"),
    29: .same(proto: "DEVICE3_16"),
    30: .same(proto: "DEVICE4_16"),
    31: .same(proto: "DEVICE5_16"),
    32: .same(proto: "DEVICE6_16"),
    33: .same(proto: "DEVICE7_16"),
    34: .same(proto: "DEVICE8_16"),
    35: .same(proto: "DEVICE9_16"),
    36: .same(proto: "DEVICE10_16"),
    37: .same(proto: "DEVICE11_16"),
    38: .same(proto: "DEVICE12_16"),
    39: .same(proto: "DEVICE13_16"),
    40: .same(proto: "DEVICE14_16"),
    41: .same(proto: "DEVICE15_16"),
    42: .same(proto: "RGB_16"),
    43: .same(proto: "SGRAY_16"),
    44: .same(proto: "SRGB_16"),
  ]
}

extension Google_Cloudprint_PwgRasterConfig.Resolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_PwgRasterConfig.protoMessageName + ".Resolution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cross_feed_dir"),
    2: .standard(proto: "feed_dir"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.crossFeedDir)
      case 2: try decoder.decodeSingularInt32Field(value: &self.feedDir)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.crossFeedDir != 0 {
      try visitor.visitSingularInt32Field(value: self.crossFeedDir, fieldNumber: 1)
    }
    if self.feedDir != 0 {
      try visitor.visitSingularInt32Field(value: self.feedDir, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PwgRasterConfig.Resolution, rhs: Google_Cloudprint_PwgRasterConfig.Resolution) -> Bool {
    if lhs.crossFeedDir != rhs.crossFeedDir {return false}
    if lhs.feedDir != rhs.feedDir {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PwgRasterConfig.Transformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloudprint_PwgRasterConfig.protoMessageName + ".Transformation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "operand"),
    3: .standard(proto: "duplex_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.operation)
      case 2: try decoder.decodeSingularEnumField(value: &self.operand)
      case 3: try decoder.decodeRepeatedEnumField(value: &self.duplexType)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operation != .rotate180 {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 1)
    }
    if self.operand != .allPages {
      try visitor.visitSingularEnumField(value: self.operand, fieldNumber: 2)
    }
    if !self.duplexType.isEmpty {
      try visitor.visitPackedEnumField(value: self.duplexType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_PwgRasterConfig.Transformation, rhs: Google_Cloudprint_PwgRasterConfig.Transformation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.operand != rhs.operand {return false}
    if lhs.duplexType != rhs.duplexType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_PwgRasterConfig.Transformation.Operation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROTATE_180"),
    1: .same(proto: "FLIP_ON_LONG_EDGE"),
    2: .same(proto: "FLIP_ON_SHORT_EDGE"),
  ]
}

extension Google_Cloudprint_PwgRasterConfig.Transformation.Operand: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL_PAGES"),
    1: .same(proto: "ONLY_DUPLEXED_EVEN_PAGES"),
    2: .same(proto: "ONLY_DUPLEXED_ODD_PAGES"),
    3: .same(proto: "EVEN_PAGES"),
    4: .same(proto: "ODD_PAGES"),
  ]
}

extension Google_Cloudprint_InputTrayUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputTrayUnit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_id"),
    2: .same(proto: "type"),
    3: .same(proto: "index"),
    4: .standard(proto: "custom_display_name"),
    5: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.vendorID)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.index)
      case 4: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 1)
    }
    if self.type != .custom {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 3)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 4)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_InputTrayUnit, rhs: Google_Cloudprint_InputTrayUnit) -> Bool {
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_InputTrayUnit.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "INPUT_TRAY"),
    2: .same(proto: "BYPASS_TRAY"),
    3: .same(proto: "MANUAL_FEED_TRAY"),
    4: .same(proto: "LCT"),
    5: .same(proto: "ENVELOPE_TRAY"),
    6: .same(proto: "ROLL"),
  ]
}

extension Google_Cloudprint_OutputBinUnit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputBinUnit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vendor_id"),
    2: .same(proto: "type"),
    3: .same(proto: "index"),
    4: .standard(proto: "custom_display_name"),
    5: .standard(proto: "custom_display_name_localized"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.vendorID)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.index)
      case 4: try decoder.decodeSingularStringField(value: &self.customDisplayName)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.customDisplayNameLocalized)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vendorID.isEmpty {
      try visitor.visitSingularStringField(value: self.vendorID, fieldNumber: 1)
    }
    if self.type != .custom {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 3)
    }
    if !self.customDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.customDisplayName, fieldNumber: 4)
    }
    if !self.customDisplayNameLocalized.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customDisplayNameLocalized, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloudprint_OutputBinUnit, rhs: Google_Cloudprint_OutputBinUnit) -> Bool {
    if lhs.vendorID != rhs.vendorID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.customDisplayName != rhs.customDisplayName {return false}
    if lhs.customDisplayNameLocalized != rhs.customDisplayNameLocalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloudprint_OutputBinUnit.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOM"),
    1: .same(proto: "OUTPUT_BIN"),
    2: .same(proto: "MAILBOX"),
    3: .same(proto: "STACKER"),
  ]
}
