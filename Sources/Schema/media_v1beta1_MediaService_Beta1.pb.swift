// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: media/v1beta1/MediaService_Beta1.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates known errors that may be thrown by media operations.
public enum Bloombox_Schema_Services_Media_V1beta1_MediaError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No error was encountered.
  case noError // = 0

  /// The specified partner ID is invalid.
  case partnerInvalid // = 1

  /// The specified location ID is invalid.
  case locationInvalid // = 2

  /// The configured access permissions do not allow the requested operation.
  case accessDenied // = 3

  /// The specified media item could not be located.
  case mediaNotFound // = 4

  /// The specified media item or media request was invalid.
  case mediaInvalid // = 5

  /// The server encountered some internal error.
  case internalError // = 99
  case UNRECOGNIZED(Int)

  public init() {
    self = .noError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 1: self = .partnerInvalid
    case 2: self = .locationInvalid
    case 3: self = .accessDenied
    case 4: self = .mediaNotFound
    case 5: self = .mediaInvalid
    case 99: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noError: return 0
    case .partnerInvalid: return 1
    case .locationInvalid: return 2
    case .accessDenied: return 3
    case .mediaNotFound: return 4
    case .mediaInvalid: return 5
    case .internalError: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Specifies the subject properties of this media. That is to say, properties of the item of which this media is the
/// subject. Also referred to as this media item's "parent" in some cases.
public struct Bloombox_Schema_Services_Media_V1beta1_MediaSubject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of this media item, with regard to it's subject parent. Optional.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Specified subject attachment for this media. Can be a product key, or a partnership, or location-level key, to
  /// facilitate later garbage collection of unused media.
  public var attachment: OneOf_Attachment? {
    get {return _storage._attachment}
    set {_uniqueStorage()._attachment = newValue}
  }

  /// Specify a product key as the subject parent of this media.
  public var product: Opencannabis_Base_ProductKey {
    get {
      if case .product(let v)? = _storage._attachment {return v}
      return Opencannabis_Base_ProductKey()
    }
    set {_uniqueStorage()._attachment = .product(newValue)}
  }

  /// Specify a partner as the subject parent of this media.
  public var partner: Bloombox_Schema_Partner_PartnerKey {
    get {
      if case .partner(let v)? = _storage._attachment {return v}
      return Bloombox_Schema_Partner_PartnerKey()
    }
    set {_uniqueStorage()._attachment = .partner(newValue)}
  }

  /// Specify a partner and location as the subject parent of this media.
  public var location: Bloombox_Schema_Partner_PartnerLocationKey {
    get {
      if case .location(let v)? = _storage._attachment {return v}
      return Bloombox_Schema_Partner_PartnerLocationKey()
    }
    set {_uniqueStorage()._attachment = .location(newValue)}
  }

  /// Specify this media as global. This is a special flag that should only be used internally.
  public var global: Bool {
    get {
      if case .global(let v)? = _storage._attachment {return v}
      return false
    }
    set {_uniqueStorage()._attachment = .global(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specified subject attachment for this media. Can be a product key, or a partnership, or location-level key, to
  /// facilitate later garbage collection of unused media.
  public enum OneOf_Attachment: Equatable {
    /// Specify a product key as the subject parent of this media.
    case product(Opencannabis_Base_ProductKey)
    /// Specify a partner as the subject parent of this media.
    case partner(Bloombox_Schema_Partner_PartnerKey)
    /// Specify a partner and location as the subject parent of this media.
    case location(Bloombox_Schema_Partner_PartnerLocationKey)
    /// Specify this media as global. This is a special flag that should only be used internally.
    case global(Bool)

    public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_MediaSubject.OneOf_Attachment, rhs: Bloombox_Schema_Services_Media_V1beta1_MediaSubject.OneOf_Attachment) -> Bool {
      switch (lhs, rhs) {
      case (.product(let l), .product(let r)): return l == r
      case (.partner(let l), .partner(let r)): return l == r
      case (.location(let l), .location(let r)): return l == r
      case (.global(let l), .global(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a payload containing a media file upload.
public struct Bloombox_Schema_Services_Media_V1beta1_MediaFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file being uploaded.
  public var filename: String = String()

  /// Content mime-type of the file being uploaded, if known.
  public var mimetype: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies media content uploaded inline via the API, if applicable for a given media upload request.
public struct Bloombox_Schema_Services_Media_V1beta1_MediaContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw data for the media content being uploaded, if applicable.
  public var content: Data {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Type specification for the media being uploaded.
  public var type: Opencannabis_Media_MediaType {
    get {return _storage._type ?? Opencannabis_Media_MediaType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_storage._type = nil}

  /// Specification for the data to be uploaded. Either a file, in which case, a mime type and/or filename can be
  /// provided, or a blob flag indicating it's just raw data.
  public var spec: OneOf_Spec? {
    get {return _storage._spec}
    set {_uniqueStorage()._spec = newValue}
  }

  /// Information about the file being uploaded, including the filename and content mime type.
  public var file: Bloombox_Schema_Services_Media_V1beta1_MediaFile {
    get {
      if case .file(let v)? = _storage._spec {return v}
      return Bloombox_Schema_Services_Media_V1beta1_MediaFile()
    }
    set {_uniqueStorage()._spec = .file(newValue)}
  }

  /// Flag indicating the specified/attached content is a raw data blob.
  public var blob: Bool {
    get {
      if case .blob(let v)? = _storage._spec {return v}
      return false
    }
    set {_uniqueStorage()._spec = .blob(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specification for the data to be uploaded. Either a file, in which case, a mime type and/or filename can be
  /// provided, or a blob flag indicating it's just raw data.
  public enum OneOf_Spec: Equatable {
    /// Information about the file being uploaded, including the filename and content mime type.
    case file(Bloombox_Schema_Services_Media_V1beta1_MediaFile)
    /// Flag indicating the specified/attached content is a raw data blob.
    case blob(Bool)

    public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_MediaContent.OneOf_Spec, rhs: Bloombox_Schema_Services_Media_V1beta1_MediaContent.OneOf_Spec) -> Bool {
      switch (lhs, rhs) {
      case (.file(let l), .file(let r)): return l == r
      case (.blob(let l), .blob(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a resumeable upload operation, created and authorized in response to a request to upload a new media item
/// from a web browser.
public struct Bloombox_Schema_Services_Media_V1beta1_UploadTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URI to upload the data to.
  public var target: String = String()

  /// Token uniquely identifying this upload transaction, so the resulting media may later be attached after being
  /// uploaded by the client.
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Media operation result, when data/operations are performed inline with a request and do not require followup.
public struct Bloombox_Schema_Services_Media_V1beta1_OperationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resulting key, provisioned fresh for this media item.
  public var key: Opencannabis_Media_MediaKey {
    get {return _storage._key ?? Opencannabis_Media_MediaKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_storage._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies an RPC operation to upload a new piece of media, provisioning a media item record (and key) along the way.
/// The resulting key, or an error encountered while attempting to fulfill the operation, is returned.
public struct Bloombox_Schema_Services_Media_V1beta1_UploadMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies an RPC request to upload a new media item.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Partnership scope value. Includes the partner account and location.
    public var scope: String {
      get {return _storage._scope}
      set {_uniqueStorage()._scope = newValue}
    }

    /// Subject attachment and scoping settings for the media item to be created.
    public var subject: Bloombox_Schema_Services_Media_V1beta1_MediaSubject {
      get {return _storage._subject ?? Bloombox_Schema_Services_Media_V1beta1_MediaSubject()}
      set {_uniqueStorage()._subject = newValue}
    }
    /// Returns true if `subject` has been explicitly set.
    public var hasSubject: Bool {return _storage._subject != nil}
    /// Clears the value of `subject`. Subsequent reads from it will return its default value.
    public mutating func clearSubject() {_storage._subject = nil}

    /// Inline media content, if applicable to this request.
    public var content: Bloombox_Schema_Services_Media_V1beta1_MediaContent {
      get {return _storage._content ?? Bloombox_Schema_Services_Media_V1beta1_MediaContent()}
      set {_uniqueStorage()._content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    public var hasContent: Bool {return _storage._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    public mutating func clearContent() {_storage._content = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies the response to a request to upload a new media item.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Followup operation specified in response to the specified media upload request, if any/applicable.
    public var operation: OneOf_Operation? {
      get {return _storage._operation}
      set {_uniqueStorage()._operation = newValue}
    }

    /// Specifies an upload transaction, created/provisioned in response to the specified media upload request. When
    /// this property is specified, the client is expected to transmit its upload data to the URI target specified in
    /// this payload.
    public var transaction: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction {
      get {
        if case .transaction(let v)? = _storage._operation {return v}
        return Bloombox_Schema_Services_Media_V1beta1_UploadTransaction()
      }
      set {_uniqueStorage()._operation = .transaction(newValue)}
    }

    /// Specifies the result of an upload operation, when data is provided inline, or otherwise, no followup is
    /// required by the client to complete the operation.
    public var result: Bloombox_Schema_Services_Media_V1beta1_OperationResult {
      get {
        if case .result(let v)? = _storage._operation {return v}
        return Bloombox_Schema_Services_Media_V1beta1_OperationResult()
      }
      set {_uniqueStorage()._operation = .result(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Followup operation specified in response to the specified media upload request, if any/applicable.
    public enum OneOf_Operation: Equatable {
      /// Specifies an upload transaction, created/provisioned in response to the specified media upload request. When
      /// this property is specified, the client is expected to transmit its upload data to the URI target specified in
      /// this payload.
      case transaction(Bloombox_Schema_Services_Media_V1beta1_UploadTransaction)
      /// Specifies the result of an upload operation, when data is provided inline, or otherwise, no followup is
      /// required by the client to complete the operation.
      case result(Bloombox_Schema_Services_Media_V1beta1_OperationResult)

      public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response.OneOf_Operation, rhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response.OneOf_Operation) -> Bool {
        switch (lhs, rhs) {
        case (.transaction(let l), .transaction(let r)): return l == r
        case (.result(let l), .result(let r)): return l == r
        default: return false
        }
      }
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies an RPC operation notifying the server that a piece of media has completed uploading, and is ready to be
/// attached to a given media subject parent.
public struct Bloombox_Schema_Services_Media_V1beta1_AttachMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request payload representing a client's desire to attach an uploaded piece of media to its specified subject parent
  /// object, once followup is complete.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Partnership scope for the request, including the partner code and location code.
    public var scope: String = String()

    /// Upload transaction token, returned in a request to provision a new media upload.
    public var token: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.schema.services.media.v1beta1"

extension Bloombox_Schema_Services_Media_V1beta1_MediaError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    1: .same(proto: "PARTNER_INVALID"),
    2: .same(proto: "LOCATION_INVALID"),
    3: .same(proto: "ACCESS_DENIED"),
    4: .same(proto: "MEDIA_NOT_FOUND"),
    5: .same(proto: "MEDIA_INVALID"),
    99: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Bloombox_Schema_Services_Media_V1beta1_MediaSubject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaSubject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "product"),
    3: .same(proto: "partner"),
    4: .same(proto: "location"),
    5: .same(proto: "global"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _attachment: Bloombox_Schema_Services_Media_V1beta1_MediaSubject.OneOf_Attachment?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _attachment = source._attachment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2:
          var v: Opencannabis_Base_ProductKey?
          if let current = _storage._attachment {
            try decoder.handleConflictingOneOf()
            if case .product(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._attachment = .product(v)}
        case 3:
          var v: Bloombox_Schema_Partner_PartnerKey?
          if let current = _storage._attachment {
            try decoder.handleConflictingOneOf()
            if case .partner(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._attachment = .partner(v)}
        case 4:
          var v: Bloombox_Schema_Partner_PartnerLocationKey?
          if let current = _storage._attachment {
            try decoder.handleConflictingOneOf()
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._attachment = .location(v)}
        case 5:
          if _storage._attachment != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._attachment = .global(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      switch _storage._attachment {
      case .product(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .partner(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .location(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .global(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_MediaSubject) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._attachment != other_storage._attachment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_MediaFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "mimetype"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.filename)
      case 2: try decoder.decodeSingularStringField(value: &self.mimetype)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if !self.mimetype.isEmpty {
      try visitor.visitSingularStringField(value: self.mimetype, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_MediaFile) -> Bool {
    if self.filename != other.filename {return false}
    if self.mimetype != other.mimetype {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_MediaContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "type"),
    3: .same(proto: "file"),
    4: .same(proto: "blob"),
  ]

  fileprivate class _StorageClass {
    var _content: Data = SwiftProtobuf.Internal.emptyData
    var _type: Opencannabis_Media_MediaType? = nil
    var _spec: Bloombox_Schema_Services_Media_V1beta1_MediaContent.OneOf_Spec?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
      _type = source._type
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._content)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 3:
          var v: Bloombox_Schema_Services_Media_V1beta1_MediaFile?
          if let current = _storage._spec {
            try decoder.handleConflictingOneOf()
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._spec = .file(v)}
        case 4:
          if _storage._spec != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._spec = .blob(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._content.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._content, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._spec {
      case .file(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .blob(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_MediaContent) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._content != other_storage._content {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._spec != other_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.target)
      case 2: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction) -> Bool {
    if self.target != other.target {return false}
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_OperationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _key: Opencannabis_Media_MediaKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_OperationResult) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._key != other_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_UploadMedia) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_UploadMedia.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "subject"),
    3: .same(proto: "content"),
  ]

  fileprivate class _StorageClass {
    var _scope: String = String()
    var _subject: Bloombox_Schema_Services_Media_V1beta1_MediaSubject? = nil
    var _content: Bloombox_Schema_Services_Media_V1beta1_MediaContent? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _subject = source._subject
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._scope)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._subject)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._content)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 1)
      }
      if let v = _storage._subject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Request) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._scope != other_storage._scope {return false}
        if _storage._subject != other_storage._subject {return false}
        if _storage._content != other_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_UploadMedia.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _operation: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response.OneOf_Operation?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .transaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .transaction(v)}
        case 2:
          var v: Bloombox_Schema_Services_Media_V1beta1_OperationResult?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .result(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .result(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._operation {
      case .transaction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .result(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._operation != other_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_AttachMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttachMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_AttachMedia) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_AttachMedia.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_AttachMedia.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.scope)
      case 2: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Media_V1beta1_AttachMedia.Request) -> Bool {
    if self.scope != other.scope {return false}
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
