// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: media/v1beta1/MediaService_Beta1.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Provides the media service, which is responsible for uploading/managing/resolving media files on behalf of
/// multitenant partner/location accounts.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates known errors that may be thrown by media operations.
public enum Bloombox_Schema_Services_Media_V1beta1_MediaError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No error was encountered.
  case noError // = 0

  /// The specified partner ID is invalid.
  case partnerInvalid // = 1

  /// The specified location ID is invalid.
  case locationInvalid // = 2

  /// The configured access permissions do not allow the requested operation.
  case accessDenied // = 3

  /// The specified media item could not be located.
  case mediaNotFound // = 4

  /// The specified media item or media request was invalid.
  case mediaInvalid // = 5

  /// The server encountered some internal error.
  case internalError // = 99
  case UNRECOGNIZED(Int)

  public init() {
    self = .noError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 1: self = .partnerInvalid
    case 2: self = .locationInvalid
    case 3: self = .accessDenied
    case 4: self = .mediaNotFound
    case 5: self = .mediaInvalid
    case 99: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noError: return 0
    case .partnerInvalid: return 1
    case .locationInvalid: return 2
    case .accessDenied: return 3
    case .mediaNotFound: return 4
    case .mediaInvalid: return 5
    case .internalError: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Schema_Services_Media_V1beta1_MediaError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Schema_Services_Media_V1beta1_MediaError] = [
    .noError,
    .partnerInvalid,
    .locationInvalid,
    .accessDenied,
    .mediaNotFound,
    .mediaInvalid,
    .internalError,
  ]
}

#endif  // swift(>=4.2)

/// Specifies a payload containing a media file upload.
public struct Bloombox_Schema_Services_Media_V1beta1_MediaFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the file being uploaded.
  public var filename: String = String()

  /// Content mime-type of the file being uploaded, if known.
  public var mimetype: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies media content uploaded inline via the API, if applicable for a given media upload request.
public struct Bloombox_Schema_Services_Media_V1beta1_MediaContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type specification for the media being uploaded.
  public var type: Opencannabis_Media_MediaType {
    get {return _storage._type ?? Opencannabis_Media_MediaType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// Specification for the data to be uploaded. Either a file, in which case, a mime type and/or filename can be
  /// provided, or a blob flag indicating it's just raw data.
  public var spec: OneOf_Spec? {
    get {return _storage._spec}
    set {_uniqueStorage()._spec = newValue}
  }

  /// Information about the file being uploaded, including the filename and content mime type.
  public var file: Bloombox_Schema_Services_Media_V1beta1_MediaFile {
    get {
      if case .file(let v)? = _storage._spec {return v}
      return Bloombox_Schema_Services_Media_V1beta1_MediaFile()
    }
    set {_uniqueStorage()._spec = .file(newValue)}
  }

  /// Flag indicating the specified/attached content is a raw data blob.
  public var blob: Bool {
    get {
      if case .blob(let v)? = _storage._spec {return v}
      return false
    }
    set {_uniqueStorage()._spec = .blob(newValue)}
  }

  /// Raw data for the media content being uploaded, if applicable.
  public var content: Opencannabis_Content_Content {
    get {return _storage._content ?? Opencannabis_Content_Content()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {_uniqueStorage()._content = nil}

  /// Name to give the media. Optional, and should be a human-readable label. Not usually based on a filename.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specification for the data to be uploaded. Either a file, in which case, a mime type and/or filename can be
  /// provided, or a blob flag indicating it's just raw data.
  public enum OneOf_Spec: Equatable {
    /// Information about the file being uploaded, including the filename and content mime type.
    case file(Bloombox_Schema_Services_Media_V1beta1_MediaFile)
    /// Flag indicating the specified/attached content is a raw data blob.
    case blob(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_MediaContent.OneOf_Spec, rhs: Bloombox_Schema_Services_Media_V1beta1_MediaContent.OneOf_Spec) -> Bool {
      switch (lhs, rhs) {
      case (.file(let l), .file(let r)): return l == r
      case (.blob(let l), .blob(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a resumeable upload operation, created and authorized in response to a request to upload a new media item
/// from a web browser.
public struct Bloombox_Schema_Services_Media_V1beta1_UploadTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URI to upload the data to.
  public var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  /// Key provisioned for the media item we are being asked to accept as an upload.
  public var key: Opencannabis_Media_MediaKey {
    get {return _storage._key ?? Opencannabis_Media_MediaKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Media operation result, when data/operations are performed inline with a request and do not require followup.
public struct Bloombox_Schema_Services_Media_V1beta1_OperationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URI to access this item.
  public var item: Opencannabis_Media_MediaItem {
    get {return _storage._item ?? Opencannabis_Media_MediaItem()}
    set {_uniqueStorage()._item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return _storage._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {_uniqueStorage()._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies an RPC structure and operation to list media items for a given partner/location scope.
public struct Bloombox_Schema_Services_Media_V1beta1_ListMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to list media items for a given scope.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Partnership scope for the request.
    public var scope: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Response containing a list of media items.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resulting media item records list.
    public var media: [Opencannabis_Media_MediaItem] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an RPC structure and operation to retrieve an individual media item record, stored under a partner/location
/// account scope value.
public struct Bloombox_Schema_Services_Media_V1beta1_GetMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to retrieve an individual media item record.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Partnership scope for the request.
    public var scope: String {
      get {return _storage._scope}
      set {_uniqueStorage()._scope = newValue}
    }

    /// Key for the media item being requested.
    public var key: Opencannabis_Media_MediaKey {
      get {return _storage._key ?? Opencannabis_Media_MediaKey()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response containing the resulting media item, if any.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resulting media item record.
    public var media: Opencannabis_Media_MediaItem {
      get {return _storage._media ?? Opencannabis_Media_MediaItem()}
      set {_uniqueStorage()._media = newValue}
    }
    /// Returns true if `media` has been explicitly set.
    public var hasMedia: Bool {return _storage._media != nil}
    /// Clears the value of `media`. Subsequent reads from it will return its default value.
    public mutating func clearMedia() {_uniqueStorage()._media = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies an RPC operation to upload a new piece of media, provisioning a media item record (and key) along the way.
/// The resulting key, or an error encountered while attempting to fulfill the operation, is returned.
public struct Bloombox_Schema_Services_Media_V1beta1_UploadMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies an RPC request to upload a new media item.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Partnership scope value. Includes the partner account and location.
    public var scope: String {
      get {return _storage._scope}
      set {_uniqueStorage()._scope = newValue}
    }

    /// Subject attachment and scoping settings for the media item to be created.
    public var subject: Opencannabis_Media_MediaSubject {
      get {return _storage._subject ?? Opencannabis_Media_MediaSubject()}
      set {_uniqueStorage()._subject = newValue}
    }
    /// Returns true if `subject` has been explicitly set.
    public var hasSubject: Bool {return _storage._subject != nil}
    /// Clears the value of `subject`. Subsequent reads from it will return its default value.
    public mutating func clearSubject() {_uniqueStorage()._subject = nil}

    /// Inline media content, if applicable to this request.
    public var content: Bloombox_Schema_Services_Media_V1beta1_MediaContent {
      get {return _storage._content ?? Bloombox_Schema_Services_Media_V1beta1_MediaContent()}
      set {_uniqueStorage()._content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    public var hasContent: Bool {return _storage._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    public mutating func clearContent() {_uniqueStorage()._content = nil}

    /// Whether the content should be exposed publicly, or at some other privacy level.
    public var privacy: Opencannabis_Media_MediaPrivacy {
      get {return _storage._privacy}
      set {_uniqueStorage()._privacy = newValue}
    }

    /// Origin from which we are uploading data.
    public var origin: String {
      get {return _storage._origin}
      set {_uniqueStorage()._origin = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Specifies the response to a request to upload a new media item.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Followup operation specified in response to the specified media upload request, if any/applicable.
    public var operation: OneOf_Operation? {
      get {return _storage._operation}
      set {_uniqueStorage()._operation = newValue}
    }

    /// Specifies an upload transaction, created/provisioned in response to the specified media upload request. When
    /// this property is specified, the client is expected to transmit its upload data to the URI target specified in
    /// this payload.
    public var transaction: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction {
      get {
        if case .transaction(let v)? = _storage._operation {return v}
        return Bloombox_Schema_Services_Media_V1beta1_UploadTransaction()
      }
      set {_uniqueStorage()._operation = .transaction(newValue)}
    }

    /// Specifies the result of an upload operation, when data is provided inline, or otherwise, no followup is
    /// required by the client to complete the operation.
    public var result: Bloombox_Schema_Services_Media_V1beta1_OperationResult {
      get {
        if case .result(let v)? = _storage._operation {return v}
        return Bloombox_Schema_Services_Media_V1beta1_OperationResult()
      }
      set {_uniqueStorage()._operation = .result(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Followup operation specified in response to the specified media upload request, if any/applicable.
    public enum OneOf_Operation: Equatable {
      /// Specifies an upload transaction, created/provisioned in response to the specified media upload request. When
      /// this property is specified, the client is expected to transmit its upload data to the URI target specified in
      /// this payload.
      case transaction(Bloombox_Schema_Services_Media_V1beta1_UploadTransaction)
      /// Specifies the result of an upload operation, when data is provided inline, or otherwise, no followup is
      /// required by the client to complete the operation.
      case result(Bloombox_Schema_Services_Media_V1beta1_OperationResult)

    #if !swift(>=4.1)
      public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response.OneOf_Operation, rhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response.OneOf_Operation) -> Bool {
        switch (lhs, rhs) {
        case (.transaction(let l), .transaction(let r)): return l == r
        case (.result(let l), .result(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Specifies an RPC operation notifying the server that a piece of media has completed uploading, and is ready to be
/// attached to a given media subject parent.
public struct Bloombox_Schema_Services_Media_V1beta1_AttachMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request payload representing a client's desire to attach an uploaded piece of media to its specified subject parent
  /// object, once followup is complete.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Partnership scope for the request, including the partner code and location code.
    public var scope: String {
      get {return _storage._scope}
      set {_uniqueStorage()._scope = newValue}
    }

    /// Key for the media item to attach.
    public var key: Opencannabis_Media_MediaKey {
      get {return _storage._key ?? Opencannabis_Media_MediaKey()}
      set {_uniqueStorage()._key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return _storage._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {_uniqueStorage()._key = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.schema.services.media.v1beta1"

extension Bloombox_Schema_Services_Media_V1beta1_MediaError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    1: .same(proto: "PARTNER_INVALID"),
    2: .same(proto: "LOCATION_INVALID"),
    3: .same(proto: "ACCESS_DENIED"),
    4: .same(proto: "MEDIA_NOT_FOUND"),
    5: .same(proto: "MEDIA_INVALID"),
    99: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Bloombox_Schema_Services_Media_V1beta1_MediaFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "mimetype"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.filename)
      case 2: try decoder.decodeSingularStringField(value: &self.mimetype)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 1)
    }
    if !self.mimetype.isEmpty {
      try visitor.visitSingularStringField(value: self.mimetype, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_MediaFile, rhs: Bloombox_Schema_Services_Media_V1beta1_MediaFile) -> Bool {
    if lhs.filename != rhs.filename {return false}
    if lhs.mimetype != rhs.mimetype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_MediaContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "file"),
    3: .same(proto: "blob"),
    4: .same(proto: "content"),
    5: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _type: Opencannabis_Media_MediaType? = nil
    var _spec: Bloombox_Schema_Services_Media_V1beta1_MediaContent.OneOf_Spec?
    var _content: Opencannabis_Content_Content? = nil
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _spec = source._spec
      _content = source._content
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._type)
        case 2:
          var v: Bloombox_Schema_Services_Media_V1beta1_MediaFile?
          if let current = _storage._spec {
            try decoder.handleConflictingOneOf()
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._spec = .file(v)}
        case 3:
          if _storage._spec != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._spec = .blob(v)}
        case 4: try decoder.decodeSingularMessageField(value: &_storage._content)
        case 5: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._spec {
      case .file(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .blob(let v)?:
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_MediaContent, rhs: Bloombox_Schema_Services_Media_V1beta1_MediaContent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _target: String = String()
    var _key: Opencannabis_Media_MediaKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _target = source._target
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._target)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._key)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._target.isEmpty {
        try visitor.visitSingularStringField(value: _storage._target, fieldNumber: 1)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction, rhs: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._target != rhs_storage._target {return false}
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_OperationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  fileprivate class _StorageClass {
    var _item: Opencannabis_Media_MediaItem? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _item = source._item
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._item)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_OperationResult, rhs: Bloombox_Schema_Services_Media_V1beta1_OperationResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._item != rhs_storage._item {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_ListMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_ListMedia, rhs: Bloombox_Schema_Services_Media_V1beta1_ListMedia) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_ListMedia.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_ListMedia.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.scope)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_ListMedia.Request, rhs: Bloombox_Schema_Services_Media_V1beta1_ListMedia.Request) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_ListMedia.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_ListMedia.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "media"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.media)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.media.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.media, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_ListMedia.Response, rhs: Bloombox_Schema_Services_Media_V1beta1_ListMedia.Response) -> Bool {
    if lhs.media != rhs.media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_GetMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_GetMedia, rhs: Bloombox_Schema_Services_Media_V1beta1_GetMedia) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_GetMedia.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_GetMedia.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _scope: String = String()
    var _key: Opencannabis_Media_MediaKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._scope)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._key)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 1)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_GetMedia.Request, rhs: Bloombox_Schema_Services_Media_V1beta1_GetMedia.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_GetMedia.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_GetMedia.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "media"),
  ]

  fileprivate class _StorageClass {
    var _media: Opencannabis_Media_MediaItem? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _media = source._media
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._media)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._media {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_GetMedia.Response, rhs: Bloombox_Schema_Services_Media_V1beta1_GetMedia.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._media != rhs_storage._media {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia, rhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_UploadMedia.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "subject"),
    3: .same(proto: "content"),
    4: .same(proto: "privacy"),
    5: .same(proto: "origin"),
  ]

  fileprivate class _StorageClass {
    var _scope: String = String()
    var _subject: Opencannabis_Media_MediaSubject? = nil
    var _content: Bloombox_Schema_Services_Media_V1beta1_MediaContent? = nil
    var _privacy: Opencannabis_Media_MediaPrivacy = .defaultPrivacy
    var _origin: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _subject = source._subject
      _content = source._content
      _privacy = source._privacy
      _origin = source._origin
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._scope)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._subject)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._content)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._privacy)
        case 5: try decoder.decodeSingularStringField(value: &_storage._origin)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 1)
      }
      if let v = _storage._subject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._privacy != .defaultPrivacy {
        try visitor.visitSingularEnumField(value: _storage._privacy, fieldNumber: 4)
      }
      if !_storage._origin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._origin, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Request, rhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._privacy != rhs_storage._privacy {return false}
        if _storage._origin != rhs_storage._origin {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_UploadMedia.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _operation: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response.OneOf_Operation?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Bloombox_Schema_Services_Media_V1beta1_UploadTransaction?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .transaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .transaction(v)}
        case 2:
          var v: Bloombox_Schema_Services_Media_V1beta1_OperationResult?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .result(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .result(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._operation {
      case .transaction(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .result(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response, rhs: Bloombox_Schema_Services_Media_V1beta1_UploadMedia.Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operation != rhs_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_AttachMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttachMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_AttachMedia, rhs: Bloombox_Schema_Services_Media_V1beta1_AttachMedia) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Media_V1beta1_AttachMedia.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Bloombox_Schema_Services_Media_V1beta1_AttachMedia.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _scope: String = String()
    var _key: Opencannabis_Media_MediaKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._scope)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._key)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 1)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Services_Media_V1beta1_AttachMedia.Request, rhs: Bloombox_Schema_Services_Media_V1beta1_AttachMedia.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
