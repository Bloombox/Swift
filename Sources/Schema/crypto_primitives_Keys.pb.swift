// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: crypto/primitives/Keys.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies basic types of keying. Options include "symmetric," which describes keys that are shared in some manner or
/// otherwise expected to be equal during encryption and decryption, and "asymmetric," which describes keying systems
/// that include the notion of a "public" and "private" member of a keypair.
public enum Opencannabis_Crypto_KeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Symmetric and/or pre-shared keys.
  case symmetric // = 0

  /// Asymmetric keying.
  case asymmetric // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .symmetric
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .symmetric
    case 1: self = .asymmetric
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .symmetric: return 0
    case .asymmetric: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_KeyType] = [
    .symmetric,
    .asymmetric,
  ]
}

#endif  // swift(>=4.2)

/// Specifies the known key disposition options for a given key. This indicates the use parameters for a key structure.
/// Secret keys, or private keys, should always be kept private. Ephemeral keys are private but meant for temporally
/// bounded use in some specific context or circumstance.
public enum Opencannabis_Crypto_KeyDisposition: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Secret key for a symmetric connection, or the private portion of an asymmetric keypair.
  case `private` // = 0

  /// Ephemeral key for a given session or specific context. Considered secret.
  case ephemeral // = 1

  /// Public portion of an asymmetric keypair.
  case `public` // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .private
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .private
    case 1: self = .ephemeral
    case 2: self = .public
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .private: return 0
    case .ephemeral: return 1
    case .public: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_KeyDisposition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_KeyDisposition] = [
    .private,
    .ephemeral,
    .public,
  ]
}

#endif  // swift(>=4.2)

/// Specifies known block cipher algorithms. Only the ciphers defined here are usable for sensitive data within the
/// OpenCannabis ecosystem. Other ciphers may be added in the future.
public enum Opencannabis_Crypto_BlockCipher: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified block cipher.
  case unspecifiedBlockCipher // = 0

  /// Advanced Encryption Standard.
  case aes // = 1

  /// Camellia block cipher.
  case camellia // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedBlockCipher
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedBlockCipher
    case 1: self = .aes
    case 2: self = .camellia
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedBlockCipher: return 0
    case .aes: return 1
    case .camellia: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_BlockCipher: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_BlockCipher] = [
    .unspecifiedBlockCipher,
    .aes,
    .camellia,
  ]
}

#endif  // swift(>=4.2)

/// Specifies known stream cipher algorithms. Only the ciphers defined here are usable for sensitive data within the
/// OpenCannabis ecosystem. Other ciphers may be added in the future.
public enum Opencannabis_Crypto_StreamCipher: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified stream cipher.
  case unspecifiedStreamCipher // = 0

  /// Rivest Cipher 5.
  case rc5 // = 1

  /// Rivest Cipher 6.
  case rc6 // = 2

  /// ChaCha20-Poly1305.
  case chacha20 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedStreamCipher
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedStreamCipher
    case 1: self = .rc5
    case 2: self = .rc6
    case 3: self = .chacha20
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedStreamCipher: return 0
    case .rc5: return 1
    case .rc6: return 2
    case .chacha20: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_StreamCipher: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_StreamCipher] = [
    .unspecifiedStreamCipher,
    .rc5,
    .rc6,
    .chacha20,
  ]
}

#endif  // swift(>=4.2)

/// Specifies known key agreement protocols. Only the algorithms defined here are usable for sensitive data within the
/// OpenCannabis ecosystem. Other protocols may be added in the future.
public enum Opencannabis_Crypto_KeyAgreement: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified key agreement protocol.
  case unspecifiedKeyAgreement // = 0

  /// Diffie-Hellman Ephemeral Key Exchange.
  case dhe // = 1

  /// Elliptic Curve Diffie-Hellman Ephemeral Key Exchange.
  case ecdhe // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedKeyAgreement
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedKeyAgreement
    case 1: self = .dhe
    case 2: self = .ecdhe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedKeyAgreement: return 0
    case .dhe: return 1
    case .ecdhe: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_KeyAgreement: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_KeyAgreement] = [
    .unspecifiedKeyAgreement,
    .dhe,
    .ecdhe,
  ]
}

#endif  // swift(>=4.2)

/// Specifies symmetric keying-based systems' block cipher operating mode. Some ciphers only support a subset of the
/// operating modes defined herein.
public enum Opencannabis_Crypto_BlockMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified block cipher operation mode.
  case unspecifiedBlockMode // = 0

  /// Electronic Code Book mode.
  case ecb // = 1

  /// Cipher Block Chaining mode.
  case cbc // = 2

  /// Cipher Feedback mode.
  case cfb // = 3

  /// Output Feedback mode.
  case ofb // = 4

  /// Counter mode.
  case ctr // = 5

  /// Counter with CBC-MAC mode.
  case ccm // = 6

  /// Galois Counter mode.
  case gcm // = 7

  /// XEX with Ciphertext Stealing mode.
  case xts // = 8

  /// Key Wrap Padding mode.
  case kwp // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedBlockMode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedBlockMode
    case 1: self = .ecb
    case 2: self = .cbc
    case 3: self = .cfb
    case 4: self = .ofb
    case 5: self = .ctr
    case 6: self = .ccm
    case 7: self = .gcm
    case 8: self = .xts
    case 9: self = .kwp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedBlockMode: return 0
    case .ecb: return 1
    case .cbc: return 2
    case .cfb: return 3
    case .ofb: return 4
    case .ctr: return 5
    case .ccm: return 6
    case .gcm: return 7
    case .xts: return 8
    case .kwp: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_BlockMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_BlockMode] = [
    .unspecifiedBlockMode,
    .ecb,
    .cbc,
    .cfb,
    .ofb,
    .ctr,
    .ccm,
    .gcm,
    .xts,
    .kwp,
  ]
}

#endif  // swift(>=4.2)

/// Enumerates PKI/asymmetric keying schemes supported by the system. RSA, ECC and DSA keying are usually used for TLS,
/// and in particular HTTPS (with DSA being in the far minority). EdDSA keying is used for distributed ledger operations.
public enum Opencannabis_Crypto_KeyingScheme: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// RSA keying.
  case rsa // = 0

  /// ECC (curve-based) keying.
  case ecc // = 1

  /// DSA keying.
  case dsa // = 2

  /// ED-DSA keying.
  case edDsa // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .rsa
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rsa
    case 1: self = .ecc
    case 2: self = .dsa
    case 3: self = .edDsa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rsa: return 0
    case .ecc: return 1
    case .dsa: return 2
    case .edDsa: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_KeyingScheme: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_KeyingScheme] = [
    .rsa,
    .ecc,
    .dsa,
    .edDsa,
  ]
}

#endif  // swift(>=4.2)

/// Specifies known initialization vector operating or allocation modes.
public enum Opencannabis_Crypto_InitializationVectorMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The IV is pre-shared or otherwise does not change.
  case staticIv // = 0

  /// The IV is generated, or derive-able, using a Time-based One-Time-Password (OTP) algorithm.
  case totp // = 1

  /// The IV is generated from a counter.
  case counter // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .staticIv
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .staticIv
    case 1: self = .totp
    case 2: self = .counter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .staticIv: return 0
    case .totp: return 1
    case .counter: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Crypto_InitializationVectorMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Crypto_InitializationVectorMode] = [
    .staticIv,
    .totp,
    .counter,
  ]
}

#endif  // swift(>=4.2)

/// Specifies parameters that are applicable specifically to ciphers operating on blocks of data, to include the block
/// cipher operating mode, and the cipher itself.
public struct Opencannabis_Crypto_BlockCipherParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the cipher in use.
  public var algorithm: Opencannabis_Crypto_BlockCipher = .unspecifiedBlockCipher

  /// Specifies the operating mode of the block cipher in use.
  public var mode: Opencannabis_Crypto_BlockMode = .unspecifiedBlockMode

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies parameters that are applicable to symmetric keys, or, keys shared between parties and identically used for
/// encryption and decryption.
public struct Opencannabis_Crypto_SymmetricKeyParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines the block or stream cipher in use for symmetric crypto.
  public var cipher: OneOf_Cipher? {
    get {return _storage._cipher}
    set {_uniqueStorage()._cipher = newValue}
  }

  /// Specifies a stream cipher.
  public var stream: Opencannabis_Crypto_StreamCipher {
    get {
      if case .stream(let v)? = _storage._cipher {return v}
      return .unspecifiedStreamCipher
    }
    set {_uniqueStorage()._cipher = .stream(newValue)}
  }

  /// Specifies a block cipher.
  public var block: Opencannabis_Crypto_BlockCipherParameters {
    get {
      if case .block(let v)? = _storage._cipher {return v}
      return Opencannabis_Crypto_BlockCipherParameters()
    }
    set {_uniqueStorage()._cipher = .block(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines the block or stream cipher in use for symmetric crypto.
  public enum OneOf_Cipher: Equatable {
    /// Specifies a stream cipher.
    case stream(Opencannabis_Crypto_StreamCipher)
    /// Specifies a block cipher.
    case block(Opencannabis_Crypto_BlockCipherParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Crypto_SymmetricKeyParameters.OneOf_Cipher, rhs: Opencannabis_Crypto_SymmetricKeyParameters.OneOf_Cipher) -> Bool {
      switch (lhs, rhs) {
      case (.stream(let l), .stream(let r)): return l == r
      case (.block(let l), .block(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies parameters that are applicable to asymmetric key pairs.
public struct Opencannabis_Crypto_AsymmetricKeypairParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asymmetric keying scheme in use.
  public var scheme: Opencannabis_Crypto_KeyingScheme {
    get {return _storage._scheme}
    set {_uniqueStorage()._scheme = newValue}
  }

  /// Fingerprint of the public key that was used in some circumstance.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies parameters used to generate an underlying keypair.
public struct Opencannabis_Crypto_KeyParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Algorithm in use to generate the key.
  public var algorithm: String {
    get {return _storage._algorithm}
    set {_uniqueStorage()._algorithm = newValue}
  }

  /// Format name for the key.
  public var format: String {
    get {return _storage._format}
    set {_uniqueStorage()._format = newValue}
  }

  /// Key size, in bits, if applicable.
  public var bits: UInt32 {
    get {return _storage._bits}
    set {_uniqueStorage()._bits = newValue}
  }

  /// Type/architecture of the keys.
  public var type: Opencannabis_Crypto_KeyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Disposition of the subject key (i.e. scope).
  public var disposition: Opencannabis_Crypto_KeyDisposition {
    get {return _storage._disposition}
    set {_uniqueStorage()._disposition = newValue}
  }

  /// General architecture and parameters for the key.
  public var architecture: OneOf_Architecture? {
    get {return _storage._architecture}
    set {_uniqueStorage()._architecture = newValue}
  }

  /// Key type/keying scheme.
  public var scheme: Opencannabis_Crypto_KeyingScheme {
    get {
      if case .scheme(let v)? = _storage._architecture {return v}
      return .rsa
    }
    set {_uniqueStorage()._architecture = .scheme(newValue)}
  }

  /// Specifies parameters for symmetric keying.
  public var symmetric: Opencannabis_Crypto_SymmetricKeyParameters {
    get {
      if case .symmetric(let v)? = _storage._architecture {return v}
      return Opencannabis_Crypto_SymmetricKeyParameters()
    }
    set {_uniqueStorage()._architecture = .symmetric(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// General architecture and parameters for the key.
  public enum OneOf_Architecture: Equatable {
    /// Key type/keying scheme.
    case scheme(Opencannabis_Crypto_KeyingScheme)
    /// Specifies parameters for symmetric keying.
    case symmetric(Opencannabis_Crypto_SymmetricKeyParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Crypto_KeyParameters.OneOf_Architecture, rhs: Opencannabis_Crypto_KeyParameters.OneOf_Architecture) -> Bool {
      switch (lhs, rhs) {
      case (.scheme(let l), .scheme(let r)): return l == r
      case (.symmetric(let l), .symmetric(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies information about an initialization vector value. IV lifecycle and use is governed by the specific
/// application or use case.
public struct Opencannabis_Crypto_InitializationVector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the operating mode for this IV, if applicable.
  public var mode: Opencannabis_Crypto_InitializationVectorMode = .staticIv

  /// Initialization vector value.
  public var value: Opencannabis_Crypto_InitializationVector.OneOf_Value? = nil

  /// Raw bytes for the vector.
  public var raw: Data {
    get {
      if case .raw(let v)? = value {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {value = .raw(newValue)}
  }

  /// Base64-encoded raw bytes for the vector.
  public var b64: String {
    get {
      if case .b64(let v)? = value {return v}
      return String()
    }
    set {value = .b64(newValue)}
  }

  /// Initialization number.
  public var number: UInt32 {
    get {
      if case .number(let v)? = value {return v}
      return 0
    }
    set {value = .number(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Initialization vector value.
  public enum OneOf_Value: Equatable {
    /// Raw bytes for the vector.
    case raw(Data)
    /// Base64-encoded raw bytes for the vector.
    case b64(String)
    /// Initialization number.
    case number(UInt32)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Crypto_InitializationVector.OneOf_Value, rhs: Opencannabis_Crypto_InitializationVector.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.raw(let l), .raw(let r)): return l == r
      case (.b64(let l), .b64(let r)): return l == r
      case (.number(let l), .number(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Specifies a symmetric encryption key, which is generally considered a secret value.
public struct Opencannabis_Crypto_SymmetricKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bit size for the underlying symmetric key.
  public var bits: UInt32 {
    get {return _storage._bits}
    set {_uniqueStorage()._bits = newValue}
  }

  /// Specifies an initialization vector value. Raw bytes should be encoded in Base64.
  public var iv: Opencannabis_Crypto_InitializationVector {
    get {return _storage._iv ?? Opencannabis_Crypto_InitializationVector()}
    set {_uniqueStorage()._iv = newValue}
  }
  /// Returns true if `iv` has been explicitly set.
  public var hasIv: Bool {return _storage._iv != nil}
  /// Clears the value of `iv`. Subsequent reads from it will return its default value.
  public mutating func clearIv() {_uniqueStorage()._iv = nil}

  /// Data for the underlying symmetric key.
  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// Specifies the raw bytes of the key.
  public var raw: Data {
    get {
      if case .raw(let v)? = _storage._data {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._data = .raw(newValue)}
  }

  /// Specifies the key bytes, encoded in base64.
  public var b64: String {
    get {
      if case .b64(let v)? = _storage._data {return v}
      return String()
    }
    set {_uniqueStorage()._data = .b64(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data for the underlying symmetric key.
  public enum OneOf_Data: Equatable {
    /// Specifies the raw bytes of the key.
    case raw(Data)
    /// Specifies the key bytes, encoded in base64.
    case b64(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Crypto_SymmetricKey.OneOf_Data, rhs: Opencannabis_Crypto_SymmetricKey.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.raw(let l), .raw(let r)): return l == r
      case (.b64(let l), .b64(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies raw or encoded key material data, which is to say, the actual public or private keys themselves. Key
/// material may be specified in raw binary form, encoded PEM form, or simply a cryptographic hash of their contents
/// (particularly when transmitting a hash of a public key).
public struct Opencannabis_Crypto_KeyMaterial {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cryptographic hash of the key in question.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  /// Parameters regarding the subject key.
  public var params: Opencannabis_Crypto_KeyParameters {
    get {return _storage._params ?? Opencannabis_Crypto_KeyParameters()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Raw data for the key in question.
  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  /// Raw bytes of the key itself.
  public var raw: Data {
    get {
      if case .raw(let v)? = _storage._data {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {_uniqueStorage()._data = .raw(newValue)}
  }

  /// Key, encoded in PEM format.
  public var pem: String {
    get {
      if case .pem(let v)? = _storage._data {return v}
      return String()
    }
    set {_uniqueStorage()._data = .pem(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Raw data for the key in question.
  public enum OneOf_Data: Equatable {
    /// Raw bytes of the key itself.
    case raw(Data)
    /// Key, encoded in PEM format.
    case pem(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Crypto_KeyMaterial.OneOf_Data, rhs: Opencannabis_Crypto_KeyMaterial.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.raw(let l), .raw(let r)): return l == r
      case (.pem(let l), .pem(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies key material for a set (pair) of asymmetric keys, which is to say, a public and a private key. This
/// structure may be used to transmit both keys in full, or just a hash of the public key, depending on the fields that
/// are filled in or not when the object is constructed.
public struct Opencannabis_Crypto_Keypair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public key. In PKI, the public key can be used only to encrypt data.
  public var `public`: Opencannabis_Crypto_KeyMaterial {
    get {return _storage._public ?? Opencannabis_Crypto_KeyMaterial()}
    set {_uniqueStorage()._public = newValue}
  }
  /// Returns true if ``public`` has been explicitly set.
  public var hasPublic: Bool {return _storage._public != nil}
  /// Clears the value of ``public``. Subsequent reads from it will return its default value.
  public mutating func clearPublic() {_uniqueStorage()._public = nil}

  /// Private key. In PKI, the private key can be used to encrypt or decrypt data.
  public var `private`: Opencannabis_Crypto_KeyMaterial {
    get {return _storage._private ?? Opencannabis_Crypto_KeyMaterial()}
    set {_uniqueStorage()._private = newValue}
  }
  /// Returns true if ``private`` has been explicitly set.
  public var hasPrivate: Bool {return _storage._private != nil}
  /// Clears the value of ``private``. Subsequent reads from it will return its default value.
  public mutating func clearPrivate() {_uniqueStorage()._private = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencannabis.crypto"

extension Opencannabis_Crypto_KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYMMETRIC"),
    1: .same(proto: "ASYMMETRIC"),
  ]
}

extension Opencannabis_Crypto_KeyDisposition: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIVATE"),
    1: .same(proto: "EPHEMERAL"),
    2: .same(proto: "PUBLIC"),
  ]
}

extension Opencannabis_Crypto_BlockCipher: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_BLOCK_CIPHER"),
    1: .same(proto: "AES"),
    2: .same(proto: "CAMELLIA"),
  ]
}

extension Opencannabis_Crypto_StreamCipher: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_STREAM_CIPHER"),
    1: .same(proto: "RC5"),
    2: .same(proto: "RC6"),
    3: .same(proto: "CHACHA20"),
  ]
}

extension Opencannabis_Crypto_KeyAgreement: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_KEY_AGREEMENT"),
    1: .same(proto: "DHE"),
    2: .same(proto: "ECDHE"),
  ]
}

extension Opencannabis_Crypto_BlockMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_BLOCK_MODE"),
    1: .same(proto: "ECB"),
    2: .same(proto: "CBC"),
    3: .same(proto: "CFB"),
    4: .same(proto: "OFB"),
    5: .same(proto: "CTR"),
    6: .same(proto: "CCM"),
    7: .same(proto: "GCM"),
    8: .same(proto: "XTS"),
    9: .same(proto: "KWP"),
  ]
}

extension Opencannabis_Crypto_KeyingScheme: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RSA"),
    1: .same(proto: "ECC"),
    2: .same(proto: "DSA"),
    3: .same(proto: "EdDSA"),
  ]
}

extension Opencannabis_Crypto_InitializationVectorMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATIC_IV"),
    1: .same(proto: "TOTP"),
    2: .same(proto: "COUNTER"),
  ]
}

extension Opencannabis_Crypto_BlockCipherParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockCipherParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "algorithm"),
    2: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.algorithm)
      case 2: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.algorithm != .unspecifiedBlockCipher {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 1)
    }
    if self.mode != .unspecifiedBlockMode {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_BlockCipherParameters, rhs: Opencannabis_Crypto_BlockCipherParameters) -> Bool {
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_SymmetricKeyParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymmetricKeyParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _cipher: Opencannabis_Crypto_SymmetricKeyParameters.OneOf_Cipher?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cipher = source._cipher
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._cipher != nil {try decoder.handleConflictingOneOf()}
          var v: Opencannabis_Crypto_StreamCipher?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._cipher = .stream(v)}
        case 2:
          var v: Opencannabis_Crypto_BlockCipherParameters?
          if let current = _storage._cipher {
            try decoder.handleConflictingOneOf()
            if case .block(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._cipher = .block(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._cipher {
      case .stream(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      case .block(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_SymmetricKeyParameters, rhs: Opencannabis_Crypto_SymmetricKeyParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cipher != rhs_storage._cipher {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_AsymmetricKeypairParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsymmetricKeypairParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scheme"),
    2: .same(proto: "fingerprint"),
  ]

  fileprivate class _StorageClass {
    var _scheme: Opencannabis_Crypto_KeyingScheme = .rsa
    var _fingerprint: Opencannabis_Crypto_Hash? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scheme = source._scheme
      _fingerprint = source._fingerprint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._scheme)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._scheme != .rsa {
        try visitor.visitSingularEnumField(value: _storage._scheme, fieldNumber: 1)
      }
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_AsymmetricKeypairParameters, rhs: Opencannabis_Crypto_AsymmetricKeypairParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scheme != rhs_storage._scheme {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_KeyParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "algorithm"),
    2: .same(proto: "format"),
    3: .same(proto: "bits"),
    4: .same(proto: "type"),
    5: .same(proto: "disposition"),
    10: .same(proto: "scheme"),
    11: .same(proto: "symmetric"),
  ]

  fileprivate class _StorageClass {
    var _algorithm: String = String()
    var _format: String = String()
    var _bits: UInt32 = 0
    var _type: Opencannabis_Crypto_KeyType = .symmetric
    var _disposition: Opencannabis_Crypto_KeyDisposition = .private
    var _architecture: Opencannabis_Crypto_KeyParameters.OneOf_Architecture?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _algorithm = source._algorithm
      _format = source._format
      _bits = source._bits
      _type = source._type
      _disposition = source._disposition
      _architecture = source._architecture
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._algorithm)
        case 2: try decoder.decodeSingularStringField(value: &_storage._format)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._bits)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._disposition)
        case 10:
          if _storage._architecture != nil {try decoder.handleConflictingOneOf()}
          var v: Opencannabis_Crypto_KeyingScheme?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._architecture = .scheme(v)}
        case 11:
          var v: Opencannabis_Crypto_SymmetricKeyParameters?
          if let current = _storage._architecture {
            try decoder.handleConflictingOneOf()
            if case .symmetric(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._architecture = .symmetric(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._algorithm.isEmpty {
        try visitor.visitSingularStringField(value: _storage._algorithm, fieldNumber: 1)
      }
      if !_storage._format.isEmpty {
        try visitor.visitSingularStringField(value: _storage._format, fieldNumber: 2)
      }
      if _storage._bits != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bits, fieldNumber: 3)
      }
      if _storage._type != .symmetric {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if _storage._disposition != .private {
        try visitor.visitSingularEnumField(value: _storage._disposition, fieldNumber: 5)
      }
      switch _storage._architecture {
      case .scheme(let v)?:
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      case .symmetric(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_KeyParameters, rhs: Opencannabis_Crypto_KeyParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._algorithm != rhs_storage._algorithm {return false}
        if _storage._format != rhs_storage._format {return false}
        if _storage._bits != rhs_storage._bits {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._disposition != rhs_storage._disposition {return false}
        if _storage._architecture != rhs_storage._architecture {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_InitializationVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitializationVector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    10: .same(proto: "raw"),
    11: .same(proto: "b64"),
    12: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      case 10:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.value = .raw(v)}
      case 11:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .b64(v)}
      case 12:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.value = .number(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .staticIv {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    switch self.value {
    case .raw(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    case .b64(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    case .number(let v)?:
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_InitializationVector, rhs: Opencannabis_Crypto_InitializationVector) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_SymmetricKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymmetricKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bits"),
    2: .same(proto: "iv"),
    10: .same(proto: "raw"),
    11: .same(proto: "b64"),
  ]

  fileprivate class _StorageClass {
    var _bits: UInt32 = 0
    var _iv: Opencannabis_Crypto_InitializationVector? = nil
    var _data: Opencannabis_Crypto_SymmetricKey.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _bits = source._bits
      _iv = source._iv
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._bits)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._iv)
        case 10:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._data = .raw(v)}
        case 11:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._data = .b64(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._bits != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bits, fieldNumber: 1)
      }
      if let v = _storage._iv {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._data {
      case .raw(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      case .b64(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_SymmetricKey, rhs: Opencannabis_Crypto_SymmetricKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bits != rhs_storage._bits {return false}
        if _storage._iv != rhs_storage._iv {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_KeyMaterial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyMaterial"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fingerprint"),
    2: .same(proto: "params"),
    10: .same(proto: "raw"),
    11: .same(proto: "pem"),
  ]

  fileprivate class _StorageClass {
    var _fingerprint: Opencannabis_Crypto_Hash? = nil
    var _params: Opencannabis_Crypto_KeyParameters? = nil
    var _data: Opencannabis_Crypto_KeyMaterial.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fingerprint = source._fingerprint
      _params = source._params
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._params)
        case 10:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._data = .raw(v)}
        case 11:
          if _storage._data != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._data = .pem(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._data {
      case .raw(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      case .pem(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_KeyMaterial, rhs: Opencannabis_Crypto_KeyMaterial) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Crypto_Keypair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Keypair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
    2: .same(proto: "private"),
  ]

  fileprivate class _StorageClass {
    var _public: Opencannabis_Crypto_KeyMaterial? = nil
    var _private: Opencannabis_Crypto_KeyMaterial? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _public = source._public
      _private = source._private
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._public)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._private)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._public {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._private {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Crypto_Keypair, rhs: Opencannabis_Crypto_Keypair) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._public != rhs_storage._public {return false}
        if _storage._private != rhs_storage._private {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
