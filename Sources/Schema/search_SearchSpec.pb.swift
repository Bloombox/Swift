// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: search/SearchSpec.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies structures that allow a caller to detail a search operation for a search request.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies system objects that searches can be performed on.
public enum Bloombox_Schema_Search_SearchableCollection: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Meta-collection representing all data.
  case global // = 0

  /// Include product catalog data.
  case products // = 1

  /// Include user and user profile data.
  case users // = 2

  /// Include partner data.
  case partners // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .global
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .global
    case 1: self = .products
    case 2: self = .users
    case 3: self = .partners
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .global: return 0
    case .products: return 1
    case .users: return 2
    case .partners: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Schema_Search_SearchableCollection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Schema_Search_SearchableCollection] = [
    .global,
    .products,
    .users,
    .partners,
  ]
}

#endif  // swift(>=4.2)

/// Specifies data extensions that may be requested, and returned, with stock search results.
public enum Bloombox_Schema_Search_SearchResultExtension: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Return the result's name along with its key. This is included in the default set of returned items when not
  /// searching in `keys_only` mode.
  case name // = 0

  /// Return the result's description along with its key. This is included in the default set of returned items when not
  /// searching in `keys_only` mode.
  case description_ // = 1

  /// Return at least one media link per result along with its key. This is included in the default set of returned items
  /// when not searching in `keys_only` mode.
  case media // = 2

  /// Return lab results in full along with each key.
  case labs // = 3

  /// Return pricing information along with each key.
  case pricing // = 4

  /// Return related item keys along with each key.
  case related // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .name
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .name
    case 1: self = .description_
    case 2: self = .media
    case 3: self = .labs
    case 4: self = .pricing
    case 5: self = .related
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .name: return 0
    case .description_: return 1
    case .media: return 2
    case .labs: return 3
    case .pricing: return 4
    case .related: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Schema_Search_SearchResultExtension: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Schema_Search_SearchResultExtension] = [
    .name,
    .description_,
    .media,
    .labs,
    .pricing,
    .related,
  ]
}

#endif  // swift(>=4.2)

/// Specifies available modes to highlight terms in search results.
public enum Bloombox_Schema_Search_ResultHighlightMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No highlighting is requested.
  case noHighlighting // = 0

  /// HTML highlighting is requested.
  case html // = 1

  /// Markdown highlighting is requested.
  case markdown // = 2

  /// Only return snippets of matching text.
  case snippet // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .noHighlighting
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noHighlighting
    case 1: self = .html
    case 2: self = .markdown
    case 3: self = .snippet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noHighlighting: return 0
    case .html: return 1
    case .markdown: return 2
    case .snippet: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Schema_Search_ResultHighlightMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Schema_Search_ResultHighlightMode] = [
    .noHighlighting,
    .html,
    .markdown,
    .snippet,
  ]
}

#endif  // swift(>=4.2)

/// Specifies modes for sorting search results.
public enum Bloombox_Schema_Search_SearchSortMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Let the server decide, using magic.
  case natural // = 0

  /// Lexicographically sort by name.
  case lexicographic // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .natural
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .natural
    case 1: self = .lexicographic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .natural: return 0
    case .lexicographic: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Bloombox_Schema_Search_SearchSortMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Bloombox_Schema_Search_SearchSortMode] = [
    .natural,
    .lexicographic,
  ]
}

#endif  // swift(>=4.2)

/// Specifies bounds for a search query.
public struct Bloombox_Schema_Search_SearchBounds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies a limit on the number of search results desired.
  public var limit: Int32 = 0

  /// Specifies an offset of records to skip during result pagination.
  public var offset: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies options for conducting a fulltext search operation.
public struct Bloombox_Schema_Search_SearchOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partner and location scope to apply during a search operation.
  public var scope: String = String()

  /// Menu sections to search in. If unspecified, search all sections.
  public var section: [Opencannabis_Products_Menu_Section_Section] = []

  /// Return products regardless of their visibility status.
  public var hidden: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies options for results returned from a search operation.
public struct Bloombox_Schema_Search_SearchResultOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only return matching keys - i.e. don't include other object data, like its name, description, or media asset links.
  public var keysOnly: Bool = false

  /// Enable result highlighting
  public var highlight: Bloombox_Schema_Search_ResultHighlightMode = .noHighlighting

  /// Specifies desired extensions to stock search result data.
  public var include: [Bloombox_Schema_Search_SearchResultExtension] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specification for a search operation.
public struct Bloombox_Schema_Search_SearchSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Value entered into a search box by a user, usually URL-encoded.
  public var term: String {
    get {return _storage._term}
    set {_uniqueStorage()._term = newValue}
  }

  /// Specifies globally-applicable options for a given search operation.
  public var options: Bloombox_Schema_Search_SearchOptions {
    get {return _storage._options ?? Bloombox_Schema_Search_SearchOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {_uniqueStorage()._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the count of items in a particular result category included in a search response.
public struct Bloombox_Schema_Search_ResultsetCategoricalCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the type of record enclosed with this count.
  public var type: Bloombox_Schema_Search_SearchableCollection = .global

  /// Specifies the count of that kind of record enclosed with this response.
  public var count: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies the bound calculated for a particular product result.
public struct Bloombox_Schema_Search_ProductResultBound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Low value for a given bound.
  public var low: Double = 0

  /// High value for a given bound.
  public var high: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies result metadata specific to product records.
public struct Bloombox_Schema_Search_ProductResultMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Price bounds.
  public var price: Bloombox_Schema_Search_ProductResultBound {
    get {return _storage._price ?? Bloombox_Schema_Search_ProductResultBound()}
    set {_uniqueStorage()._price = newValue}
  }
  /// Returns true if `price` has been explicitly set.
  public var hasPrice: Bool {return _storage._price != nil}
  /// Clears the value of `price`. Subsequent reads from it will return its default value.
  public mutating func clearPrice() {_uniqueStorage()._price = nil}

  /// THC bounds.
  public var thc: Bloombox_Schema_Search_ProductResultBound {
    get {return _storage._thc ?? Bloombox_Schema_Search_ProductResultBound()}
    set {_uniqueStorage()._thc = newValue}
  }
  /// Returns true if `thc` has been explicitly set.
  public var hasThc: Bool {return _storage._thc != nil}
  /// Clears the value of `thc`. Subsequent reads from it will return its default value.
  public mutating func clearThc() {_uniqueStorage()._thc = nil}

  /// CBD bounds.
  public var cbd: Bloombox_Schema_Search_ProductResultBound {
    get {return _storage._cbd ?? Bloombox_Schema_Search_ProductResultBound()}
    set {_uniqueStorage()._cbd = newValue}
  }
  /// Returns true if `cbd` has been explicitly set.
  public var hasCbd: Bool {return _storage._cbd != nil}
  /// Clears the value of `cbd`. Subsequent reads from it will return its default value.
  public mutating func clearCbd() {_uniqueStorage()._cbd = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies metadata for a search resultset.
public struct Bloombox_Schema_Search_SearchResultsetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of matching records, across all categorical types.
  public var count: [Bloombox_Schema_Search_ResultsetCategoricalCount] {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// Product-specific metadata.
  public var products: Bloombox_Schema_Search_ProductResultMetadata {
    get {return _storage._products ?? Bloombox_Schema_Search_ProductResultMetadata()}
    set {_uniqueStorage()._products = newValue}
  }
  /// Returns true if `products` has been explicitly set.
  public var hasProducts: Bool {return _storage._products != nil}
  /// Clears the value of `products`. Subsequent reads from it will return its default value.
  public mutating func clearProducts() {_uniqueStorage()._products = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a set of items returned as results to a search operation.
public struct Bloombox_Schema_Search_SearchResultset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies metadata about the resultset.
  public var metadata: Bloombox_Schema_Search_SearchResultsetMetadata {
    get {return _storage._metadata ?? Bloombox_Schema_Search_SearchResultsetMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Search results matching the provided query.
  public var payload: [Bloombox_Schema_Search_SearchResult] {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.schema.search"

extension Bloombox_Schema_Search_SearchableCollection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GLOBAL"),
    1: .same(proto: "PRODUCTS"),
    2: .same(proto: "USERS"),
    3: .same(proto: "PARTNERS"),
  ]
}

extension Bloombox_Schema_Search_SearchResultExtension: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NAME"),
    1: .same(proto: "DESCRIPTION"),
    2: .same(proto: "MEDIA"),
    3: .same(proto: "LABS"),
    4: .same(proto: "PRICING"),
    5: .same(proto: "RELATED"),
  ]
}

extension Bloombox_Schema_Search_ResultHighlightMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_HIGHLIGHTING"),
    1: .same(proto: "HTML"),
    2: .same(proto: "MARKDOWN"),
    3: .same(proto: "SNIPPET"),
  ]
}

extension Bloombox_Schema_Search_SearchSortMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NATURAL"),
    1: .same(proto: "LEXICOGRAPHIC"),
  ]
}

extension Bloombox_Schema_Search_SearchBounds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchBounds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limit"),
    2: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.limit)
      case 2: try decoder.decodeSingularInt32Field(value: &self.offset)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_SearchBounds, rhs: Bloombox_Schema_Search_SearchBounds) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_SearchOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "section"),
    3: .same(proto: "hidden"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.scope)
      case 2: try decoder.decodeRepeatedEnumField(value: &self.section)
      case 3: try decoder.decodeSingularBoolField(value: &self.hidden)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.section.isEmpty {
      try visitor.visitPackedEnumField(value: self.section, fieldNumber: 2)
    }
    if self.hidden != false {
      try visitor.visitSingularBoolField(value: self.hidden, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_SearchOptions, rhs: Bloombox_Schema_Search_SearchOptions) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.section != rhs.section {return false}
    if lhs.hidden != rhs.hidden {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_SearchResultOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResultOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keys_only"),
    2: .same(proto: "highlight"),
    3: .same(proto: "include"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.keysOnly)
      case 2: try decoder.decodeSingularEnumField(value: &self.highlight)
      case 3: try decoder.decodeRepeatedEnumField(value: &self.include)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keysOnly != false {
      try visitor.visitSingularBoolField(value: self.keysOnly, fieldNumber: 1)
    }
    if self.highlight != .noHighlighting {
      try visitor.visitSingularEnumField(value: self.highlight, fieldNumber: 2)
    }
    if !self.include.isEmpty {
      try visitor.visitPackedEnumField(value: self.include, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_SearchResultOptions, rhs: Bloombox_Schema_Search_SearchResultOptions) -> Bool {
    if lhs.keysOnly != rhs.keysOnly {return false}
    if lhs.highlight != rhs.highlight {return false}
    if lhs.include != rhs.include {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_SearchSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "term"),
    2: .same(proto: "options"),
  ]

  fileprivate class _StorageClass {
    var _term: String = String()
    var _options: Bloombox_Schema_Search_SearchOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _term = source._term
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._term)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._options)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._term.isEmpty {
        try visitor.visitSingularStringField(value: _storage._term, fieldNumber: 1)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_SearchSpec, rhs: Bloombox_Schema_Search_SearchSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._term != rhs_storage._term {return false}
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_ResultsetCategoricalCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResultsetCategoricalCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularInt32Field(value: &self.count)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .global {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_ResultsetCategoricalCount, rhs: Bloombox_Schema_Search_ResultsetCategoricalCount) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_ProductResultBound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductResultBound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "low"),
    2: .same(proto: "high"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.low)
      case 2: try decoder.decodeSingularDoubleField(value: &self.high)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.low != 0 {
      try visitor.visitSingularDoubleField(value: self.low, fieldNumber: 1)
    }
    if self.high != 0 {
      try visitor.visitSingularDoubleField(value: self.high, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_ProductResultBound, rhs: Bloombox_Schema_Search_ProductResultBound) -> Bool {
    if lhs.low != rhs.low {return false}
    if lhs.high != rhs.high {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_ProductResultMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductResultMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "price"),
    2: .same(proto: "thc"),
    3: .same(proto: "cbd"),
  ]

  fileprivate class _StorageClass {
    var _price: Bloombox_Schema_Search_ProductResultBound? = nil
    var _thc: Bloombox_Schema_Search_ProductResultBound? = nil
    var _cbd: Bloombox_Schema_Search_ProductResultBound? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _price = source._price
      _thc = source._thc
      _cbd = source._cbd
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._price)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._thc)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._cbd)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._price {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._thc {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._cbd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_ProductResultMetadata, rhs: Bloombox_Schema_Search_ProductResultMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._price != rhs_storage._price {return false}
        if _storage._thc != rhs_storage._thc {return false}
        if _storage._cbd != rhs_storage._cbd {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_SearchResultsetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResultsetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "products"),
  ]

  fileprivate class _StorageClass {
    var _count: [Bloombox_Schema_Search_ResultsetCategoricalCount] = []
    var _products: Bloombox_Schema_Search_ProductResultMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _count = source._count
      _products = source._products
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._count)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._products)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._count.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._count, fieldNumber: 1)
      }
      if let v = _storage._products {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_SearchResultsetMetadata, rhs: Bloombox_Schema_Search_SearchResultsetMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._count != rhs_storage._count {return false}
        if _storage._products != rhs_storage._products {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Search_SearchResultset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResultset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "payload"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Bloombox_Schema_Search_SearchResultsetMetadata? = nil
    var _payload: [Bloombox_Schema_Search_SearchResult] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._payload, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Schema_Search_SearchResultset, rhs: Bloombox_Schema_Search_SearchResultset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
