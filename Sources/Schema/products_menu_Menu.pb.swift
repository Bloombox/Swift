// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: products/menu/Menu.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies structures that, together, form a composed menu product catalog, which is defined as a payload that
/// specifies individual product entries, enumerated by type or section. Usually, catalog structures are used to present
/// menu data in one way or another, but are also employed for synchronizing data between systems.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates statuses a menu may assume.
public enum Opencannabis_Products_Menu_Status: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Indicates that a menu revision is not yet published.
  case unpublished // = 0

  /// Indicates that a menu revision has been published and is considered live.
  case live // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unpublished
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unpublished
    case 1: self = .live
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unpublished: return 0
    case .live: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Products_Menu_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Products_Menu_Status] = [
    .unpublished,
    .live,
  ]
}

#endif  // swift(>=4.2)

/// Enumerates flags that can be set on a menu.
public enum Opencannabis_Products_Menu_Flag: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Indicates that this entire menu is considered a draft.
  case draft // = 0

  /// Indicates that the underlying menu data is currently private and should not be exposed publicly.
  case `private` // = 1

  /// Indicates that the underlying menu data is known to be out-of-date.
  case outOfDate // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .draft
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .draft
    case 1: self = .private
    case 2: self = .outOfDate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .draft: return 0
    case .private: return 1
    case .outOfDate: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opencannabis_Products_Menu_Flag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Products_Menu_Flag] = [
    .draft,
    .private,
    .outOfDate,
  ]
}

#endif  // swift(>=4.2)

/// Specifies settings used to generate a menu, or used as input when generating menus.
public struct Opencannabis_Products_Menu_MenuSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flag indicating a full menu, including hidden/out-of-stock items.
  public var full: Bool {
    get {return _storage._full}
    set {_uniqueStorage()._full = newValue}
  }

  /// Only include menu keys, no detail data.
  public var keysOnly: Bool {
    get {return _storage._keysOnly}
    set {_uniqueStorage()._keysOnly = newValue}
  }

  /// Don't return the menu if it's identical to this fingerprint.
  public var snapshot: Opencannabis_Crypto_Hash {
    get {return _storage._snapshot ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  public var hasSnapshot: Bool {return _storage._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  public mutating func clearSnapshot() {_uniqueStorage()._snapshot = nil}

  /// Bloom filter to consider when returning or processing menu items.
  public var fingerprint: Opencannabis_Crypto_Hash {
    get {return _storage._fingerprint ?? Opencannabis_Crypto_Hash()}
    set {_uniqueStorage()._fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return _storage._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {_uniqueStorage()._fingerprint = nil}

  /// Sections to include in the menu. If unspecified, include all sections.
  public var section: [Opencannabis_Products_Menu_Section_Section] {
    get {return _storage._section}
    set {_uniqueStorage()._section = newValue}
  }

  /// Hint for other available sections. Included on a sectioned menu payload with only one section.
  public var availableSection: [Opencannabis_Products_Menu_Section_Section] {
    get {return _storage._availableSection}
    set {_uniqueStorage()._availableSection = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies metadata for a package of menu data.
public struct Opencannabis_Products_Menu_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partner location that owns this menu data.
  public var scope: String {
    get {return _storage._scope}
    set {_uniqueStorage()._scope = newValue}
  }

  /// Version number, or publish timestamp, of this data.
  public var version: UInt64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Status of this menu data.
  public var status: Opencannabis_Products_Menu_Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Flags attached to this menu data.
  public var flags: [Opencannabis_Products_Menu_Flag] {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// When this menu data was published.
  public var published: Opencannabis_Temporal_Instant {
    get {return _storage._published ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._published = newValue}
  }
  /// Returns true if `published` has been explicitly set.
  public var hasPublished: Bool {return _storage._published != nil}
  /// Clears the value of `published`. Subsequent reads from it will return its default value.
  public mutating func clearPublished() {_uniqueStorage()._published = nil}

  /// Settings that produced this menu data.
  public var settings: Opencannabis_Products_Menu_MenuSettings {
    get {return _storage._settings ?? Opencannabis_Products_Menu_MenuSettings()}
    set {_uniqueStorage()._settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return _storage._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {_uniqueStorage()._settings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies the concept of a tag that may be arbitrarily created and attached to menu products, in a many-to-many-style
/// relationship, for the purpose of categorically sorting/managing items.
public struct Opencannabis_Products_Menu_ProductTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID for the tag. Usually a shortened version of the display name.
  public var id: String = String()

  /// Display text for the tag.
  public var display: String = String()

  /// Color code, in hex, for the tag.
  public var color: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a foreign reference for a given menu product. A foreign reference is a unique ID or link between a product
/// and that same product in some foreign computer system.
public struct Opencannabis_Products_Menu_ForeignReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Foreign key value for a reference between an in-network product and an out-of-network representation of that same
  /// product in a different computer system.
  public var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// Domain for the integrating system. This is usually set to a unique domain value that corresponds to the foreign
  /// system, and can be used to identify it later.
  public var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// URL to this product in the foreign system, if applicable. Can also be a link to a REST URL payload representing
  /// this product's data in the foreign system.
  public var link: String {
    get {return _storage._link}
    set {_uniqueStorage()._link = newValue}
  }

  /// Timestamp for when this foreign reference was attached to a given menu product. This timestamp should only be set
  /// once, upon original creation/linking of the foreign reference.
  public var attached: Opencannabis_Temporal_Instant {
    get {return _storage._attached ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._attached = newValue}
  }
  /// Returns true if `attached` has been explicitly set.
  public var hasAttached: Bool {return _storage._attached != nil}
  /// Clears the value of `attached`. Subsequent reads from it will return its default value.
  public mutating func clearAttached() {_uniqueStorage()._attached = nil}

  /// Timestamp indicating when this foreign product reference was last validated with the foreign system. Each time an
  /// item is fetched or otherwise synchronized, this should be updated.
  public var validated: Opencannabis_Temporal_Instant {
    get {return _storage._validated ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._validated = newValue}
  }
  /// Returns true if `validated` has been explicitly set.
  public var hasValidated: Bool {return _storage._validated != nil}
  /// Clears the value of `validated`. Subsequent reads from it will return its default value.
  public mutating func clearValidated() {_uniqueStorage()._validated = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Menu product payload stanza. Specifies a single product as a member of a menu section. This generic record is used to
/// wrap concrete menu product structures to make them generically usable. In V2 data stores, menu products are stored
/// generically as a top-level entity (as opposed to V1, in which this model is synthesized from raw map data).
public struct Opencannabis_Products_Menu_MenuProduct {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key record uniquely identifying this menu product. Keys for saved items are lifted to this property from the
  /// attached concrete record below.
  public var key: Opencannabis_Base_ProductKey {
    get {return _storage._key ?? Opencannabis_Base_ProductKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Product tags attached to this entry. Product tags are arbitrary phrases or strings that may be attached to product
  /// records to help categorize them or facilitate their management. They are not generally end-user-visible.
  public var tag: [Opencannabis_Products_Menu_ProductTag] {
    get {return _storage._tag}
    set {_uniqueStorage()._tag = newValue}
  }

  /// Set of foreign references for this product, or, instances in which this product exists in an out-of-network system,
  /// in a uniquely identifiable way.
  public var ref: [Opencannabis_Products_Menu_ForeignReference] {
    get {return _storage._ref}
    set {_uniqueStorage()._ref = newValue}
  }

  /// Content and materials data for this menu product.
  public var product: OneOf_Product? {
    get {return _storage._product}
    set {_uniqueStorage()._product = newValue}
  }

  /// Apothecary product.
  public var apothecary: Opencannabis_Products_Apothecary {
    get {
      if case .apothecary(let v)? = _storage._product {return v}
      return Opencannabis_Products_Apothecary()
    }
    set {_uniqueStorage()._product = .apothecary(newValue)}
  }

  /// Cartridge product.
  public var cartridge: Opencannabis_Products_Cartridge {
    get {
      if case .cartridge(let v)? = _storage._product {return v}
      return Opencannabis_Products_Cartridge()
    }
    set {_uniqueStorage()._product = .cartridge(newValue)}
  }

  /// Edible product.
  public var edible: Opencannabis_Products_Edible {
    get {
      if case .edible(let v)? = _storage._product {return v}
      return Opencannabis_Products_Edible()
    }
    set {_uniqueStorage()._product = .edible(newValue)}
  }

  /// Extract product.
  public var extract: Opencannabis_Products_Extract {
    get {
      if case .extract(let v)? = _storage._product {return v}
      return Opencannabis_Products_Extract()
    }
    set {_uniqueStorage()._product = .extract(newValue)}
  }

  /// Flower product.
  public var flower: Opencannabis_Products_Flower {
    get {
      if case .flower(let v)? = _storage._product {return v}
      return Opencannabis_Products_Flower()
    }
    set {_uniqueStorage()._product = .flower(newValue)}
  }

  /// Merchandise product.
  public var merchandise: Opencannabis_Products_Merchandise {
    get {
      if case .merchandise(let v)? = _storage._product {return v}
      return Opencannabis_Products_Merchandise()
    }
    set {_uniqueStorage()._product = .merchandise(newValue)}
  }

  /// Plant product.
  public var plant: Opencannabis_Products_Plant {
    get {
      if case .plant(let v)? = _storage._product {return v}
      return Opencannabis_Products_Plant()
    }
    set {_uniqueStorage()._product = .plant(newValue)}
  }

  /// Preroll product.
  public var preroll: Opencannabis_Products_Preroll {
    get {
      if case .preroll(let v)? = _storage._product {return v}
      return Opencannabis_Products_Preroll()
    }
    set {_uniqueStorage()._product = .preroll(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Content and materials data for this menu product.
  public enum OneOf_Product: Equatable {
    /// Apothecary product.
    case apothecary(Opencannabis_Products_Apothecary)
    /// Cartridge product.
    case cartridge(Opencannabis_Products_Cartridge)
    /// Edible product.
    case edible(Opencannabis_Products_Edible)
    /// Extract product.
    case extract(Opencannabis_Products_Extract)
    /// Flower product.
    case flower(Opencannabis_Products_Flower)
    /// Merchandise product.
    case merchandise(Opencannabis_Products_Merchandise)
    /// Plant product.
    case plant(Opencannabis_Products_Plant)
    /// Preroll product.
    case preroll(Opencannabis_Products_Preroll)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Products_Menu_MenuProduct.OneOf_Product, rhs: Opencannabis_Products_Menu_MenuProduct.OneOf_Product) -> Bool {
      switch (lhs, rhs) {
      case (.apothecary(let l), .apothecary(let r)): return l == r
      case (.cartridge(let l), .cartridge(let r)): return l == r
      case (.edible(let l), .edible(let r)): return l == r
      case (.extract(let l), .extract(let r)): return l == r
      case (.flower(let l), .flower(let r)): return l == r
      case (.merchandise(let l), .merchandise(let r)): return l == r
      case (.plant(let l), .plant(let r)): return l == r
      case (.preroll(let l), .preroll(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies an inner menu payload which contains menu data for a given menu section.
public struct Opencannabis_Products_Menu_SectionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of products included in this menu section data.
  public var count: Int32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// Section that this data is attached to.
  public var section: Opencannabis_Products_Menu_Section_SectionSpec {
    get {return _storage._section ?? Opencannabis_Products_Menu_Section_SectionSpec()}
    set {_uniqueStorage()._section = newValue}
  }
  /// Returns true if `section` has been explicitly set.
  public var hasSection: Bool {return _storage._section != nil}
  /// Clears the value of `section`. Subsequent reads from it will return its default value.
  public mutating func clearSection() {_uniqueStorage()._section = nil}

  /// Menu products attached to this section.
  public var product: [Opencannabis_Products_Menu_MenuProduct] {
    get {return _storage._product}
    set {_uniqueStorage()._product = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a menu split into section-level chunks.
public struct Opencannabis_Products_Menu_SectionedMenu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of all products included in this menu, all sections considered.
  public var count: Int32 = 0

  /// Specifies a payload of sectioned menu data.
  public var payload: [Opencannabis_Products_Menu_SectionData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies an inner menu payload which contains mapped data, where each map key is a section name, lower-cased, and
/// each map value is itself a product, and each map is addressed at a typed property name.
public struct Opencannabis_Products_Menu_StaticMenu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies APOTHECARY products attached to this menu.
  public var apothecary: Dictionary<String,Opencannabis_Products_Apothecary> = [:]

  /// Specifies CARTRIDGE products attached to this menu.
  public var cartridges: Dictionary<String,Opencannabis_Products_Cartridge> = [:]

  /// Specifies EDIBLE products attached to this menu.
  public var edibles: Dictionary<String,Opencannabis_Products_Edible> = [:]

  /// Specifies EXTRACT products attached to this menu.
  public var extracts: Dictionary<String,Opencannabis_Products_Extract> = [:]

  /// Specifies FLOWER products attached to this menu.
  public var flowers: Dictionary<String,Opencannabis_Products_Flower> = [:]

  /// Specifies MERCHANDISE products attached to this menu.
  public var merchandise: Dictionary<String,Opencannabis_Products_Merchandise> = [:]

  /// Specifies PLANT products attached to this menu.
  public var plants: Dictionary<String,Opencannabis_Products_Plant> = [:]

  /// Specifies PREROLL products attached to this menu.
  public var prerolls: Dictionary<String,Opencannabis_Products_Preroll> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Holds a full specification for a revision of menu data, segmented into sections, by the categories member products
/// are filed in. Categories are enumerated in `menu.Section`.
public struct Opencannabis_Products_Menu_Menu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata for the menu.
  public var metadata: Opencannabis_Products_Menu_Metadata {
    get {return _storage._metadata ?? Opencannabis_Products_Menu_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Specifies menu content, either in repeated section data, or with a static map.
  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  /// Data payloads attached to this menu.
  public var payload: Opencannabis_Products_Menu_SectionedMenu {
    get {
      if case .payload(let v)? = _storage._content {return v}
      return Opencannabis_Products_Menu_SectionedMenu()
    }
    set {_uniqueStorage()._content = .payload(newValue)}
  }

  /// Specifies a static menu, where each section is specified as a typed map, with keys mapped to products.
  public var menu: Opencannabis_Products_Menu_StaticMenu {
    get {
      if case .menu(let v)? = _storage._content {return v}
      return Opencannabis_Products_Menu_StaticMenu()
    }
    set {_uniqueStorage()._content = .menu(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies menu content, either in repeated section data, or with a static map.
  public enum OneOf_Content: Equatable {
    /// Data payloads attached to this menu.
    case payload(Opencannabis_Products_Menu_SectionedMenu)
    /// Specifies a static menu, where each section is specified as a typed map, with keys mapped to products.
    case menu(Opencannabis_Products_Menu_StaticMenu)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Products_Menu_Menu.OneOf_Content, rhs: Opencannabis_Products_Menu_Menu.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.payload(let l), .payload(let r)): return l == r
      case (.menu(let l), .menu(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencannabis.products.menu"

extension Opencannabis_Products_Menu_Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNPUBLISHED"),
    1: .same(proto: "LIVE"),
  ]
}

extension Opencannabis_Products_Menu_Flag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DRAFT"),
    1: .same(proto: "PRIVATE"),
    2: .same(proto: "OUT_OF_DATE"),
  ]
}

extension Opencannabis_Products_Menu_MenuSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "full"),
    2: .standard(proto: "keys_only"),
    3: .same(proto: "snapshot"),
    4: .same(proto: "fingerprint"),
    5: .same(proto: "section"),
    6: .standard(proto: "available_section"),
  ]

  fileprivate class _StorageClass {
    var _full: Bool = false
    var _keysOnly: Bool = false
    var _snapshot: Opencannabis_Crypto_Hash? = nil
    var _fingerprint: Opencannabis_Crypto_Hash? = nil
    var _section: [Opencannabis_Products_Menu_Section_Section] = []
    var _availableSection: [Opencannabis_Products_Menu_Section_Section] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _full = source._full
      _keysOnly = source._keysOnly
      _snapshot = source._snapshot
      _fingerprint = source._fingerprint
      _section = source._section
      _availableSection = source._availableSection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._full)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._keysOnly)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._snapshot)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._fingerprint)
        case 5: try decoder.decodeRepeatedEnumField(value: &_storage._section)
        case 6: try decoder.decodeRepeatedEnumField(value: &_storage._availableSection)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._full != false {
        try visitor.visitSingularBoolField(value: _storage._full, fieldNumber: 1)
      }
      if _storage._keysOnly != false {
        try visitor.visitSingularBoolField(value: _storage._keysOnly, fieldNumber: 2)
      }
      if let v = _storage._snapshot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fingerprint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._section.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._section, fieldNumber: 5)
      }
      if !_storage._availableSection.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._availableSection, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_MenuSettings, rhs: Opencannabis_Products_Menu_MenuSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._full != rhs_storage._full {return false}
        if _storage._keysOnly != rhs_storage._keysOnly {return false}
        if _storage._snapshot != rhs_storage._snapshot {return false}
        if _storage._fingerprint != rhs_storage._fingerprint {return false}
        if _storage._section != rhs_storage._section {return false}
        if _storage._availableSection != rhs_storage._availableSection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "version"),
    3: .same(proto: "status"),
    4: .same(proto: "flags"),
    5: .same(proto: "published"),
    6: .same(proto: "settings"),
  ]

  fileprivate class _StorageClass {
    var _scope: String = String()
    var _version: UInt64 = 0
    var _status: Opencannabis_Products_Menu_Status = .unpublished
    var _flags: [Opencannabis_Products_Menu_Flag] = []
    var _published: Opencannabis_Temporal_Instant? = nil
    var _settings: Opencannabis_Products_Menu_MenuSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scope = source._scope
      _version = source._version
      _status = source._status
      _flags = source._flags
      _published = source._published
      _settings = source._settings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._scope)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._version)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 4: try decoder.decodeRepeatedEnumField(value: &_storage._flags)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._published)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._settings)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._scope.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scope, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._version, fieldNumber: 2)
      }
      if _storage._status != .unpublished {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 3)
      }
      if !_storage._flags.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._flags, fieldNumber: 4)
      }
      if let v = _storage._published {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_Metadata, rhs: Opencannabis_Products_Menu_Metadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scope != rhs_storage._scope {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._published != rhs_storage._published {return false}
        if _storage._settings != rhs_storage._settings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_ProductTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "display"),
    3: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.display)
      case 3: try decoder.decodeSingularStringField(value: &self.color)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 2)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_ProductTag, rhs: Opencannabis_Products_Menu_ProductTag) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.display != rhs.display {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_ForeignReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForeignReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "domain"),
    3: .same(proto: "link"),
    4: .same(proto: "attached"),
    5: .same(proto: "validated"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _domain: String = String()
    var _link: String = String()
    var _attached: Opencannabis_Temporal_Instant? = nil
    var _validated: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _domain = source._domain
      _link = source._link
      _attached = source._attached
      _validated = source._validated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._key)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._link)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._attached)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._validated)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._link.isEmpty {
        try visitor.visitSingularStringField(value: _storage._link, fieldNumber: 3)
      }
      if let v = _storage._attached {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._validated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_ForeignReference, rhs: Opencannabis_Products_Menu_ForeignReference) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._attached != rhs_storage._attached {return false}
        if _storage._validated != rhs_storage._validated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_MenuProduct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuProduct"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "tag"),
    3: .same(proto: "ref"),
    10: .same(proto: "apothecary"),
    11: .same(proto: "cartridge"),
    12: .same(proto: "edible"),
    13: .same(proto: "extract"),
    14: .same(proto: "flower"),
    15: .same(proto: "merchandise"),
    16: .same(proto: "plant"),
    17: .same(proto: "preroll"),
  ]

  fileprivate class _StorageClass {
    var _key: Opencannabis_Base_ProductKey? = nil
    var _tag: [Opencannabis_Products_Menu_ProductTag] = []
    var _ref: [Opencannabis_Products_Menu_ForeignReference] = []
    var _product: Opencannabis_Products_Menu_MenuProduct.OneOf_Product?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _tag = source._tag
      _ref = source._ref
      _product = source._product
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._tag)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._ref)
        case 10:
          var v: Opencannabis_Products_Apothecary?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .apothecary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .apothecary(v)}
        case 11:
          var v: Opencannabis_Products_Cartridge?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .cartridge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .cartridge(v)}
        case 12:
          var v: Opencannabis_Products_Edible?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .edible(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .edible(v)}
        case 13:
          var v: Opencannabis_Products_Extract?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .extract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .extract(v)}
        case 14:
          var v: Opencannabis_Products_Flower?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .flower(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .flower(v)}
        case 15:
          var v: Opencannabis_Products_Merchandise?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .merchandise(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .merchandise(v)}
        case 16:
          var v: Opencannabis_Products_Plant?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .plant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .plant(v)}
        case 17:
          var v: Opencannabis_Products_Preroll?
          if let current = _storage._product {
            try decoder.handleConflictingOneOf()
            if case .preroll(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._product = .preroll(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tag.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tag, fieldNumber: 2)
      }
      if !_storage._ref.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ref, fieldNumber: 3)
      }
      switch _storage._product {
      case .apothecary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .cartridge(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .edible(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .extract(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .flower(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .merchandise(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .plant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .preroll(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_MenuProduct, rhs: Opencannabis_Products_Menu_MenuProduct) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._ref != rhs_storage._ref {return false}
        if _storage._product != rhs_storage._product {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_SectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "section"),
    3: .same(proto: "product"),
  ]

  fileprivate class _StorageClass {
    var _count: Int32 = 0
    var _section: Opencannabis_Products_Menu_Section_SectionSpec? = nil
    var _product: [Opencannabis_Products_Menu_MenuProduct] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _count = source._count
      _section = source._section
      _product = source._product
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._count)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._section)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._product)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._count != 0 {
        try visitor.visitSingularInt32Field(value: _storage._count, fieldNumber: 1)
      }
      if let v = _storage._section {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._product.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._product, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_SectionData, rhs: Opencannabis_Products_Menu_SectionData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._count != rhs_storage._count {return false}
        if _storage._section != rhs_storage._section {return false}
        if _storage._product != rhs_storage._product {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_SectionedMenu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SectionedMenu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.count)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_SectionedMenu, rhs: Opencannabis_Products_Menu_SectionedMenu) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_StaticMenu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StaticMenu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apothecary"),
    2: .same(proto: "cartridges"),
    3: .same(proto: "edibles"),
    4: .same(proto: "extracts"),
    5: .same(proto: "flowers"),
    6: .same(proto: "merchandise"),
    7: .same(proto: "plants"),
    8: .same(proto: "prerolls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Apothecary>.self, value: &self.apothecary)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Cartridge>.self, value: &self.cartridges)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Edible>.self, value: &self.edibles)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Extract>.self, value: &self.extracts)
      case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Flower>.self, value: &self.flowers)
      case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Merchandise>.self, value: &self.merchandise)
      case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Plant>.self, value: &self.plants)
      case 8: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Preroll>.self, value: &self.prerolls)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apothecary.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Apothecary>.self, value: self.apothecary, fieldNumber: 1)
    }
    if !self.cartridges.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Cartridge>.self, value: self.cartridges, fieldNumber: 2)
    }
    if !self.edibles.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Edible>.self, value: self.edibles, fieldNumber: 3)
    }
    if !self.extracts.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Extract>.self, value: self.extracts, fieldNumber: 4)
    }
    if !self.flowers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Flower>.self, value: self.flowers, fieldNumber: 5)
    }
    if !self.merchandise.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Merchandise>.self, value: self.merchandise, fieldNumber: 6)
    }
    if !self.plants.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Plant>.self, value: self.plants, fieldNumber: 7)
    }
    if !self.prerolls.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencannabis_Products_Preroll>.self, value: self.prerolls, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_StaticMenu, rhs: Opencannabis_Products_Menu_StaticMenu) -> Bool {
    if lhs.apothecary != rhs.apothecary {return false}
    if lhs.cartridges != rhs.cartridges {return false}
    if lhs.edibles != rhs.edibles {return false}
    if lhs.extracts != rhs.extracts {return false}
    if lhs.flowers != rhs.flowers {return false}
    if lhs.merchandise != rhs.merchandise {return false}
    if lhs.plants != rhs.plants {return false}
    if lhs.prerolls != rhs.prerolls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Products_Menu_Menu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Menu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    3: .same(proto: "payload"),
    4: .same(proto: "menu"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Opencannabis_Products_Menu_Metadata? = nil
    var _content: Opencannabis_Products_Menu_Menu.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 3:
          var v: Opencannabis_Products_Menu_SectionedMenu?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .payload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .payload(v)}
        case 4:
          var v: Opencannabis_Products_Menu_StaticMenu?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .menu(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .menu(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      switch _storage._content {
      case .payload(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .menu(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Products_Menu_Menu, rhs: Opencannabis_Products_Menu_Menu) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
