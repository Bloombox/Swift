// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: analytics/stream/Filter.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Provides filter structures used for streaming-style analytics calculations (in particular, Bloom filters).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines a basic Bloom-style binary filter structure. Also specifies the hash iteration count, or *k* value, used to
/// derive and query this filter.
public struct Bloombox_Stream_BloomFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash iteration count, or *k* value, for the Bloom filter.
  public var hashCount: UInt32 = 0

  /// Raw bits of the Bloom filter.
  public var bits: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines a multi-layer Bloom filter, wherein each layer is defined by some application semantics to signify additional
/// value. An arbitrary number of layers may be kept.
public struct Bloombox_Stream_LayeredBloomFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies a static Bloom filter.
  public var filter: [Bloombox_Stream_BloomFilter] = []

  /// Limit for additional layers. If unspecified, default is 0 (the first layer does not count).
  public var limit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines an extended Bloom-style binary filter, where each position of the filter is expanded to include integer state
/// for a counter. Counters cannot be negative and so are stored unsigned.
public struct Bloombox_Stream_CountingBloomFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash iteration count, or *k* value, for the Bloom filter.
  public var hashCount: UInt32 = 0

  /// Raw buckets for the counter.
  public var bucket: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines a Bloom filter with additional temporal properties, for the purpose of facilitating time-based decay. Arrays
/// for timestamp storage, counter storage, and bitset storage are kept in sync.
public struct Bloombox_Stream_OITDBloomFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash iteration count, or *k* value, for the Bloom filter.
  public var hashCount: UInt32 = 0

  /// Set of raw filter bits (i.e., the "content" of the filter).
  public var bitset: [UInt64] = []

  /// Counter buckets corresponding to each filter bit position.
  public var bucket: [UInt64] = []

  /// Set of timestamps corresponding to each filter bit position.
  public var timestamp: [UInt64] = []

  /// Specifies an insertions count, which tracks the number of items globally inserted into each layer.
  public var insertions: [UInt32] = []

  /// Specifies a static Bloom filter, which supplants the insertion count array with information about membership.
  public var membership: [Bloombox_Stream_BloomFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines a Bloom filter with temporal storage properties, counter support, and layering support, for the purpose of
/// facilitating time-based decay with depth indication. The inner OITD Bloom Filter record can be referenced above.
public struct Bloombox_Stream_LayeredOITDBloomFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies layers of temporally-decaying Bloom filters.
  public var filter: [Bloombox_Stream_OITDBloomFilter] = []

  /// Specifies the layer limit for this individual Bloom filter, upon initialization.
  public var limit: UInt32 = 0

  /// Specifies an insertions count, which tracks the number of items globally inserted into each layer.
  public var insertions: [UInt32] = []

  /// Specifies a static Bloom filter, which supplants the insertion count array with information about membership.
  public var membership: [Bloombox_Stream_BloomFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.stream"

extension Bloombox_Stream_BloomFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BloomFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hash_count"),
    2: .same(proto: "bits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.hashCount)
      case 2: try decoder.decodeRepeatedFixed64Field(value: &self.bits)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hashCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.hashCount, fieldNumber: 1)
    }
    if !self.bits.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Stream_BloomFilter, rhs: Bloombox_Stream_BloomFilter) -> Bool {
    if lhs.hashCount != rhs.hashCount {return false}
    if lhs.bits != rhs.bits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Stream_LayeredBloomFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LayeredBloomFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.filter)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filter, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Stream_LayeredBloomFilter, rhs: Bloombox_Stream_LayeredBloomFilter) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Stream_CountingBloomFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountingBloomFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hash_count"),
    2: .same(proto: "bucket"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.hashCount)
      case 2: try decoder.decodeRepeatedFixed64Field(value: &self.bucket)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hashCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.hashCount, fieldNumber: 1)
    }
    if !self.bucket.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucket, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Stream_CountingBloomFilter, rhs: Bloombox_Stream_CountingBloomFilter) -> Bool {
    if lhs.hashCount != rhs.hashCount {return false}
    if lhs.bucket != rhs.bucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Stream_OITDBloomFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OITDBloomFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hash_count"),
    2: .same(proto: "bitset"),
    3: .same(proto: "bucket"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "insertions"),
    6: .same(proto: "membership"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.hashCount)
      case 2: try decoder.decodeRepeatedFixed64Field(value: &self.bitset)
      case 3: try decoder.decodeRepeatedFixed64Field(value: &self.bucket)
      case 4: try decoder.decodeRepeatedUInt64Field(value: &self.timestamp)
      case 5: try decoder.decodeRepeatedUInt32Field(value: &self.insertions)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.membership)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hashCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.hashCount, fieldNumber: 1)
    }
    if !self.bitset.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bitset, fieldNumber: 2)
    }
    if !self.bucket.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucket, fieldNumber: 3)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if !self.insertions.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.insertions, fieldNumber: 5)
    }
    if !self.membership.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.membership, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Stream_OITDBloomFilter, rhs: Bloombox_Stream_OITDBloomFilter) -> Bool {
    if lhs.hashCount != rhs.hashCount {return false}
    if lhs.bitset != rhs.bitset {return false}
    if lhs.bucket != rhs.bucket {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.insertions != rhs.insertions {return false}
    if lhs.membership != rhs.membership {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bloombox_Stream_LayeredOITDBloomFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LayeredOITDBloomFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "limit"),
    3: .same(proto: "insertions"),
    4: .same(proto: "membership"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.filter)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.limit)
      case 3: try decoder.decodeRepeatedUInt32Field(value: &self.insertions)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.membership)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filter, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.insertions.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.insertions, fieldNumber: 3)
    }
    if !self.membership.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.membership, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bloombox_Stream_LayeredOITDBloomFilter, rhs: Bloombox_Stream_LayeredOITDBloomFilter) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.insertions != rhs.insertions {return false}
    if lhs.membership != rhs.membership {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
