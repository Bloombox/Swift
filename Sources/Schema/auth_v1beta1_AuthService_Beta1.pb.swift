// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: auth/v1beta1/AuthService_Beta1.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumerates known errors that may be thrown by auth operations.
public enum Bloombox_Schema_Services_Auth_V1beta1_AuthError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// There was no error.
  case noError // = 0

  /// Access was denied: the user's account is suspended.
  case accountSuspended // = 1

  /// Profile could not be located.
  case profileNotFound // = 2

  /// The provided user key was found to be invalid.
  case invalidUserKey // = 3

  /// The provided auth assertion was deemed to be invalid.
  case invalidAssertion // = 4

  /// The specified authentication type is not currently supported.
  case unsupportedLoginType // = 5

  /// Authentication token from Hydra was not valid.
  case invalidAuthToken // = 6

  /// The ticket provided for consent was invalid.
  case invalidTicket // = 7

  /// The client's profile could not be located.
  case clientNotFound // = 8

  /// Consent ID is not valid.
  case invalidConsentID // = 9

  /// The provided ID token information was found to be invalid.
  case invalidIDToken // = 10

  /// The provided access token information was found to be invalid.
  case invalidAccessToken // = 11

  /// The provided ID token was found to be expired.
  case expiredIDToken // = 12

  /// The provided access token was found to be expired.
  case expiredAccessToken // = 13

  /// The specified client was invalid.
  case invalidClient // = 14

  /// The specified origin was invalid.
  case invalidOrigin // = 15

  /// Access was denied for unspecified reasons.
  case accessDenied // = 16

  /// The provided session value was invalid.
  case invalidSession // = 17

  /// The provided session has expired.
  case expiredSession // = 18

  /// The provided fingerprint value was invalid.
  case invalidFingerprint // = 19

  /// Captcha verification value was invalid.
  case invalidCaptcha // = 20

  /// The provided captcha veriication value was not correct.
  case captchaRejected // = 21

  /// The specified consent ID could not be resolved.
  case consentNotFound // = 22

  /// Consent operation or consent record has expired.
  case expiredConsent // = 23

  /// An internal error was encountered.
  case internalError // = 99
  case UNRECOGNIZED(Int)

  public init() {
    self = .noError
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 1: self = .accountSuspended
    case 2: self = .profileNotFound
    case 3: self = .invalidUserKey
    case 4: self = .invalidAssertion
    case 5: self = .unsupportedLoginType
    case 6: self = .invalidAuthToken
    case 7: self = .invalidTicket
    case 8: self = .clientNotFound
    case 9: self = .invalidConsentID
    case 10: self = .invalidIDToken
    case 11: self = .invalidAccessToken
    case 12: self = .expiredIDToken
    case 13: self = .expiredAccessToken
    case 14: self = .invalidClient
    case 15: self = .invalidOrigin
    case 16: self = .accessDenied
    case 17: self = .invalidSession
    case 18: self = .expiredSession
    case 19: self = .invalidFingerprint
    case 20: self = .invalidCaptcha
    case 21: self = .captchaRejected
    case 22: self = .consentNotFound
    case 23: self = .expiredConsent
    case 99: self = .internalError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noError: return 0
    case .accountSuspended: return 1
    case .profileNotFound: return 2
    case .invalidUserKey: return 3
    case .invalidAssertion: return 4
    case .unsupportedLoginType: return 5
    case .invalidAuthToken: return 6
    case .invalidTicket: return 7
    case .clientNotFound: return 8
    case .invalidConsentID: return 9
    case .invalidIDToken: return 10
    case .invalidAccessToken: return 11
    case .expiredIDToken: return 12
    case .expiredAccessToken: return 13
    case .invalidClient: return 14
    case .invalidOrigin: return 15
    case .accessDenied: return 16
    case .invalidSession: return 17
    case .expiredSession: return 18
    case .invalidFingerprint: return 19
    case .invalidCaptcha: return 20
    case .captchaRejected: return 21
    case .consentNotFound: return 22
    case .expiredConsent: return 23
    case .internalError: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Specifies a message payload wherein a user is asserting their identity via an email-based username and a regular
/// string password, encoded and potentially encrypted by the frontend agent.
public struct Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".EmailPasswordAssertion"

  /// Email address the user is logging in with.
  public var email: String = String()

  /// User's specified account password. Expressed as a hex-encoded hashed MD5, or at least Base64-encoded when sent in
  /// cleartext, and always over a secure connection.
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.email)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Specifies a message payload containing a Firebase ID token provided during an auth flow on the frontend.
public struct Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".FirebaseTokenAssertion"

  /// Firebase identity token.
  public var token: String = String()

  /// User's ID.
  public var uid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      case 2: try decoder.decodeSingularStringField(value: &self.uid)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Specifies a generic assertion for account access privileges.
public struct Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".AccountAssertion"

  /// Assertion provided by the user, based on their chosen login method.
  public var assertion: OneOf_Assertion? {
    get {return _storage._assertion}
    set {_uniqueStorage()._assertion = newValue}
  }

  /// Email/Password-based account login.
  public var emailPassword: Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion {
    get {
      if case .emailPassword(let v)? = _storage._assertion {return v}
      return Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion()
    }
    set {_uniqueStorage()._assertion = .emailPassword(newValue)}
  }

  /// Firebase account login.
  public var firebase: Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion {
    get {
      if case .firebase(let v)? = _storage._assertion {return v}
      return Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion()
    }
    set {_uniqueStorage()._assertion = .firebase(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Assertion provided by the user, based on their chosen login method.
  public enum OneOf_Assertion: Equatable {
    /// Email/Password-based account login.
    case emailPassword(Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion)
    /// Firebase account login.
    case firebase(Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion)

    public static func ==(lhs: Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion.OneOf_Assertion, rhs: Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion.OneOf_Assertion) -> Bool {
      switch (lhs, rhs) {
      case (.emailPassword(let l), .emailPassword(let r)): return l == r
      case (.firebase(let l), .firebase(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion?
          if let current = _storage._assertion {
            try decoder.handleConflictingOneOf()
            if case .emailPassword(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._assertion = .emailPassword(v)}
        case 2:
          var v: Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion?
          if let current = _storage._assertion {
            try decoder.handleConflictingOneOf()
            if case .firebase(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._assertion = .firebase(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._assertion {
      case .emailPassword(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .firebase(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies an RPC operation wherein a user has requested an assertion of their identity be validated by the server.
public struct Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateUser"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to authenticate a user.
  public struct Request: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser.protoMessageName + ".Request"

    /// Provider the user would like to login with.
    public var provider: Bloombox_Schema_Identity_IdentityProvider {
      get {return _storage._provider}
      set {_uniqueStorage()._provider = newValue}
    }

    /// Login credentials provided by the user or Firebase.
    public var assertion: Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion {
      get {return _storage._assertion ?? Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion()}
      set {_uniqueStorage()._assertion = newValue}
    }
    /// Returns true if `assertion` has been explicitly set.
    public var hasAssertion: Bool {return _storage._assertion != nil}
    /// Clears the value of `assertion`. Subsequent reads from it will return its default value.
    public mutating func clearAssertion() {_storage._assertion = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularEnumField(value: &_storage._provider)
          case 2: try decoder.decodeSingularMessageField(value: &_storage._assertion)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if _storage._provider != .email {
          try visitor.visitSingularEnumField(value: _storage._provider, fieldNumber: 1)
        }
        if let v = _storage._assertion {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to authenticate a user.
  public struct Response: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser.protoMessageName + ".Response"

    /// Indicates the user's identity ID.
    public var uid: String = String()

    /// Indicates the user's account key.
    public var key: String = String()

    /// Authorized token resulting from the authentication operation.
    public var token: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.uid)
        case 2: try decoder.decodeSingularStringField(value: &self.key)
        case 3: try decoder.decodeSingularStringField(value: &self.token)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.uid.isEmpty {
        try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
      }
      if !self.key.isEmpty {
        try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
      }
      if !self.token.isEmpty {
        try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Specifies an operation to resolve authorized access credentials for Firebase and other services, based on a completed
/// authentication and authorization/consent flow.
public struct Bloombox_Schema_Services_Auth_V1beta1_ResolveToken: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ResolveToken"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to generate a platform authorization token.
  public struct Request: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ResolveToken.protoMessageName + ".Request"

    /// OAuth2 client ID.
    public var clientID: String {
      get {return _storage._clientID}
      set {_uniqueStorage()._clientID = newValue}
    }

    /// Encoded source origin.
    public var origin: String {
      get {return _storage._origin}
      set {_uniqueStorage()._origin = newValue}
    }

    /// State token for the active authentication flow.
    public var state: String {
      get {return _storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// Captcha code to be used via reCAPTCHA.
    public var captcha: String {
      get {return _storage._captcha}
      set {_uniqueStorage()._captcha = newValue}
    }

    /// Active session ID.
    public var session: String {
      get {return _storage._session}
      set {_uniqueStorage()._session = newValue}
    }

    /// Active device fingerprint.
    public var fingerprint: String {
      get {return _storage._fingerprint}
      set {_uniqueStorage()._fingerprint = newValue}
    }

    /// Combined authentication/authorization ticket.
    public var auth: Bloombox_Schema_Security_AuthPayload {
      get {return _storage._auth ?? Bloombox_Schema_Security_AuthPayload()}
      set {_uniqueStorage()._auth = newValue}
    }
    /// Returns true if `auth` has been explicitly set.
    public var hasAuth: Bool {return _storage._auth != nil}
    /// Clears the value of `auth`. Subsequent reads from it will return its default value.
    public mutating func clearAuth() {_storage._auth = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularStringField(value: &_storage._clientID)
          case 2: try decoder.decodeSingularStringField(value: &_storage._origin)
          case 3: try decoder.decodeSingularStringField(value: &_storage._state)
          case 4: try decoder.decodeSingularStringField(value: &_storage._captcha)
          case 5: try decoder.decodeSingularStringField(value: &_storage._session)
          case 6: try decoder.decodeSingularStringField(value: &_storage._fingerprint)
          case 7: try decoder.decodeSingularMessageField(value: &_storage._auth)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if !_storage._clientID.isEmpty {
          try visitor.visitSingularStringField(value: _storage._clientID, fieldNumber: 1)
        }
        if !_storage._origin.isEmpty {
          try visitor.visitSingularStringField(value: _storage._origin, fieldNumber: 2)
        }
        if !_storage._state.isEmpty {
          try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 3)
        }
        if !_storage._captcha.isEmpty {
          try visitor.visitSingularStringField(value: _storage._captcha, fieldNumber: 4)
        }
        if !_storage._session.isEmpty {
          try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 5)
        }
        if !_storage._fingerprint.isEmpty {
          try visitor.visitSingularStringField(value: _storage._fingerprint, fieldNumber: 6)
        }
        if let v = _storage._auth {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Response to a request to generate a platform authorization token.
  public struct Response: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ResolveToken.protoMessageName + ".Response"

    /// Resulting JSON web token, for main application use.
    public var app: String = String()

    /// Resulting JSON web token, for DB use.
    public var db: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.app)
        case 2: try decoder.decodeSingularStringField(value: &self.db)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.app.isEmpty {
        try visitor.visitSingularStringField(value: self.app, fieldNumber: 1)
      }
      if !self.db.isEmpty {
        try visitor.visitSingularStringField(value: self.db, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Specifies an operation wherein a user is demonstrating or indicating a decision regarding a consent flow, and would
/// like to proceed with the next sensible action.
public struct Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ConsentDecision"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request indicating an acceptance of the consent challenge - or, 'authorizing' a consent flow.
  public struct Accept: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.protoMessageName + ".Accept"

    /// User ID from the on-page access or identity token.
    public var uid: String = String()

    /// ID for the consent flow.
    public var consent: String = String()

    /// Scope(s) granted in the consent flow.
    public var scope: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.uid)
        case 2: try decoder.decodeSingularStringField(value: &self.consent)
        case 3: try decoder.decodeRepeatedStringField(value: &self.scope)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.uid.isEmpty {
        try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
      }
      if !self.consent.isEmpty {
        try visitor.visitSingularStringField(value: self.consent, fieldNumber: 2)
      }
      if !self.scope.isEmpty {
        try visitor.visitRepeatedStringField(value: self.scope, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Request indicating a rejection of the consent challenge - or, 'denying' a consent flow.
  public struct Reject: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.protoMessageName + ".Reject"

    /// User ID from the on-page access or identity token.
    public var uid: String = String()

    /// ID for the consent flow.
    public var consent: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.uid)
        case 2: try decoder.decodeSingularStringField(value: &self.consent)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.uid.isEmpty {
        try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
      }
      if !self.consent.isEmpty {
        try visitor.visitSingularStringField(value: self.consent, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Specifies the response payload for a consent decision indication.
  public struct Response: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.protoMessageName + ".Response"

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let _ = try decoder.nextFieldNumber() {
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Specifies an operation to build a full user context after a successful ID and authorization/consent flow, including
/// a fresh JWT, resolved user key and profile, and access roles/rights related to particular partner/location scopes.
public struct Bloombox_Schema_Services_Auth_V1beta1_UserContext: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".UserContext"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to retrieve materialized user authentication context. Must include valid, one-use cryptographic information
  /// along with the resulting ID and access tokens from the auth flow.
  public struct Request: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_UserContext.protoMessageName + ".Request"

    /// User's identity ID, or 'uid'.
    public var uid: String = String()

    /// Active session ID for the user.
    public var session: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.uid)
        case 2: try decoder.decodeSingularStringField(value: &self.session)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.uid.isEmpty {
        try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
      }
      if !self.session.isEmpty {
        try visitor.visitSingularStringField(value: self.session, fieldNumber: 2)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Response to a request to retrieve materialized user authentication context. Either specified an error or a set of
  /// materialized credential data.
  public struct Response: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_UserContext.protoMessageName + ".Response"

    /// User profile key.
    public var key: String {
      get {return _storage._key}
      set {_uniqueStorage()._key = newValue}
    }

    /// User's profile object.
    public var profile: Bloombox_Schema_Identity_User {
      get {return _storage._profile ?? Bloombox_Schema_Identity_User()}
      set {_uniqueStorage()._profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return _storage._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {_storage._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularStringField(value: &_storage._key)
          case 2: try decoder.decodeSingularMessageField(value: &_storage._profile)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if !_storage._key.isEmpty {
          try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
        }
        if let v = _storage._profile {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Retrieve a user's profile by their profile key.
public struct Bloombox_Schema_Services_Auth_V1beta1_GetProfile: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".GetProfile"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to get a user's profile object from the database.
  public struct Request: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_GetProfile.protoMessageName + ".Request"

    /// key to reference the profile user's object from the database.
    public var user: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.user)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.user.isEmpty {
        try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Response to a request to get a user's profile object.
  public struct Response: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_GetProfile.protoMessageName + ".Response"

    /// User's profile object.
    public var profile: Bloombox_Schema_Identity_User {
      get {return _storage._profile ?? Bloombox_Schema_Identity_User()}
      set {_uniqueStorage()._profile = newValue}
    }
    /// Returns true if `profile` has been explicitly set.
    public var hasProfile: Bool {return _storage._profile != nil}
    /// Clears the value of `profile`. Subsequent reads from it will return its default value.
    public mutating func clearProfile() {_storage._profile = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._profile)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._profile {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Specifies an RPC operation to perform a consent flow through Hydra.
public struct Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ConsentFlow"

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request to perform a consent flow.
  public struct Request: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow.protoMessageName + ".Request"

    /// ID value of the consent request.
    public var consent: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.consent)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.consent.isEmpty {
        try visitor.visitSingularStringField(value: self.consent, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Response to a request to perform a consent flow.
  public struct Response: SwiftProtobuf.Message {
    public static let protoMessageName: String = Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow.protoMessageName + ".Response"

    /// Consent ticket returned from Hydra.
    public var ticket: Opencannabis_Oauth_ConsentTicket {
      get {return _storage._ticket ?? Opencannabis_Oauth_ConsentTicket()}
      set {_uniqueStorage()._ticket = newValue}
    }
    /// Returns true if `ticket` has been explicitly set.
    public var hasTicket: Bool {return _storage._ticket != nil}
    /// Clears the value of `ticket`. Subsequent reads from it will return its default value.
    public mutating func clearTicket() {_storage._ticket = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._ticket)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._ticket {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bloombox.schema.services.auth.v1beta1"

extension Bloombox_Schema_Services_Auth_V1beta1_AuthError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    1: .same(proto: "ACCOUNT_SUSPENDED"),
    2: .same(proto: "PROFILE_NOT_FOUND"),
    3: .same(proto: "INVALID_USER_KEY"),
    4: .same(proto: "INVALID_ASSERTION"),
    5: .same(proto: "UNSUPPORTED_LOGIN_TYPE"),
    6: .same(proto: "INVALID_AUTH_TOKEN"),
    7: .same(proto: "INVALID_TICKET"),
    8: .same(proto: "CLIENT_NOT_FOUND"),
    9: .same(proto: "INVALID_CONSENT_ID"),
    10: .same(proto: "INVALID_ID_TOKEN"),
    11: .same(proto: "INVALID_ACCESS_TOKEN"),
    12: .same(proto: "EXPIRED_ID_TOKEN"),
    13: .same(proto: "EXPIRED_ACCESS_TOKEN"),
    14: .same(proto: "INVALID_CLIENT"),
    15: .same(proto: "INVALID_ORIGIN"),
    16: .same(proto: "ACCESS_DENIED"),
    17: .same(proto: "INVALID_SESSION"),
    18: .same(proto: "EXPIRED_SESSION"),
    19: .same(proto: "INVALID_FINGERPRINT"),
    20: .same(proto: "INVALID_CAPTCHA"),
    21: .same(proto: "CAPTCHA_REJECTED"),
    22: .same(proto: "CONSENT_NOT_FOUND"),
    23: .same(proto: "EXPIRED_CONSENT"),
    99: .same(proto: "INTERNAL_ERROR"),
  ]
}

extension Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "password"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_EmailPasswordAssertion) -> Bool {
    if self.email != other.email {return false}
    if self.password != other.password {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "uid"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_FirebaseTokenAssertion) -> Bool {
    if self.token != other.token {return false}
    if self.uid != other.uid {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "email_password"),
    2: .same(proto: "firebase"),
  ]

  fileprivate class _StorageClass {
    var _assertion: Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion.OneOf_Assertion?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assertion = source._assertion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._assertion != other_storage._assertion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser.Request: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "assertion"),
  ]

  fileprivate class _StorageClass {
    var _provider: Bloombox_Schema_Identity_IdentityProvider = .email
    var _assertion: Bloombox_Schema_Services_Auth_V1beta1_AccountAssertion? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _provider = source._provider
      _assertion = source._assertion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser.Request) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._provider != other_storage._provider {return false}
        if _storage._assertion != other_storage._assertion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser.Response: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "key"),
    3: .same(proto: "token"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_AuthenticateUser.Response) -> Bool {
    if self.uid != other.uid {return false}
    if self.key != other.key {return false}
    if self.token != other.token {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ResolveToken: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ResolveToken) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ResolveToken.Request: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .same(proto: "origin"),
    3: .same(proto: "state"),
    4: .same(proto: "captcha"),
    5: .same(proto: "session"),
    6: .same(proto: "fingerprint"),
    7: .same(proto: "auth"),
  ]

  fileprivate class _StorageClass {
    var _clientID: String = String()
    var _origin: String = String()
    var _state: String = String()
    var _captcha: String = String()
    var _session: String = String()
    var _fingerprint: String = String()
    var _auth: Bloombox_Schema_Security_AuthPayload? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clientID = source._clientID
      _origin = source._origin
      _state = source._state
      _captcha = source._captcha
      _session = source._session
      _fingerprint = source._fingerprint
      _auth = source._auth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ResolveToken.Request) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._clientID != other_storage._clientID {return false}
        if _storage._origin != other_storage._origin {return false}
        if _storage._state != other_storage._state {return false}
        if _storage._captcha != other_storage._captcha {return false}
        if _storage._session != other_storage._session {return false}
        if _storage._fingerprint != other_storage._fingerprint {return false}
        if _storage._auth != other_storage._auth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ResolveToken.Response: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "app"),
    2: .same(proto: "db"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ResolveToken.Response) -> Bool {
    if self.app != other.app {return false}
    if self.db != other.db {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.Accept: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "consent"),
    3: .same(proto: "scope"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.Accept) -> Bool {
    if self.uid != other.uid {return false}
    if self.consent != other.consent {return false}
    if self.scope != other.scope {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.Reject: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "consent"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.Reject) -> Bool {
    if self.uid != other.uid {return false}
    if self.consent != other.consent {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.Response: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentDecision.Response) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_UserContext: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_UserContext) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_UserContext.Request: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "session"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_UserContext.Request) -> Bool {
    if self.uid != other.uid {return false}
    if self.session != other.session {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_UserContext.Response: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "profile"),
  ]

  fileprivate class _StorageClass {
    var _key: String = String()
    var _profile: Bloombox_Schema_Identity_User? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _profile = source._profile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_UserContext.Response) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._key != other_storage._key {return false}
        if _storage._profile != other_storage._profile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_GetProfile: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_GetProfile) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_GetProfile.Request: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_GetProfile.Request) -> Bool {
    if self.user != other.user {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_GetProfile.Response: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profile"),
  ]

  fileprivate class _StorageClass {
    var _profile: Bloombox_Schema_Identity_User? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _profile = source._profile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_GetProfile.Response) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._profile != other_storage._profile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow.Request: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consent"),
  ]

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow.Request) -> Bool {
    if self.consent != other.consent {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow.Response: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ticket"),
  ]

  fileprivate class _StorageClass {
    var _ticket: Opencannabis_Oauth_ConsentTicket? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ticket = source._ticket
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Bloombox_Schema_Services_Auth_V1beta1_ConsentFlow.Response) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._ticket != other_storage._ticket {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
