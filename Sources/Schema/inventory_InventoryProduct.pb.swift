// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: inventory/InventoryProduct.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

///*
/// Specifies top-level structures used for generic inventory item storage. Inventory items are essentially concrete
/// products, combined with an amount/variant specification, into various parameters (amount on hand, amount ready for
/// sale, and so on).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Key structure for inventory records. Identifies the product being inventoried, with a unique ID set upon creation or
/// allocation of the record.
public struct Opencannabis_Inventory_InventoryKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key record uniquely identifying this inventory product. Keys for saved items are lifted to this property from the
  /// attached concrete record below.
  public var key: Opencannabis_Base_ProductKey {
    get {return _storage._key ?? Opencannabis_Base_ProductKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// Unique ID provisioned for this inventory item.
  public var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Structured information specifying a location where an inventory product can exist. Sets of coordinates are generated
/// or resolved when an inventory item is created or allocated, and further updated as the inventory item moves through
/// process or physically moves around. How inventory coordinates are used entirely depends on how a partner wants to use
/// them, with varying degrees of specificity possible.
public struct Opencannabis_Inventory_InventoryCoordinates {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location code. Specifies a physical location where the inventory product is held. This is the highest-resolution
  /// property specifying inventory coordinates. Optional.
  public var location: String = String()

  /// Zone code. This property is usually meant to be nested under the value for `location` - i.e., a zone code inside
  /// given location code. Optional.
  public var zone: String = String()

  /// Rack code. This property is optional and is usually meant to be nested under the value for `zone` - i.e., a rack
  /// code or number is inside a given zone which is inside a given location. Optional.
  public var rack: String = String()

  /// Shelf code. This property is optional and is usually meant to be nested under the value for `rack` - i.e., a shelf
  /// code or number is inside a given rack which is inside a zone which is inside a location. Optional.
  public var shelf: String = String()

  /// Bin code. This property is optional and is usually meant to be global, although it may be nested as well if bins
  /// are anonymous in the target partner system.
  public var bin: String = String()

  /// Batch code. Used to correlate test results and other data. Optional. Usually meant to be used as a global property,
  /// but can be nested under any of the other inventory coordinate values. How this property is used is determined by
  /// the hosting/invoking/subject partner.
  public var batch: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies an amount of a particular product, which may take a certain state as part of an inventory item, or batch of
/// inventory for a given product.
public struct Opencannabis_Inventory_InventoryAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of pricing/inventory to employ for this product. Can either be `UNIT` or `WEIGHTED` pricing.
  public var type: Opencannabis_Structs_Pricing_PricingType = .unit

  /// Specifies the unit basis for a subject inventory item. The unit basis is either set to `UNIT` pricing, or the
  /// weight used as a unit for inventory.
  public var basis: Opencannabis_Inventory_InventoryAmount.OneOf_Basis? = nil

  /// The inventory item is unit-based, i.e., just individual items.
  public var unit: Bool {
    get {
      if case .unit(let v)? = basis {return v}
      return false
    }
    set {basis = .unit(newValue)}
  }

  /// The inventory item is weight-based, i.e., a certain amount of grams or pounds.
  public var weight: Opencannabis_Structs_Pricing_PricingWeightTier {
    get {
      if case .weight(let v)? = basis {return v}
      return .noWeight
    }
    set {basis = .weight(newValue)}
  }

  /// Actual amount specified for the given inventory.
  public var quantity: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the unit basis for a subject inventory item. The unit basis is either set to `UNIT` pricing, or the
  /// weight used as a unit for inventory.
  public enum OneOf_Basis: Equatable {
    /// The inventory item is unit-based, i.e., just individual items.
    case unit(Bool)
    /// The inventory item is weight-based, i.e., a certain amount of grams or pounds.
    case weight(Opencannabis_Structs_Pricing_PricingWeightTier)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencannabis_Inventory_InventoryAmount.OneOf_Basis, rhs: Opencannabis_Inventory_InventoryAmount.OneOf_Basis) -> Bool {
      switch (lhs, rhs) {
      case (.unit(let l), .unit(let r)): return l == r
      case (.weight(let l), .weight(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Specifies the structure of an inventory state checkin, including the inventory item's status at the time the checkin
/// was submitted, timestamp information, and the set of coordinates where the checkin took place.
public struct Opencannabis_Inventory_InventoryState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the inventory item. Specifies the active state for the inventory item, from a set of enumerated standard
  /// inventory states.
  public var status: Opencannabis_Inventory_InventoryState.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Specifies the new (target) coordinates for a given inventory item, a change that occurred with a given inventory
  /// item checkin.
  public var coordinates: Opencannabis_Inventory_InventoryCoordinates {
    get {return _storage._coordinates ?? Opencannabis_Inventory_InventoryCoordinates()}
    set {_uniqueStorage()._coordinates = newValue}
  }
  /// Returns true if `coordinates` has been explicitly set.
  public var hasCoordinates: Bool {return _storage._coordinates != nil}
  /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
  public mutating func clearCoordinates() {_uniqueStorage()._coordinates = nil}

  /// Indicates whether the inventory item is fit for sale, or not. This flag must be set to `true` for an item to be
  /// eligible for listing.
  public var fitForSale: Bool {
    get {return _storage._fitForSale}
    set {_uniqueStorage()._fitForSale = newValue}
  }

  /// Amount of inventory, in this batch, that is on-hand.
  public var amount: Opencannabis_Inventory_InventoryAmount {
    get {return _storage._amount ?? Opencannabis_Inventory_InventoryAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// Timestamp for when this inventory state entry was created. Set after initially saving an inventory state checkin.
  public var created: Opencannabis_Temporal_Instant {
    get {return _storage._created ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  public var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  public mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// Timestamp for when this inventory state entry was updated, if applicable. Set after saving an existing inventory
  /// state checkin.
  public var modified: Opencannabis_Temporal_Instant {
    get {return _storage._modified ?? Opencannabis_Temporal_Instant()}
    set {_uniqueStorage()._modified = newValue}
  }
  /// Returns true if `modified` has been explicitly set.
  public var hasModified: Bool {return _storage._modified != nil}
  /// Clears the value of `modified`. Subsequent reads from it will return its default value.
  public mutating func clearModified() {_uniqueStorage()._modified = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Available statuses that an inventory item may take, in a given inventory step.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Specifies a status where a given batch of inventory has not yet been reconciled with ledger/database services,
    /// and is therefore considered ephemeral, or held-in-suspense, until further action is taken.
    case unreconciled // = 0

    /// Indicates a status where a given batch of inventory is currently in the process of being "received," consisting
    /// of initial unpackaging, re-packaging, and inventory checkin/update.
    case receiving // = 1

    /// Indicates a status where a given batch of inventory is held in quarantine, awaiting the results of lab testing,
    /// or regarded as unfit for sale for some other reason.
    case quarantine // = 2

    /// Indicates a status where a given batch of inventory is held on-hand in storage, awaiting further action.
    case onHand // = 3

    /// Status indicating that a product/inventory batch is currently listed for sale, or otherwise available for
    /// purchase, distribution, or resale.
    case forSale // = 4

    /// Indicates that a particular inventory batch is fully claimed, and may soon be committed, assuming payment
    /// settling and other steps take place.
    case claimed // = 5

    /// Indicates that a particular inventory batch or inventory item has been fully committed-to, meaning, it will soon
    /// or has already left the posession of the (now, or soon-to-be former) owning partner.
    case committed // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unreconciled
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unreconciled
      case 1: self = .receiving
      case 2: self = .quarantine
      case 3: self = .onHand
      case 4: self = .forSale
      case 5: self = .claimed
      case 6: self = .committed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unreconciled: return 0
      case .receiving: return 1
      case .quarantine: return 2
      case .onHand: return 3
      case .forSale: return 4
      case .claimed: return 5
      case .committed: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Opencannabis_Inventory_InventoryState.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencannabis_Inventory_InventoryState.Status] = [
    .unreconciled,
    .receiving,
    .quarantine,
    .onHand,
    .forSale,
    .claimed,
    .committed,
  ]
}

#endif  // swift(>=4.2)

/// Menu product payload stanza. Specifies a single product as a member of a menu section. This generic record is used to
/// wrap concrete menu product structures to make them generically usable. In V2 data stores, menu products are stored
/// generically as a top-level entity (as opposed to V1, in which this model is synthesized from raw map data).
public struct Opencannabis_Inventory_InventoryProduct {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key for this inventory item. Uniquely identifies the subject inventoried product, along with a globally-unique ID,
  /// which is set upon inventory item allocation (either provided explicitly or auto-generated).
  public var key: Opencannabis_Inventory_InventoryKey {
    get {return _storage._key ?? Opencannabis_Inventory_InventoryKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {_uniqueStorage()._key = nil}

  /// SKUs that should reference this inventory product. These are arbitrary strings that should map to this inventory
  /// item, potentially to/from foreign or 3rd-party systems.
  public var sku: [String] {
    get {return _storage._sku}
    set {_uniqueStorage()._sku = newValue}
  }

  /// Product variance specifications. Each variant spec describes a variance property and value for this product.
  /// Variance specifies how this particular batch of inventory is concretely parameterized, i.e., the "color" and "red"
  /// in "these hats are the color red."
  public var variant: [Opencannabis_Commerce_VariantSpec] {
    get {return _storage._variant}
    set {_uniqueStorage()._variant = newValue}
  }

  /// Current/active state for this inventory product. This includes the active status and coordinates for the item, with
  /// timestamping information detailing when the status last changed.
  public var state: Opencannabis_Inventory_InventoryState {
    get {return _storage._state ?? Opencannabis_Inventory_InventoryState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  /// Full history for an inventory product, including every inventory state for the item since its creation. Every item
  /// in inventory begins with exactly one history entry, stored in the `state` property. Once a second history entry is
  /// added for the inventory item, `history` is initialized with the old state as the first item, and `state` is
  /// replaced with the new state.
  public var history: [Opencannabis_Inventory_InventoryState] {
    get {return _storage._history}
    set {_uniqueStorage()._history = newValue}
  }

  /// Holds a menu product, including all referenced content, retail-side pricing, materials information (including test
  /// results), and so on.
  public var item: Opencannabis_Products_Menu_MenuProduct {
    get {return _storage._item ?? Opencannabis_Products_Menu_MenuProduct()}
    set {_uniqueStorage()._item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return _storage._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {_uniqueStorage()._item = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencannabis.inventory"

extension Opencannabis_Inventory_InventoryKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InventoryKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "uuid"),
  ]

  fileprivate class _StorageClass {
    var _key: Opencannabis_Base_ProductKey? = nil
    var _uuid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _uuid = source._uuid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeSingularStringField(value: &_storage._uuid)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_InventoryKey, rhs: Opencannabis_Inventory_InventoryKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_InventoryCoordinates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InventoryCoordinates"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "zone"),
    3: .same(proto: "rack"),
    4: .same(proto: "shelf"),
    5: .same(proto: "bin"),
    6: .same(proto: "batch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.location)
      case 2: try decoder.decodeSingularStringField(value: &self.zone)
      case 3: try decoder.decodeSingularStringField(value: &self.rack)
      case 4: try decoder.decodeSingularStringField(value: &self.shelf)
      case 5: try decoder.decodeSingularStringField(value: &self.bin)
      case 6: try decoder.decodeSingularStringField(value: &self.batch)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.rack.isEmpty {
      try visitor.visitSingularStringField(value: self.rack, fieldNumber: 3)
    }
    if !self.shelf.isEmpty {
      try visitor.visitSingularStringField(value: self.shelf, fieldNumber: 4)
    }
    if !self.bin.isEmpty {
      try visitor.visitSingularStringField(value: self.bin, fieldNumber: 5)
    }
    if !self.batch.isEmpty {
      try visitor.visitSingularStringField(value: self.batch, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_InventoryCoordinates, rhs: Opencannabis_Inventory_InventoryCoordinates) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.rack != rhs.rack {return false}
    if lhs.shelf != rhs.shelf {return false}
    if lhs.bin != rhs.bin {return false}
    if lhs.batch != rhs.batch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_InventoryAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InventoryAmount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "unit"),
    3: .same(proto: "weight"),
    4: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2:
        if self.basis != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.basis = .unit(v)}
      case 3:
        if self.basis != nil {try decoder.handleConflictingOneOf()}
        var v: Opencannabis_Structs_Pricing_PricingWeightTier?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.basis = .weight(v)}
      case 4: try decoder.decodeSingularUInt64Field(value: &self.quantity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unit {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.basis {
    case .unit(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    case .weight(let v)?:
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    case nil: break
    }
    if self.quantity != 0 {
      try visitor.visitSingularUInt64Field(value: self.quantity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_InventoryAmount, rhs: Opencannabis_Inventory_InventoryAmount) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.basis != rhs.basis {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_InventoryState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InventoryState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "coordinates"),
    3: .standard(proto: "fit_for_sale"),
    4: .same(proto: "amount"),
    98: .same(proto: "created"),
    99: .same(proto: "modified"),
  ]

  fileprivate class _StorageClass {
    var _status: Opencannabis_Inventory_InventoryState.Status = .unreconciled
    var _coordinates: Opencannabis_Inventory_InventoryCoordinates? = nil
    var _fitForSale: Bool = false
    var _amount: Opencannabis_Inventory_InventoryAmount? = nil
    var _created: Opencannabis_Temporal_Instant? = nil
    var _modified: Opencannabis_Temporal_Instant? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _coordinates = source._coordinates
      _fitForSale = source._fitForSale
      _amount = source._amount
      _created = source._created
      _modified = source._modified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._coordinates)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._fitForSale)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 98: try decoder.decodeSingularMessageField(value: &_storage._created)
        case 99: try decoder.decodeSingularMessageField(value: &_storage._modified)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._status != .unreconciled {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 1)
      }
      if let v = _storage._coordinates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._fitForSale != false {
        try visitor.visitSingularBoolField(value: _storage._fitForSale, fieldNumber: 3)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }
      if let v = _storage._modified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_InventoryState, rhs: Opencannabis_Inventory_InventoryState) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._coordinates != rhs_storage._coordinates {return false}
        if _storage._fitForSale != rhs_storage._fitForSale {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._modified != rhs_storage._modified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencannabis_Inventory_InventoryState.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNRECONCILED"),
    1: .same(proto: "RECEIVING"),
    2: .same(proto: "QUARANTINE"),
    3: .same(proto: "ON_HAND"),
    4: .same(proto: "FOR_SALE"),
    5: .same(proto: "CLAIMED"),
    6: .same(proto: "COMMITTED"),
  ]
}

extension Opencannabis_Inventory_InventoryProduct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InventoryProduct"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "sku"),
    3: .same(proto: "variant"),
    10: .same(proto: "state"),
    11: .same(proto: "history"),
    20: .same(proto: "item"),
  ]

  fileprivate class _StorageClass {
    var _key: Opencannabis_Inventory_InventoryKey? = nil
    var _sku: [String] = []
    var _variant: [Opencannabis_Commerce_VariantSpec] = []
    var _state: Opencannabis_Inventory_InventoryState? = nil
    var _history: [Opencannabis_Inventory_InventoryState] = []
    var _item: Opencannabis_Products_Menu_MenuProduct? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _sku = source._sku
      _variant = source._variant
      _state = source._state
      _history = source._history
      _item = source._item
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._sku)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._variant)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._state)
        case 11: try decoder.decodeRepeatedMessageField(value: &_storage._history)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._item)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._sku.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._sku, fieldNumber: 2)
      }
      if !_storage._variant.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._variant, fieldNumber: 3)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._history.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._history, fieldNumber: 11)
      }
      if let v = _storage._item {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencannabis_Inventory_InventoryProduct, rhs: Opencannabis_Inventory_InventoryProduct) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._sku != rhs_storage._sku {return false}
        if _storage._variant != rhs_storage._variant {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._history != rhs_storage._history {return false}
        if _storage._item != rhs_storage._item {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
